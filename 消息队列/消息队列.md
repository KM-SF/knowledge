### 为什么要使用消息队列

1. 限流削峰：MQ可以将系统的超量请求暂存其中，以便系统后期可以慢慢进行处理，从而避免了请求的丢失或系统被压垮![](/消息队列/images/限流削峰.png)
2. 异步解耦：上游系统对下游系统的调用若为同步调用，则会大大降低系统的吞吐量与并发度，且系统耦合度太高。而异步调用则会解决这些问题。所以两层之间若要实现由同步到异步的转化，一般性做法就是，在这两层间添加一个MQ层。![](/消息队列/images/异步解耦.png)
3. 分布式系：统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过MQ完成此类数据收集是最好的选择。

## 什么是 MQ

Message Queue（MQ），消息队列中间件。很多⼈都说：MQ 通过将消息的发送和接收分离来实现应⽤程序的异步和解偶，这个给⼈的直觉是——MQ 是异步的，⽤来解耦的，但是这个只是 MQ 的效果⽽不是⽬的。MQ 真正的⽬的是为了通讯，屏蔽底层复杂的通讯协议，定义了⼀套应⽤层的、更加简单的通讯协议。MQ 所要做的就是构建⼀个简单的“协议”——⽣产者/消费者模型。MQ 带给我的“协议”不是具体的通讯协议，⽽是更⾼层次通讯模型。它定义了两个对象——发送数据的叫⽣产者；接收数据的叫消费者， 提供⼀个SDK 让我们可以定义⾃⼰的⽣产者和消费者实现消息通讯⽽⽆视底层通讯协议。

## 为什么要引入MQ

1. **”削峰填谷”**，相信大家对这四个字也非常熟悉了，可以联想一下现实生活的三峡大坝，本质起到的作用是一样的。扩展解释一下，**所谓的“削峰填谷”就是指缓冲上下游瞬时突发的流量，使其更平滑。**对于发送能力很强的上游系统，如果没有消息引擎的保护，下游系统可能会直接被压垮导致全链路服务雪崩，消息引擎可以在很大程度上避免流量的震荡。平缓的应对突发的流量冲击
2. **解耦：**在于发送方和接收方的松耦合，减少系统间不必要的交互。减少系统之间的影响，提高系统的稳定性和可扩展性
2. 异步：异步能提高系统的响应速度和吞吐量

## 引入MQ后有什么缺点

1. 系统可用性降低：一旦MQ宕机，整个业务就会产生影响，对高可用较高
2. 系统的复杂度提高：引入MQ后，业务的数据链路变得很复杂，需要保证消息不丢失，不重复消费，顺序消费等等
3. 数据一致性：A系统发消息，需要由B,C两个系统一同处理。如果B系统处理成功，C系统处理失败，会造成数据一致性问题

## 消息队列的种类

#### 目前消息队列的中间件选型很多种：

+ rabbitMQ：内部的可玩性（功能性）是非常强
+ rocketMQ：阿里。性能是与kafka相比肩，除此之外还封装了更多功能
+ kafka：最快MQ
+ zeroMQ

#### 这些消息队列中间件有什么区别？

broker：这个流派通常有⼀台服务器作为 Broker，所有的消息都通过它中转。⽣产者把消息发送给它就结束⾃⼰的任务了，Broker 则把消息主动推送给消费者（或者消费者主动轮询）

##### 有broker

+ 重topic：整个broker依据topic来进行消息中转。在重topic的消息队列里必然需要topic的存在。kafka，RocketMQ
+ 轻topic：RabbitMQ。topic可有可无，只是一种中转模式

##### 无broker

在生产者和消费者之间没有使用broker，例如：zeroMQ，直接使用socket进行通信