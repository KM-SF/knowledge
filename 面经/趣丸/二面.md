### 你们的redis用来做什么

我们用redis来保存门店信息，优惠券信息，召回数据和降级数据

### 你们redis的部署模式是什么

我们用到的codis集群，就是客户端分片模式

### 了解cluster集群嘛

+ 通过哈希的方式，将数据分片，每个节点均分存储一定的哈希槽（哈希值）区间的数据，默认分配了16384个槽位
+ 数据分片存储在多个互为主从的多个节点上（16384个槽均分到每个节点上）
+ 数据先写入主节点，再同步到从节点（支持配置为阻塞同步）
+ 同一分片多个节点间的数据不保证强一致性
+ 读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
+ 扩容时需要把旧节点的数据迁移一部分到新节点
+ 在redis cluster架构下，每个redis要放开两个端口，例如：一个6379，另外一个就是加上1W的端口16379。另外一个端口是用来进行节点间通信的，也就是cluster bus的通信。用来进行故障检测，配置更新，故障转移授权。
+ cluster bus用了另外一种二进制的协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间

### 那codis这个代理模式你觉得有什么必要。跟cluster集群有什么区别，分别有优缺点

|              | codis            | cluster  |
| ------------ | ---------------- | -------- |
| 数据库数量   | 16               | 1        |
| 不支持命令   | keys             | select   |
| dashboard    | 有               | 没有     |
| 可视化客户端 | 有               | 没有     |
| 集群结构     | 代理             | 去中心化 |
| 哈希槽       | 1024             | 16394    |
| 升级         | 无法保证后续升级 | 官网保证 |
| 部署         | 较为复杂         | 简单     |
| 自动均衡     | 是               | 否       |

### 这两种模式，有什么常规命令不能使用

codis：keys

cluster：select，met

### 为什么cluster集群要能使用pipeline

不同key可能落到不同的哈希槽上，不能用mget获取。所以只能使用pipeline，一个一个获取

### go是一门面向对象的语言吗

是,也不是.虽然Go语言可以通过定义类型和方法来实现面向对象的设计风格,但是Go是实际上并没有继承这一说法.在Go语言中,interface(接口)这个概念以另外一种角度展现了一种更加易用与通用的设计方法.在Go中,我们可以通过组合,也就是将某个类型放入另外的一个类型中来实现类似继承,让该类型提供有共性但不相同的功能.相比起C++和Java,Go提供了更加通用的定义函数的方法,我们可以指定函数的接受对象(receiver),它可以是任意的类型,包括内建类型,在这里没有任何的限制.

同样的,没有了类型继承,使得Go语言在面向对象编程的方面会显得更加轻量化

+ 有用到设计模式和编码范式吗？
+ 在go怎么实现工厂模式
+ 你们会写单元测试
+ 如果为了你方便写单元测试，那你的代码书写有什么要求
+ 单例模式是有利于单元测试还是无利于单元测试

### 写一个程序判断这个机器是64位还是32位（用go和cpp都可以）

判断一个指针大小是8字节还是4字节。8字节64位，4字节32位

### 场景题：一群用户进入到一个房间，那么房间就有一个用户列表。统计每1分钟，5分钟，10分钟，所有玩家的发言次数。并且排序输出最活跃的玩家。（分布式的，微服务的架构。每个用户可能连接到不同的服务节点）

因为不同的玩家可能链接到不同的服务端，所以无法使用本地内存做处理

1. 使用redis的list结果，保存每个玩家的1分钟（提交的频率可以修改）的发言次数（id：次数）。
2. 使用redis的zset进行排序输出。例如5分钟内的结果，就是用滑动窗口获取list中5分钟的数据（5个1分钟）。然后保存到zset中排序

### 场景题：随时都能统计所有用户的积分剩余情况。

流水表和积分表。

1. 先获取积分表中的当前的积分数据
2. 根据流水表可以得到该用户从当前时间和统计时间之间的所有消费记录
3. 累加积分表和水流表消费积分即可

### 场景题：付费和下单这两个事务怎么保证要不都成功，要不都失败。

前置预留资源+用RocketMQ的事务消息