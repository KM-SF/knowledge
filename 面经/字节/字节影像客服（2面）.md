## 知识点

+ 讲下第一个项目
+ 你们平时是怎么测试性能指标的
+ 顺序写和随机写正常情况下哪个比较快

> 顺序写比较快，随机写还涉及到磁盘磁道的寻址。

+ 说下文件系统

> 1. ext系统由一个启动块和多个块组组成
> 2. 每个块组由多个块组成。超级块，块组描述符表，块位图，inode位图，inode表，数据块组成。而超级块和块组描述符表每个块组都一样，一般都是0号块组的副本。
> 3. 超级块：描述**整个分区**的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。
> 4. 块组描述表：描述一个块组的信息（有多少个inode，多少个数据块等等）。是所有块组的集合，在每个块组都会备份一份
> 5. 块位图：描述整个块组中哪些块已用哪些块空闲的，那些块已经用了
> 6. inode位图：描述哪些inode块已经使用
> 7. inode表：inode块集合，inode块保存文件信息
> 8. 数据块：保存数据

+ 文件系统下的读写过程清楚吗

> 1. 程序调用read或者write的系统调用函数
> 2. 系统调用函数会触发一个80的软中断
> 3. 软中断的过程会把把对应的**系统调用后（内核函数数组对应的下标）**放在eax寄存器里面。每个系统调用函数都有对应的一个内核函数，该函数保存再一个数组中。
> 4. 然后会执行sys_calltable函数，实际上就是执行内核函数（ 系统调用函数对应的内核函数sys_write）
> 5. 然后内核函数里面会通过vfs得到具体对应的是哪个文件系统
> 6. 然后vfs就调用对应文件系统的具体函数。

+ iscsi的客户端要怎么实现（考察底层，用户可以不感知的情况下直接调用write和read函数）

> 自己做一个文件系统，然后文件系统底层实现的就是通过iscsi协议调用服务端的接口。

+ 什么是reator
+ 为什么reator比较快
+ reator在fd较少的情况下性能如何
+ iscsi协议是基于哪一层实现的（网络协议）
+ 为什么iscsi协议是使用TCP
+ TCP为什么可靠

> 1. 序号/应答机制：数据传输的顺序行
> 2. 超时重传机制：发送数据后，启动计时器，在超时时间内没有收到ack确认序号，会重发数据包
> 3. 数据头部校验：TCP保证它的头部和数据的校验和，如果数据包有差错，就丢弃数据不进行ACK
> 4. 滑动窗口：告诉对方，我这里的缓冲区剩余大小是多少。防止对方发送的数据量大于我缓冲区剩下的大小
> 5. 拥塞控制：在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。
> 6. 最大报文长度：在建立TCP的时候，会约定数据包的最大长度，超过该长度会进行切分

+ UDP要怎么实现可靠性
+ 自己实现一个拥塞控制

## 算法题

二叉树的左视图（递归和非递归）

