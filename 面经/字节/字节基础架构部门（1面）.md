# 项目

+ 自我介绍
+ 介绍下tgtd项目
+ VS后端存储的整体架构
+ 分片层的作用
+ 底层副本写失败怎么办
+ 你们底层是用了几个副本
+ 仲裁节点挂了会怎么样
+ 如果一个写成功一个写失败会怎么样（仲裁节点在不在线两种情况）

# 分布式

+ raft协议你了解吗

  > https://zhuanlan.zhihu.com/p/91288179
  >
  > raft是工程上使用较为广泛的强一致性。raft是一个共识算法（consensus algorithm），所谓共识，就是多个节点对某个事情达成一致的看法，即使是在部分节点故障、网络延时、网络分割的情况下

+ raft协议里面的一个细节：数据写着写着分叉了怎么办，数据分叉是什么意思

  > 可能是想说脑裂

+ raft协议写数据的时候会记录他当前的term。term是什么意思

  > 在Raft协议中，将时间分成了一些任意长度的时间片，称为term，term使用连续递增的编号的进行识别
  >
  > 每一个term都从新的选举开始，candidate们会努力争取称为leader。一旦获胜，它就会在剩余的term时间内保持leader状态，在某些情况下(如term3)选票可能被多个candidate瓜分，形不成多数派，因此term可能直至结束都没有leader，下一个term很快就会到来重新发起选举。
  >
  > term也起到了系统中逻辑时钟的作用，每一个server都存储了当前term编号，在server之间进行交流的时候就会带有该编号，如果一个server的编号小于另一个的，那么它会将自己的编号更新为较大的那一个；如果leader或者candidate发现自己的编号不是最新的了，就会自动转变为follower；如果接收到的请求的term编号小于自己的当前term将会拒绝执行。

+ 写日志都会有一个term和index。正常情况term和index的数据应该是一样的。异常场景某个节点不断挂不断起，然后它的term和index的数据不一样，那是怎么裁决哪个数据是正确的

  > 在Raft中，leader通过强制follower复制自己的日志来解决上述日志不一致的情形，那么冲突的日志将会被重写。为了让日志一致，先找到最新的一致的那条日志(如f中索引为3的日志条目)，然后把follower之后的日志全部删除，leader再把自己在那之后的日志一股脑推送给follower，这样就实现了一致。而寻找该条日志，可以通过AppendEntries RPC，该RPC中包含着下一次要执行的命令索引，如果能和follower的当前索引对上，那就执行，否则拒绝，然后leader将会逐次递减索引，直到找到相同的那条日志。

# 数据库

+ mysql中的redo log和undo log分别是什么

  > redo log ：
  >
  > 内容：物理格式的日志，记录的是物理数据页面的修改的信息，其redo log是顺序写入redo log file的物理文件中去的。
  >
  > 作用：确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

  > undo log：
  >
  > 作用：保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读
  >
  > 内容：逻辑格式的日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的。

+ mysql的checkpoint的作用是什么

  > https://www.e-learn.cn/topic/2688022
  >
  > + checkpoin：是重做日志对数据页刷新到磁盘的操作做的检查点，通过LSN号保存记录，作用是当发生宕机等crash情况时，再次启动时会查询checkpoint点，在该检查点之后发生的事物修改恢复到磁盘。
  >
  > + Checkpoint解决的三个问题：
  >   1. 解决了数据库恢复慢的问题(redo log循环写)
  >   2. 缓冲区不够用的问题(脏页比例达到75%强制刷新到磁盘)
  >   3. 重做日志不可用问题(在redo log的write追上checkpoint时刷新脏页到磁盘)
  >
  > + InnoDB存储引擎内部，**两种checkpoint**，分别为:
  >   + Sharp Checkpoint 适用于数据库关闭时的一致性刷新 (数据库关闭时 触发)
  >   + Fuzzy Checkpoint 适用于数据库运行时的部分页刷新 (数据库运行时周期性触发)

+ mysql写数据的过程是怎么样的，怎么落盘的

  > InnoDB在缓冲池中变更数据时，会首先将相关变更写入重做日志缓冲中，然后再按时或者当事务提交时写入磁盘，这符合Force-log-at-commit原则；当重做日志写入磁盘后，缓冲池中的变更数据才会依据checkpoint机制择时写入到磁盘中，这符合WAL原则。

+ mysql是每写一条数据都要落盘是吗

  > 操作系统的文件系统是带有缓存的，当InnoDB向磁盘写入数据时，有可能只是写入到了文件系统的缓存中，没有真正的“落袋为安”。 InnoDB的innodb_flush_log_at_trx_commit属性可以控制每次事务提交时InnoDB的行为。当属性值为0时，事务提交时，不会对重做日志进行写入操作，而是等待主线程按时写入；当属性值为1时，事务提交时，会将重做日志写入文件系统缓存，并且调用文件系统的fsync，将文件系统缓冲中的数据真正写入磁盘存储，确保不会出现数据丢失；当属性值为2时，事务提交时，也会将日志文件写入文件系统缓存，但是不会调用fsync，而是让文件系统自己去判断何时将缓存写入磁盘。

+ mysql的acid是什么，分别的含义是什么

  > + 原子性：最小单元，整个事务的所有操作要么做，要么都不做 （undo log）
  > + 一致性：从一种一致性状态转换为另一种一致性状态，事务开始/结束都保证完整性 
  > + 隔离性：并发执行的各个事务之间不相互干扰
  > + 持久性：事务一旦提交，结果将永久保存在数据库中（redo log）

+ mysql的一致性是怎么保证的

  > 基于原子性，隔离性和持久性完成

# 操作系统

+ 多核CPU中的一级缓存和二级缓存，一级缓存是每个CPU独有的，二级缓存是每个CPU共享的，怎么保证数据一致，多核CPU的数据怎么保证一致

  > https://www.cnblogs.com/caibixiang123/p/9326714.html
  >
  > 在MESI协议中，每个cache line有4个状态，可用2个bit表示，它们分别是：
  >
  > | 状态         | 描述                                                         |
  > | ------------ | ------------------------------------------------------------ |
  > | M(Modified)  | 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 |
  > | E(Exclusive) | 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。 |
  > | S(Shared)    | 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。 |
  > | I(Invalid)   | 这行数据无效                                                 |
  >
  >   MESI为了保证多个CPU缓存中共享数据的一致性，定义了cache line的四种状态，而CPU对cache line的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的cache line 状态进行一致性修改，从而保证数据在多个缓存之间保持一致性(M:modified  E:Exclusive  S:shared  I:invalid) 。

+ 多线程中的锁有什么

  > 互斥锁，条件变量，自旋锁，读写锁，CAS，原子操作

+ 什么是原子操作

  > 原子操作，它表示在多个线程访问同一个全局资源的时候，能够确保所有其他线程都不在同一时间访问该资源。也就是确保了在同一时刻只有一个线程对这个资源进行访问。这有点类似互斥对象对共享资源的访问的保护，但是原子操作更加接近底层，因而效率更高

# 闲聊

+ 最近一年工作中最困难的事情是什么
+ 你的框架有没有参考一些其他公司的开源框架和开源源码
+ 这个项目（tgtd）做了多久

# 算法

+ 单链表K翻转