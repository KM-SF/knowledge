### 1. 语法题

```go
func fun() {
	s1 := [3]int{1, 2, 3}
	s2 := [3]int{1, 2, 3}
	b := (s1 == s2) // 能不能执行成功，如果能结果是什么
	fmt.Print(b)	// 答：可以比较返回false，原因数组的长度固定，可以每个元素比较

	ss1 := []int{1, 2, 3}
	ss2 := []int{1, 2, 3}
	b = (ss1 == ss2) // 能不能执行成功，如果能结果是什么
	fmt.Print(b)	// 答：不可以比较，原因切片长度不固定，无法比较

	var m1 map[string]int
	m1["one"] = 1	
	m2 := make(map[string]int)
	m2["one"] = 2
	b = (m1 == m2) // 能不能执行成功，如果能结果是什么
	fmt.Print(b)	// 答：会panic，m1是空指针。且map不能比较，原因map的hash结构不一样，是无序的

	m3 := make(map[string]int)
	m3["one"] = 1
	m3["two"] = 2
	m3["three"] = 3
	for key, _ := range m3 {
		fmt.Print(key) // 输出结果是什么
        // 随机输出，因为map无须
	}
	for key, _ := range m3 {
		fmt.Print(key) // 结果会跟上面一样吗
        // 不一样，遍历map是无序
	}
	for key, _ := range m3 {
		fmt.Print(key) // 结果会跟上面一样吗
        // 不一样，遍历map是无序
	}
}
```

### 2. go的协程调度机制

基于CSP并发模型开发了GMP调度器，其中 

+  **G（Goroutine）** : 每个 Goroutine 对应一个 G 结构体，G 存储 Goroutine 的运行堆栈、状态以及任务函数

- **M（Machine）**: 对OS内核级线程的封装，数量对应真实的CPU数(真正干活的对象).
- **P (Processor)**: 逻辑处理器,即为G和M的调度对象，用来调度G和M之间的关联关系，其数量可通过 GOMAXPROCS()来设置，默认为核心数。

P和M是11关系，但是会存在M>=P的情况。G的创建会优先保存到P的本地队列上，如果P的本地队列已满则扔到全局队列。当一个G要执行时，则M上运行的goroutine切换为G0，G0负责调度时协程的切换，会优先从P的本地队列取到G，如果本地队列为空，则从全局队列或者其他P的队列偷取G，并开始运行G。

### 3. 并发题：（滴滴app的场景，主页同时渲染三个数据）

1. 有一个协程rpc获取的个人信息
2. 有一个协程rpc获取你所在位置附近地理信息
3. 有一个协程rpc获取其他的功能（我的订单，历史记录等等）
4. 要求以上三个rpc数据都放到同一个队列（假设能放到同一个队列），而且需要有超时保护，防止一次rpc等待太久，无法渲染主页

```
我回答用sync.WaitGroup+ctx.WithTimeOut+AfterTime+select
面试官实际想说用channel去处理
```

### 4. mysql的慢查询

### 5. redis有哪些常用的数据结构和对应使用场景

1. string：缓存功能，计数器
2. list：消息队列
3. set：标签，共同好友
4. zset：排行榜
5. hash：存储用户相关信息

### 6. list和set有什么区别

1. list是可以重复的，set不可重复
2. list支持顺序读写，set随机读写

### 7. 对set中add一个已有的元素，那他是报错还是覆盖

会忽略

### 8. redis它是一个单线程的，那他是怎么处理网络并发请求的

使用的是非阻塞的io多路复用技术（epoll）

### 9. 你详细介绍下怎么多路复用（我回答了epoll的三个函数和对应的底层原理）

+ 底层实现原理：
  + 当内核初始化epoll时，会开辟一块内核高速cache区，用于安置我们监听的socket，这些socket会以红黑树的形式保存在内核的cache里，以支持快速的查找，插入，删除．同时，建立了一个list链表，用于存储准备就绪的事件．所以调用epoll_wait时，在timeout时间内，只是简单的观察这个list链表是否有数据，如果没有，则睡眠至超时时间到返回；如果有数据，则在超时时间到，拷贝至用户态events数组中．
  + 那么，这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。
+ epoll_create：创建一个 epoll 文件描述符，底层同时创建一棵红黑树 and 一个就绪链表 rdlist。红黑树存储了所有监控的文件描述符；就绪链表存储就绪文件描述符
+ epoll_clt：
  + 删除：将文件描述符从红黑树上摘除
  + 插入：先查看红黑树是否有该 fd：如果有，不再插入；如果没有，插入。（epoll 使用“事件”的就绪通知方式，通过 epoll_ctl 注册 fd，一旦该 fd 就绪，内核就会采用类似callback 的回调机制来激活该 fd，epoll_wait 便可以收到通知）
+ epoll_wait：只是从就绪链表中取出元素，将该元素上的事件复制到用户态区间（使用 mmap 提高效
  率）

### 10. 如果访问一个大key那么会不会阻塞后面的请求

会

### 11. 你在使用过程中有出现这种情况吗

没有

### 12. 你怎么设计访问大key不会阻塞后面的请求

```
我回答了用：
1. 多线程方式处理。（为什么redis还是用单线程处理，不是用多线程）
	1. 我回答多线程并发需要加锁，而且实现的复杂度也比较高
2. 用零拷贝和多进程（redis的对多线程处理并没有强大，如何不破坏单线程的情况解决这个问题）

面试官给的答案：（讲思路，不用考虑可行性）
1. 判断如果是大key，超过多大则直接返回错误
2. 按照时间片切分，一次只处理一部分，然后再排队（类似于进程时间片切换）
```
