## 项目

+ 项目介绍
+ glfs支不支持远端访问的方式？如果支持为什么还需要做一个tgtd作为中间层，转发到glfs那边
+ tgtd的工作分工
+ 这个tgtd的想法是谁想的
+ 你们的工作流程是怎么样的
+ 项目发开完后的效果
+ 性能提升是相对什么比较
+ 线程池里面处理的任务是同步的吗
+ IO请求处理完成后，是怎么处理子Reactor和fd关联上，触发OUT事件的？
+ IO请求发送的glfs是阻塞还是非阻塞的
+ glfs的API支不支持异步的。
+ 如果glfs的API是异步的话，是怎么使用

## 基础知识

+ 对epoll的作用（跟poll和select的优点）

  ```
  1. 没有最大连接数有上限
  2. 不用对fd集合进行轮询扫描
  3. 不需要将fd集合从内核和用户空间来回拷贝
  ```

  epoll里面有用到共享内存吗

  ```
  应该是没有用到共享内存的
  ```

  共享内存是存在进程空间的哪部分

  ```
  保存在进程空间中的用户空间。用户空间里面的共享区（文件映射区）
  ```

+ 进程空间分为哪几部分

  ```
  进程有4G的内存空间，0~3G是用户空间，3~4G是内核空间
  ```

  用户空间分为哪几个区（提示mmap存放的位置）

  ```
  栈区，堆区，bss区，堆区，代码常量区，共享区（文件映射区）
  ```

+ C++中的多态的实现原理

  ```
  多态的实现主要分为：静态多态和动态多态
  
  静态多态主要是通过**重载和模板技术**实现，在编译的时候确定
  
  动态多态是用虚函数机制实现的（覆盖），在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
  
  虚函数的实现：在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。
  ```

+ 是一个类有一个虚表，还是一个对象一个虚表

  ```
  一个类有一个虚表
  同一个类的不同实例对象，公用一份虚函数表！它们的 Vptr 指向相同的虚函数表。
  ```

+ 那一个对象有一个虚函数指针，还是一个类一个虚函数指针

  ```
  一个对象有一个虚函数指针
  同一个类的不同实例对象，拥有不同的虚函数指针，但是指向同一个虚函数表
  ```

+ 那如果是多继承呢。虚函数指针和虚函数表分别是几个（针对类和对象）

  ```
  https://blog.csdn.net/qq_36359022/article/details/81870219
  
  在多继承情况下，有多少个基类就有多少个虚函数表，每个对象就有多少个虚函数指针表。前提是基类要有虚函数才算上这个基类。
  ```

+ 以下输出结果是什么：

  ```c++
  
  class parent {
   public:
    virtual void foo() { cout << "parent" << endl; }
  };
  
  class son : public parent {
   public:
    void foo(int i = 1) { cout << "son" << endl; }
  };
  
  int main() {
    parent p;
    son s;
    p.foo();	// parent
    s.foo();	// son
  
    parent* pp = &s;
    son* ps = &s;
    pp->foo();	// parent
    ps->foo();	// son
    return 0;
  }
  ```

+ C++中的隐藏和覆盖

  ```
  覆盖指的是子类覆盖父类函数（被覆盖），特征是：
  1.分别位于子类和父类中
  2.函数名字与参数都相同
  3.父类的函数是虚函数（virtual）
  
  隐藏指的是子类隐藏了父类的函数（还存在），具有以下特征：
  子类的函数与父类的名称相同，但是参数不同，父类函数被隐藏
  子类函数与父类函数的名称相同，参数也相同，但是父类函数没有virtual，父类函数被隐藏
  ```

  ```
  总结：
  IF 子类的函数与父类的名称相同，但是参数不同
  
  　　父类函数被隐藏
  
  ELSE IF 子类函数与父类函数的名称相同&&参数也相同&&但是父类函数没有virtual
  
  　　父类函数被隐藏
  
  ELSE IF 子类函数与父类函数的名称相同&&参数也相同&&但是父类函数有virtual
  
  　　父类函数被覆盖
  ```

+ 哈希冲突的解决方式

  ```
  （闭散列）开放定址法（再散列法）：当 key 的哈希地址 p=H(key)冲突时，以 p 为基础，产生另一个哈希地址 p1，...，直到找到一个不冲突的哈希地址 pi，将元素放入其中
  
  （开散列）链式定址法：将哈希值相同的元素，挂在一个链表上
  ```

+ 有一个单核的机器，有一个程序A功能就是死循环cout语句。那这个时候将这个A启动后，CPU负载会很高。那这个时候能不能在启动一个A程序

  ```
  可以启动
  ```

+ 如果能再起来一个的话，那么这两个程序CPU负载使用比例会是怎么样

  ```
  我认为CPU负载比例应该是各50%，因为当一个进程的时间片用完后会退出CPU的使用权，由另外一个进程占用
  ```

+ mysql里面的存储引擎中的InnoDB是用什么来实现的

  ```
  底层实现是用B+树。
  ```

+ 内核里面的内存是怎么管理的（怎么解决碎片问题）

  ```
  https://blog.csdn.net/aurorayqz/article/details/79671785
  
  内存管理做一个简单介绍
  linux kernel 通过把整个物理内存划分成以一个个page进行管理，管理器就是伙伴系统，它的最小分配单元就是page。但是对于小于page的内存分配，如果直接分配一个page，是一个很大的浪费。linux kernel 通过slab来实现对小于page大小的内存分配。slab把page按2的m次幂进行划分一个个字节块，当kmalloc申请内存时，通过slab管理器返回需要满足申请大小的最小空闲内存块。
  slub主要是针对slab的对象管理数据的优化版本，相比于slab，slub提供更小的管理成本开销。而且slub对多核系统的支持也更加友好。细节这里就不展开讲。
  所以kernel的内存管理是个2层分层系统，从下往上依次为：
  第一层为全部物理内存：其管理器为伙伴系统，最小管理单位为page；
  第二层为slab page：其管理器为slab/slub，最小管理单位为2的m次幂的字节块；
  ```

  ```
  内存碎片：
  伙伴算法，用于管理物理内存，避免内存碎片;
  高速缓存Slab层用于管理内核分配内存，避免碎片。
  ```

+ 在网络中的ping命令他是怎么实现的

  ```
  向远程计算机通过ICMP协议发送特定的数据包，然后等待回应并接收返回的数据包 ，对每个接收的数据包均根据传输的消息进行验证。默认情况下，传输四个包含 32 字节 
  数据（由字母组成的一个循环大写字母序列）的回显数据包。
  过程如下： 
  （1）通过将 ICMP 回显数据包发送到计算机并侦听回显回复数据包来验证与一台或多台 远程计算机的连接。  
  （2）每个发送的数据包最多等待一秒。  
  （3）打印已传输和接收的数据包数。  
  ```

+ ICMP包他的头部是IP头部吗（他是位于IP协议上的还是以太网协议上的）

  ```
  ICMP使用IP的基本支持，就像它是一个更高级别的协议，但是，ICMP实际上是IP的一个组成部分，必须由每个IP模块实现。他位于网络层。
  ```

+ 他为什么需要IP头部

  ```
  因为ICMP实际上是IP的一个组成部分，必须由每个IP模块实现
  ```

+ 为什么TIME_WAIT需要2MSL时长，而不是1MSL时长

  ```
  1MSL：为1段TCP报文再传输过程中最大生命周期
  
  等待2MSL的根本原因，为了实现TCP全双工可靠的释放
  	在第4次挥手时，C端向S端发送最后的ACK，也可能会丢失，导致S端收不到该确认报文。当S端在1MSL时间内没有接收到C端发送的ACK确认报文时，S端会再次向C端**重新发送FIN报文（重传机制）**。C端收到FIN报文后，会重新发送最后一个ACK报文，直到S端能成功的接收到ACK报文，连接才真正的断开。
  	
  为了使就得数据包在网络中因过期而消失（防止被动方收到主动方发送的过期数据）
  	先假设没有TIME_WAIT状态的限制，如果当前有一个TCP连接（local_ip，local_port，remote_ip，remote_port）在断开的同时，以相同的4元组去建立新的连接。那么TCP协议栈就无法区分前后两条tcp连接是不同的，在它看来就一条连接。导致前一条TCP已经关闭的连接发送出去的数据，，通过之后的新连接，仍然可以发送给s端
  ```

+ 如果不释放的话，会占用什么资源

  ```
  不释放的话，会占用fd和缓冲区
  ```

+ 为什么会占用fd

  ```
  因为网络通信就是通过fd来交互的
  ```

## 设计题

+ 现在有一个IP段（1.1.1.1~2.2.2.2）会保存一些城市信息（城市名词，人口数量等等）
+ 现在有很多IP段有对应的城市信息（数据存在数据库中）
+ 现在设计一个输入IP，需要返回一个城市的信息（需要支持海量数据查询）

答：

```
1. 使用一个红黑树保存对应的IP段，因为红黑树的操作时间复杂度都是nlgn，输入一个IP就能快速查询到一个该IP所处于的IP段
2. 再用一个hasp_map保存对应数据。key就是这个IP段，value就是对应的城市信息。通过红黑树查询的IP段就能得到对应的城市信息
```

