# 流程：

1. 先自我介绍
2. 笔试
3. 面试

# 笔试

+ 已知有C语言定义 char a[] = {0, 1, 2, 3, 4};那么表达式 a[0] += 0x100 + *a + strlen(a) + sizeof(a)的值是？

+ 下面的sizeof(A) 的值是

  ```c++
  已知有结构体 A的定义
  struct A
  {
      char a; 1 
      int b[0]; 4 //8
      short c; 2 // 12
  };
  ```

+ 下面的函数用于将整数转为十进制字符串，请找出其中所有的问题并改正它们。

  ```C++
  char *num2str(int num, char *str_result, int size)
  {
      char *p = str_result;
  	if (num < 0) {			//提醒加上的
  		num * = -1;			//提醒加上的
  		*(p++) = '-';		//提醒加上的
  	}						//提醒加上的
  		
      // 找到个位数在字符串中所在的位置
      for (int divsor = 10; num / divsor != 0; divsor *= 10)
          p++;
  
      // 从尾向头将整数逐字转为字符串
      while (num) {
          *(p--) = '0' + num % 10; // 我改的
          num /= 10;
      }
      p[size] = '\0'; // 提醒加上的
      return str_result;
  }
  ```

+ 在 Linux环境下用 gcc构建一个 C/C++程序时，编译器报"undefined reference to..."的错误，请分析可能存在哪些问题，怎样解决？

+ 将一个数组的所有元素向右移动若干单位 ，并把数组右侧溢出的元素填补在数组左侧的空缺中，这种操作称为数组的循环平移 。给你一个不少于3个元素的数组a，已知 a是从一个有序且不包含重复元素的数组循环平移k（k大于等于0且小于数组长度）个单位而来。请写一个函数，输入int类型数组a，返回k的值

# 面试

+ 内存对齐有什么用

1. 平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。

2. 性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。CPU总是以其字大小（32位处理器上为4个字节）读取数据，所以当您在支持它的处理器上进行未对齐的地址访问时，处理器将读取多个字。CPU将读取您请求的地址所跨越的每个内存字。这将导致访问请求数据所需的内存事务数增加至多2倍。

+ 数据库有了解吗 
+ 怎么把多线程用起来
+ 线程数量个数怎么定
+ 粘包问题
+ 对单个socket的事件，要有序的。这个怎么保证。（应该是ADD run DEL）