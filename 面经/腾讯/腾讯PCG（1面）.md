# C++

+ C++是怎么通过虚函数实现多态的
  
  + 父类声明了一个虚函数，那么该父类的内存中有一个虚函数指针。该指针指向虚函数指针表。该表保存了所有虚函数的地址。子类继承该父类，该虚函数指针表也会继承过来。然后重写了父类的虚函数，那么该虚函数指针表中对应的虚函数地址会被子类的虚函数地址覆盖。然后通过父类的指针指向子类的对象，调用虚函数就能调用到子类的虚函数
  
+ C++函数的调用原理（函数A调用函数B的过程）

+ 引用和指针有什么区别

  + 引用是一个变量的别名，操作这个引用就相当于操作这个变量。指针是指向一个变量的地址，操作指针需要对指针进行解引用
  + 指针有自己的一个内存空间，而引用没有
  + 指针初始化可以为NULL，而引用必须是一个已经存在的变量的引用
  + 指针初始化后可以修改指向重新赋值，而引用不能重新赋值
  + 有const指针，没有const引用
  + 如果要返回一个动态分配的内存或者对象，只能返回指针，不能返回引用。返回引用会造成内存泄漏
  + sizeof 指针的话是4字节，而引用则是被引用对象的大小
  + 有多级指针，没有多级引用
  + 指针和引用使用运算符++的含义不同

+ 怎么样通过一个函数的参数来进行返回值（参数类型）

  + 可以声明指针或者引用

+ C++的一个函数，返回多个值是什么实现的

  + 参数都设置成指针或者引用（int *fun(int *ret1, int *ret2, int &ret3, int &ret4)）

+ const int * Class:Func(const int * const val) const; 说下每个const的作用（从左往右）

  + 第一个const：返回值不能被修改。表示只读
  + 第二个const：该指针指向了了一个地址，不能通过指针修改该地址上的值
  + 第二个const：该指针不能重新指向一个新地址
  + 第四个const：防止成员函数修改被调用对象的值

+ STL的vector的底层存储机制是怎么样子的

  + vector底层是由数组实现的。它的扩容机制是：2倍增长

+ 查找算法有用到哪些？

  + 顺序查找：二分查找，分块查找
  + 树型查找：二叉搜索树（二叉查找树）
  + Hash表查找

+ 哈希查找是怎么实现的

  + 通过哈希函数直接定位哈希桶，但是可能会出现哈希冲突的情况

+ 哈希函数得到的val有重复的情况怎么解决（哈希冲突）

  + 开放定址法：当 key 的哈希地址 p=H(key)冲突时，以 p 为基础，产生另一个哈希地址 p1，...，直到找到一个不冲突的哈希地址 pi，将元素放入其中
  + 链式定址法：将哈希值相同的元素，挂在一个链表上

+ 哈希查找的时间复杂度

  + 正常情况没有冲突，就是O(1)
  + 如果有冲突且是用拉链法的话，就是O(1) + O(n)（加上链表长度）

+ 冒泡排序的思想

  + 从数组中第一个数开始，依次遍历数组中的每一个数，通过相邻比较交换，交换较大的值。每一轮循环下来找出剩余未排序数的中的最大数并“冒泡”至数列的顶端。

+ 设计模式里面的单例是怎么实现

  + 构造函数声明为 private，且不实现（不允许再次构造）
  + 定义一个static 类型变量（确保类中只有一个实例）
  + 提供能够对该实例访问的全局接口（返回值类型 static 类名*）

+ 单例是线程安全的吗

  + ```c++
    // 饿汉式：不管你使用不使用我，我一开始就把你 new 出来（不存在线程安全的问题）
    class Singleton
    {
    private:
      Singleton(){}
      static Singleton *single;
    
     public:
      static Singleton* getInstance() { return single; }
    };
    Singleton* Singleton::single = new Singleton();//创建实例
    ```

  + ```C++
    // 懒汉式：只有在使用时，才把它 new 出来。有线程安全。需要加锁
    class Singleton
    {
    private:
      Singleton(){}
      static Singleton *single;
    
     public:
      static Singleton* getInstance() { 
        
        if (single == NULL){
          Lock();
          if (single == NULL){	//double-check机制
            single = new Singleton();
          }
          Unlock();
        }
        return single; 
      }
    };
    Singleton* Singleton::single = NULL;//创建实例
    ```

+ 如何实现线程安全

  + double check和加锁
  + 获取的时候判断single是不是NULL，如果是则加锁，加完锁后再次判断是不是NULL，不是NULL才new。

# 操作系统

+ 一个进程的内存空间是怎么布局的
  + BSS段（未初始化数据区）：通常用来存放程序中未初始化的全局变量和静态变量的一块内存区域。BSS段属于**静态分配**，程序结束后静态变量资源由系统自动释放。
  + 数据段：存放程序中已初始化的全局变量的一块内存区域。数据段也属于**静态内存分配**

  + 代码段：存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在代码段中，也有可能包含一些只读的常数变量

  + 栈区：由编译器自动释放，存放函数的参数值、局部变量等。每当一个函数被调用时，该函数的返回类型和一些调用的信息被存放到栈中。然后这个被调用的函数再为他的自动变量和临时变量在栈上分配空间。每调用一个函数一个新的栈就会被使用。栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。

  + 堆区：用于动态分配内存，位于BSS和栈中间的地址区域。由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。**频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。**
+ 堆和栈分配上有什么不同
  + 栈：栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能从栈中获取的空间较小。
  + 由程序员申请分配和释放。堆是从低地址位向高地址位增长，采用链式存储结构。**频繁的malloc/free造成内存空间的不连续，产生碎片。当申请堆空间时库函数是按照一定的算法搜索可用的足够大的空间。因此堆的效率比栈要低的多。**
+ 字节序是什么含义
  + 网络字节序：网络字节序是大端法。本地字节序是小端法。所以网络字节序和本地字节序需要互相转换。
+ 操作系统里面的死锁是什么含义
  + 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象
+ 死锁有没有什么简单的规避方法
  + 资源一次性分配，从而剥夺请求和保持条件
  + 可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件
  + 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件

# 网络

+ TCP的状态机

  + TCP状态转换图：![TCP状态转换图](https://github.com/594301947/knowledge/blob/master/%E7%BD%91%E7%BB%9C/images/TCP%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE.jpg)

+ 如果一个连接处于time_wait状态，是谁先发起了关闭

  + time_wait状态由主动方发起关闭

+ closing状态是什么含义

  + 双方同时发送FIN包

+ select和epoll的区别

  + |            | epoll            | select                                                       |
    | ---------- | ---------------- | ------------------------------------------------------------ |
    | 时间复杂度 | O(1)             | 当有 I/O 时间发生时，不能知道是哪个 fd 触发了，只能无差别的轮询所有 fd。 O(N) |
    | 底层实现   | 红黑树+就绪链表  | 数组                                                         |
    | 缺点       | 消耗的资源比较多 | 最大连接数有上限<br>需要对fd集合进行轮询扫描<br>需要将fd集合从内核和用户空间来回拷贝 |

+ epoll的边缘触发和水平触发有什么区别

  + 水平触发：只要高电平 or 低电平时，才会触发。即：有数据可读时，就会一直触发（事件没处理完，不会从激活链表中摘除，会一直触发，直到事件处理完，才移除激活队列）
  + 边缘触发：只有电平发生变化时，才会触发（事件来到时，只触发一次，就从激活链表中摘除）

# 其他

+ redis的跳表的实现原理
+ LSM这种结构是什么样的原理
+ zookeeper是用来做什么的
+ CAP原则

# 算法

+ 写一个函数，实现将16进制表现形式的字符串转化为整数。例如，输入”1a”，返回26，输入“FE”，返回254 (请使用字符数组实现，以便直接在数组上操作。) 

+ 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

  ```
  示例：
  输入："abbaca"
  输出："ca"
  ```

+ 最长无重复子串

# 智力题

+ 36辆车，6个跑道，无计时器，用最少的比赛次数求出前三名
  + **最少可以用8次求出结果**
  + 36辆车，6个跑道，6辆车为一组进行比赛，可以得到6组数据（A,B,C,D,E,F）。**（用了6次）**
  + 然后再6组数据中每组的第一名进行比较，得到前三名（A,B,C）**（用了1次）**
  + 由于上面可以得到D,E,F这一组的第一名都没进前三，那么D,E,F这三组的数据就不用比较了
  + 假设A组的第一名是第一名，B组的第一名是第二名，C组的第一名是第三名。
  + 那么A组中第二名和第三名继续比赛，B组的前三名进行比赛，C组的第一名进行比赛。（A2,A3,B1,B2,B3,C1）**（用了1次）**
  + A2,A3,B1,B2,B3,C1这一组比赛就可以得到前两名，那么这前两名就是对应的第二名和第三名。第一名是前面的A1