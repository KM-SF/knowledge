https://blog.csdn.net/aurorayqz/article/details/79671785

## 内存管理做一个简单介绍

linux kernel 通过把整个物理内存划分成以一个个page进行管理，管理器就是伙伴系统，它的最小分配单元就是page。但是对于小于page的内存分配，如果直接分配一个page，是一个很大的浪费。linux kernel 通过slab来实现对小于page大小的内存分配。slab把page按2的m次幂进行划分一个个字节块，当kmalloc申请内存时，通过slab管理器返回需要满足申请大小的最小空闲内存块。
slub主要是针对slab的对象管理数据的优化版本，相比于slab，slub提供更小的管理成本开销。而且slub对多核系统的支持也更加友好。细节这里就不展开讲。
所以kernel的内存管理是个2层分层系统，从下往上依次为：
第一层为全部物理内存：其管理器为伙伴系统，最小管理单位为page；
第二层为slab page：其管理器为slab/slub，最小管理单位为2的m次幂的字节块；

## 内存对齐

### 性能原因

CPU 看代内存是一块块的，块大小为 2，4，8，16 个字节，因此 CPU 在读取内存数据时，时以块大小为粒度读取的。举例说明：
case1：从 0 开始读取 4 字节的数据。直接将 0-3 这 4 个字节的数据读取到寄存器，返回
case2：从 1 开始读取 4 字节的数据假设 CPU 要读取 4 字节大小的数据，如果数据在 1 字节位置作为起始读取地址，读取过程就很复杂，

①先将 1-4 这 4 个字节读取到寄存器

②再读取 4-7 这 4 字节的数据到寄存器

③把 4，6，7 字节的数据剔除，剩下 1，2，3，4

④最后，将 1，2，3，4 字节的数据合并，存到寄存器

### 平台原因

并不是所有的硬件平台都支持访问任意地址的数据

### 对齐准则

1. 每个数据成员偏移量必须是 min(#pragma pack()指定的数, len(该数据成员))的倍数
2. struc 的 size，一定是长度最长的数据成员的倍数