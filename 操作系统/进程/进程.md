# 概念

+ **孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程。子进程的父进程变成init进程，称为init进程领养孤儿进程**
+ **僵尸进程：进程终止了，父进程尚未回收子进程资源（PCB），子进程的资源还残留在内核中，变成僵尸进程**
+ **为什么不能用kill命令杀死僵尸进程？因为kill命令是给进程发送信号的，但是僵尸进程已经终止了，只是残留PCB资源在内核**
+ 当进程终止时，操作系统的隐式回收机制会：
  1. 关闭所有文件描述符
  2. 释放用户空间分配的内存。内核的PCB仍保留
  3. 保存该进程的退出状态（正常终止->退出值，异常终止->信号）

# 虚拟地址空间

+ linux每运行一个进程，操作系统都会分配一个0~4G的虚拟地址空间

+ 我们每运行一个进程，并非真的少了4G的物理内存。而是用了多少才减多少。

+ 每个进程的虚拟地址空间都互不影响

+ CPU为什么要使用虚拟地址空间与物理地址空间映射？解决了什么样的问题？

  + 方便编译器和操作系统安排程序的地址分布。程序可以使用一系列连续的虚拟地址空间来访问物理内存中不连续的内存缓冲区
  + 方便进程之间隔离。不同进程使用的虚拟地址彼此隔离。一个进程的代码无法更正正在由另一个进程使用的物理内存。
  + 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常是4K）保存到磁盘文件。数据或者代码页会根据需要在物理内存与磁盘之间移动。 

+ 虚拟地址空间由0~3G的用户空间，3G~4G的内核空间（kernel）组成。内核空间是受保护的。用户不能对该空间进行写操作，否则会出现段错误。

  > 0~3G的用户空间主要组成部分：
  >
  > 1. 栈空间：自顶向下分配地址
  > 2. 共享库
  > 3. 堆空间：自底向上分配地址
  > 4. .bss（未初始化全局变量）
  > 5. .data（已初始化全局变量）
  > 6. .text（代码段）

  > 3G~4G的内核空间组要组成部分：
  >
  > 1. 内存管理
  > 2. 进程管理
  > 3. 设备驱动管理
  > 4. VFS虚拟文件系统

  > 虚拟地址空间：![虚拟地址空间](/操作系统/进程/images/虚拟地址空间.png)

# 进程控制块（PCB）

+ 每个进程在内核中都有一个进程控制块（PCB）来维护进程相关信息。linux内核进程控制块是task_struct结构体
+ 进程控制块主要包括以下：
  + 进程id。系统中每个进程有一个唯一得分id，在C语言中用pid_t类型表示，其实是个非负整数
  + 进程的状态：初始化，就绪，运行，挂起，停止状态。
  + 进程切换时需要保存和回复的一些CPU寄存器信息。该进程时间片用完时需要保存寄存器的一些信息，等待下次CPU分配了时间片，以便继续执行
  + 描述虚拟地址空间信息。虚拟地址和物理地址的对应关系
  + 描述控制终端信息
  + 当前工作目录
  + umask掩码
  + 文件描述符表（简单理解文件描述符的数组）
  + 信号相关的信息
  + 用户id和组id
  + 会话和进程组
  + 进程可以使用的资源上限

# 进程的状态

+ 进程基本的状态有5中。分别是初始态，就绪态，运行态，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。
  + 就绪态：进程等待CPU分配时间片
  + 运行态：正在占用CPU
  + 停止：进程运行结束
  + 挂起：等待除CPU以外的其他资源（阻塞），主动放弃CPU

> 进程五种状态：![进程五种状态](/操作系统/进程/images/进程的五种状态.png)

# 进程原语

> 头文件：#include <unistd.h>

> **创建一个子进程：fork**
>
> pid_t fork(void);
>
> 返回值：调用一次返回两次。父进程返回一次，子进程返回一次。
>
> + 父进程返回的是：子进程的id号。（-1为失败）
> + 子进程返回的是：0
>
> **特点：**
>
> + 子进程复制父进程的0到3g空间和父进程内核中的PCB，但id号不同
> +  读时共享，写时复制
> + 父进程和子进程都会继续从调用fork函数之后的代码开始执行。子进程不会从头开始执行。
> + fork创建子进程之后，父进程和子进程谁先执行是由内核调度算法决定的。父子进程都公平分配CPU的时间片

> **执行另外一个程序：exec族**
>
> int execl(const char *path, const char *arg, ...);
> int execlp(const char *file, const char *arg, ...);
> int execle(const char *path, const char *arg, ..., char *const envp[]);
> int execv(const char *path, char *const argv[]);
> int execvp(const char *file, char *const argv[]);
> int execve(const char *path, char *const argv[], char *const envp[]);
>
> 返回值：这些函数如果调用成功则加载新的程序从启动代码开始执行，不再返回，如果调用出错则返回-1，**所以exec函数只有出错的返回值而没有成功的返回值。**
>
> 规律：
>
> > l 命令行参数列表
> > p 搜素file时使用path变量
> > v 使用命令行参数数组
> > e 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量
>
> + 不带字母p（表示path）的exec函数第一个参数必须是程序的相对路径或绝对路径，例如“/bin/ls”或“./a.out”，而不能是“ls”或“a.out”
> + 对于带字母p的函数：如果参数中包含/，则将其视为路径名，否则视为不带路径的程序名，**在PATH环境变量的目录列表中搜索这个程序。**
> + 带有字母l（表示list）的exec函数要求将新程序的每个命令行参数都当作一个参数传给它，命令行参数的个数是可变的，因此函数原型中有…，…中的最后一个可变参数应该是NULL。
> + 带有字母v（表示vector）的函数，则应该先构造一个指向各参数的指针数组，然后将该数组的首地址当作参数传给它，数组中的最后一个指针也应该是NULL，就像main函数的argv参数或者环境变量表一样。
> + 以e（表示environment）结尾的exec函数，可以把一份新的环境变量表传给它，其他exec函数仍使用当前的环境变量表执行新程序。
>
> 例子：
>
> ```C
> char *const ps_argv[] ={"ps", "-o", "pid,ppid,pgrp,session,tpgid,comm", NULL};
> char *const ps_envp[] ={"PATH=/bin:/usr/bin", "TERM=console", NULL};
> execl("/bin/ps", "ps", "-o", "pid,ppid,pgrp,session,tpgid,comm", NULL);
> execv("/bin/ps", ps_argv);
> execle("/bin/ps", "ps", "-o", "pid,ppid,pgrp,session,tpgid,comm", NULL, ps_envp);
> execve("/bin/ps", ps_argv, ps_envp);
> execlp("ps", "ps", "-o", "pid,ppid,pgrp,session,tpgid,comm", NULL);
> execvp("ps", ps_argv);
> ```
>
> **特点：**
>
> + **用fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。**
> + **调用exec后，原来打开的文件描述符仍然是打开的**
> + **当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程（main函数）开始执行。**
> + **调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。**
> + **事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve**

> **回收子进程：wait和waitpid**
>
> pid_t wait(int *status);
> pid_t waitpid(pid_t pid, int *status, int options);
>
> > + waitpid的第一个参数（pid）：
> >   + < -1 回收指定进程组内的任意子进程
> >   + -1 回收任意子进程
> >   + 0 回收和当前调用waitpid一个组的所有子进程
> >   + \>0 回收指定ID的子进程
> > + waitpid的第三个参数（options）：设置为WNOHANG
> >   + 设置非阻塞状态
> >   + **返回值是0，则还有子进程等待回收**
> >   + 返回值是-1，则没有子进程需要回收
>
> + 一个进程在终止时会关闭所有文件描述符，**释放在用户空间分配的内存，但它的PCB还保留着**，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。
> + **一次wait调用只能清理一个子进程，清理多个子进程应使用循环**
>
> + wait函数有以下三个功能：
>   1. 阻塞等待子进程退户
>   2. 回收子进程残留资源
>   3. 获取子进程结束状态（退出原因）
> + 获取退出状态：
>   + WIFEXITED(status)为非0：进程正常结束。WEXITSTATUS(status)：可以获取退出状态
>   + WIFSIGNALED(status)为非0：进程异常退出。WTERMSIG(status)：使进程终止的那个信号编号

# 进程共享

+ **读时共享，写时复制：子进程复制了父进程0~3G用户空间内容，以及父进程的PCB，但是pid不同。fork之后子进程不是真的将父进程的0-3G地址空间完全拷贝一份，而是如果只是读操作，那么还是共用一份地址。如果是涉及到写操作，那才会拷贝一份，在新的地址空间上操作。这是为了节省资源开销。**

> 父子相同处：这里相同的含义是指值相同，地址是不同的。**相同不等于共享**
>
> + 全局变量，.data/.text/栈/堆，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式等等

> 父子不同处：
>
> + 进程id，fork返回值，父进程ID，进程运行时间，闹钟（定时器），未决信号集

> **重点：**
>
> + 父子进程不共享全局变量
> + 父子进程共享文件描述符（已经打开的文件描述符）
> + mmap建立的映射区