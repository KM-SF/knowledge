### 进程的基本状态

+ 创建状态：进程正在被创建
+ 运行：当一个进程在处理机CPU上运行时，则称为该进程处理运行状态
+  就绪：当一个进程获得了除处理机CPU以外的一切所需资源（一旦得到处理机即可运行）
+ 阻塞：一个进程正在等待某一事件发生（例如请求IO而等待IO完成等），故该进程处于阻塞状态
+ 终止状态：进程运行完毕

### 僵尸进程/孤儿进程

+ 孤儿进程：父进程退出，该子进程还在运行，这个进程称为孤儿进程（父进程退出后，由init进程收养，后续由init进程对子进程进行回收），因此可以看到孤儿进程并不存在问题。守护进程就是利用该机制
+ 僵尸进程：子进程终止了，父进程尚未回收子进程资源（PCB），子进程的资源还残留在内核中，变成僵尸进程。进程回收调用wait/waitpid。僵尸进程会占用系统资源，一旦僵尸进程太多会耗尽系统资源

### fork

+ 作用：**创建一个子进程**。
+ 函数原型：pid_t fork(void);

+ 返回值：调用一次返回两次。父进程返回一次，子进程返回一次。
  + 父进程返回的是：子进程的id号。（-1为失败）
  + 子进程返回的是：0

+ **特点：**
  + 子进程复制父进程的0到3g空间和父进程内核中的PCB，但id号不同
  + 读时共享，写时复制
  + 父进程和子进程都会继续从调用fork函数之后的代码开始执行。子进程不会从头开始执行。
  + fork创建子进程之后，父进程和子进程谁先执行是由内核调度算法决定的。父子进程都公平分配CPU的时间片

### 进程共享

+ **读时共享，写时复制：子进程复制了父进程0~3G用户空间内容，以及父进程的PCB，但是pid不同。fork之后子进程不是真的将父进程的0-3G地址空间完全拷贝一份，而是如果只是读操作，那么还是共用一份地址。如果是涉及到写操作，那才会拷贝一份，在新的地址空间上操作。这是为了节省资源开销。**

> 父子相同处：这里相同的含义是指**值相同，地址是不同的。相同不等于共享**
>
> + 全局变量，.data/.text/栈/堆，环境变量，用户ID，宿主目录，进程工作目录，信号处理方式等等

> 父子不同处：
>
> + 进程id，fork返回值，父进程ID，进程运行时间，闹钟（定时器），未决信号集

> **重点：**
>
> + 父子进程不共享全局变量，栈变量，堆变量，静态变量
> + 父子进程共享文件描述符（已经打开的文件描述符）
> + mmap建立的映射区

### SIGCHID信号

+ 当一个进程正常或异常终止时，内核就会向其父进程发送SIGCHID信号。（因为子进程终止时异步的，子进程可能在父进程运行的任何时候退出，因此只能由内核将信号发送给父进程）
+ 父进程默认处理方式：忽略

### SIGPIPE信号（Broken pipe）

+ 管道破裂：向没有打开或者意外终止的管道中写入数据，写进程会受到SIGPIPE信号
  + 第一次写，写进程会受到RST标记，异常终止连接
  + 在收到RST标记后，写进程仍然执意要向已经关闭的管道中写数据，写进程就会受到SIGPIPE信号。该信号默认情况下，会使写进程终止
+ 场景：在服务器设计时，极有可能出现客户端已经挂掉，服务端还会继续想客户端套接字写入数据的场景，这会导致产生SIGPIPE信号，导致服务端进程挂掉。如果服务端不处理该信号，则是很危险的行为
+ 解决方案：
  + signal(SIGPIPE, SIG_IGN);   //忽略该信号，不执行默认动作
  + 注册SIGPIPE信号处理函数，处理该信号

### wait/waitpid

+ **回收子进程：**

+ 函数原型：pid_t wait(int *status);   pid_t waitpid(pid_t pid, int *status, int options);

> + waitpid的第一个参数（pid）：
>   + < -1 回收指定进程组内的任意子进程
>   + -1 回收任意子进程
>   + 0 回收和当前调用waitpid一个组的所有子进程
>   + \>0 回收指定ID的子进程
> + waitpid的第三个参数（options）：设置为WNOHANG
>   + 设置非阻塞状态
>   + **返回值是0，则还有子进程等待回收**
>   + 返回值是-1，则没有子进程需要回收

+ 一个进程在终止时会关闭所有文件描述符，**释放在用户空间分配的内存，但它的PCB还保留着**，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。
+ **一次wait调用只能清理一个子进程，清理多个子进程应使用循环**

+ wait函数有以下三个功能：
  1. 阻塞等待子进程退户
  2. 回收子进程残留资源
  3. 获取子进程结束状态（退出原因）
+ 获取退出状态：
  + WIFEXITED(status)为非0：进程正常结束。WEXITSTATUS(status)：可以获取退出状态
  + WIFSIGNALED(status)为非0：进程异常退出。WTERMSIG(status)：使进程终止的那个信号编号

### 守护进程

+ 守护进程是后台运行，不与任何控制终端相关联的进程

+ 进程都有父进程，父进程也有父进程，这就形成了一个以init进程为根的家族树

+ 进程组：一组相关的进程集合

+ 会话：一组相关进程组的集合

+ 一个进程会有如下ID：进程ID（pid），进程组ID（pgid），会话ID（sid）。默认情况下，新创建的进程会继承父进程的进程组ID合会话ID

+ 守护进程步骤：

  | 操作                                                       | 原因                                                         |
  | ---------------------------------------------------------- | ------------------------------------------------------------ |
  | fork创建子进程，父进程调用exit退出                         | 由于守护进程是脱离控制终端的，这样做，使得父进程先于子进程退出，子进程变为孤儿进程由init进程收养 |
  | 子进程调用setsid()创建新会话                               | 调用fork后，子进程全盘拷贝了父进程的会话、进程组、控制终端等，虽然父进程退出了，但是会话、进程组、控制终端等却没有改变。这不是真正意义上的独立开来，而，setsid函数就能够使子进程完全独立开来，即：使当前进程脱离原会话/原进程组/原控制终端的控制。 |
  | 再次fork一个子进程，父进程exit退出                         | 现在，子进程已经称为无终端的会话组长，但它可以通过fork一个子进程重新申请打开一个控制终端，该新的子进程不是会话受进程，它不能重新打开控制终端。  也就是说，通过再次创建子进程结束当前进程，使进程不再使会话首进程来禁止进程重新打开控制终端。 |
  | 在子进程中调用chdir(‘/’)让根目录称为子进程的工作目录       |                                                              |
  | 在子进程中调用umask重设文件权限掩码为0（相当于把权限放开） |                                                              |
  | 在子进程中close不需要的文件描述符                          | 用fork函数新建的子进程会从父进程那里继承一些已经打开了的文件。这些被打开的文件可能永远不会被守护进程读写，但它们一样消耗系统资源。  其实在上面的第二步之后，守护进程已经与所属的控制终端失去了联系，因此从终端输入的字符不可能达到守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在终端上显示出来。所以，文件描述符为0、1和2 的3个文件已经失去了存在的价值，也应被关闭。（关闭失去价值的输入、输出、报错等对应的文件描述符） |





### 进程通信

+ 每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。
+ 每个进程都有0-4G的地址空间，其中0-3G用户空间是自己独享的，其他进程没法访问。3G-4G的内核空间，虽然虚拟区域不同，但是所指向的物理区域是相同的。系统能通过内核空间进行进程间通信
+ 通信方式：无名管道（PIPE），有名管道（FIFO），共享内存（mmap），信号，本地套接字，消息队列

### 无名管道PIPE

+ 只能用于有血缘关系的进程间通信（父子进程/兄弟进程）
+ 半双工（方向只能朝一个方向流动），一个读端，一个写端。先进先出

### 有名管道FIFO

+ 当只写打开FIFO管道时，如果没有FIFO没有读端打开，则open写打开会阻塞。
+ FIFO内核实现时可以支持双向通信，也是一个缓冲区。（pipe单向通信，因为父子进程共享同一个file结构体）
+ FIFO可以一个读端，多个写端；也可以一个写端，多个读端。

### 消息队列

+ 消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标记。 (消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点)具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
+ 特点：
  + 消息队列是面向记录的，其中的消息具有特定的**格式**以及特定的**优先级**。
  + 消息队列**独立**于发送与接收进程。进程终止时，消息队列及其内容并不会删除。
  + 消息队列可以实现消息的**随机查询**，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。
+ msgget：创建/打开消息队列，返回消息队列ID
+ msgsnd：添加消息，成功返回0
+ msgrcv：读取消息，成功返回消息长度。在读取数据时，参数type可以指定接收某个类型的数据
+ msgctl：操作消息

### 本地套接字（Unix Socket）

+ 本地套接字用于IPC（进程通信）更有效率，不需要经过网络协议，不需要打包拆包，计算检验和，维护序号和应答等。只需要将应用层数据从一个进程拷贝到另外一个进程。
+ unix domain socket也提供面向流和数据包两种API接口，类似于TCP和UDP，但是面向消息的domain socket也是可靠的，消息既不会丢失也不会顺序错乱
+ unix domain socket的地址是一个socket类型的文件在文件系统中路径
+ 这个socket文件由bind调用创建，如果调用bind时，该文件存在，那么bind会报错：Address already in use
+ 客户端不能依赖隐私绑定"bind"。需要两个地址结构，一个用于本地绑定bind，一个用于跟服务器通信connect
+ 使用一个伪文件在内核空间进行通信
+ 调用bind之前，先调用unlink(socket_file)，将socket文件删除，再有bind去创建

### 共享内存

+ 管道/共享内存存在于“内核”中，因此，将读写数据时，要将数据从内核在应用区来回拷贝，性能开销是很大的。而共享内存将同一块内存区域映射到共享它的不同进程的地址空间，这样不同进程之间的通信就不需要经过内核。
+ mmap是内核借助文件帮我创建了一个映射区，多个进程之间利用该映射区完成数据传递。内核空间多进程共享。
+ 共享内存是最快的一种IPC，因为是直接读写内存
+ 因为多个进程可以同时操作，所以需要进行同步。信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问
+ **注意事项**
  1. 创建映射区的过程中，隐含着一次对映射文件的读操作。所以open的文件一定要有读权限。
  2. 当MAP_SHARED时，要求：映射区的权限<=文件打开的权限（处于对映射区的保护）。
  3. 当MAP_PRIVATE时，则对文件打开的权限有读的权限即可。
  4. 映射区的释放与文件关闭无关，只要映射建立成功，文件可以立即关闭
  5. 特别注意，当映射文件大小为0时，不能创建映射区，所以用于映射的文件必须要有实际大小
  6. munmap：传入的地址一定是mmap返回的地址，杜绝创建其他地址。
  7. 偏移量必须是4K的整数倍
  8. mmap创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功后再进行操作

### 常见错误码

| 错误码     | 错误信息   | 可能原因                                               | 处理方式         |
| ---------- | ---------- | ------------------------------------------------------ | ---------------- |
| EAGAIN     | Try again  | 读数据时，没有数据在内核缓冲区（多数发生在非阻塞IO上） | while循环读取    |
| EPIPE      | broken pip | 信号SIGPIPE（Broken pipe）                             |                  |
| EINTR      |            | 被其他系统调用中断                                     | 再执行一次       |
| ETIMEOUT   |            | 连接超时                                               |                  |
| EADDRINUSE |            | 地址被占用                                             | 设置地址复用标志 |
| ENOTCONN   |            | 连接建立失败                                           |                  |

### 零拷贝 sendfile

+ 传统IO：硬盘—>内核缓冲区—>用户缓冲区—>内核 socket 缓冲区—>协议引擎 （4 次数据拷贝）
+ 零拷贝（sendfile）：硬盘—>内核缓冲区—>内核 socket 缓冲区—>协议引擎
+ 真正零拷贝（sendfile+Linux2.4以上）：硬盘->内核缓冲区—>协议引擎
+ 零拷贝技术，数据拷贝不用涉及到在内核态和用户态之间的来回拷贝，数据传递完全是在内核中进行的，操作效率很高

### 进程间如何传递文件描述符

答：socketpair()和 sendmsg/recvmsg

### 内核是如何实现创建线程和进程的

实际上，对于 linux 内核而言，是没有线程这个概念的，创建线程/进程都是采用 do_fork 系统调用，也是创建一个 task_struct 结构体，只不过创建线程时，指定一些变量是共享的