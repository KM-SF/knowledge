原文链接：https://blog.csdn.net/dd864140130/article/details/56494925

# 乱序重排

有两个线程：有个线程1，有一个变量x初始化是0。有一个线程2，有一个变量y初始化也是0。然后线程1和2同时执行，会不会出现结果ry=0和rx=0

```c++
// 线程1要执行的函数
void fn1() {
	x = 1
	ry = y
}

// 线程2要执行的函数
void fn2() {
	y = 1
	rx = x
}
```

**会出现。乱序重排，会导致都为0的情况：**

乱序重排：两条互不相关的语句，可以先后调换或者并行执行。提高效率

乱序重拍的原因：

- 现代处理器采用指令并行技术,在不存在数据依赖性的前提下,处理器可以改变语句对应的机器指令的执行顺序来提高处理器执行速度
- 现代处理器采用内部缓存技术,导致数据的变化不能及时反映在主存所带来的乱序.
- 现代编译器为优化而重新安排语句的执行顺序

例子：

> 正常顺序：
>
> 1. 洗水壶
> 2. 烧开水
> 3. 洗茶壶
> 4. 洗茶杯
> 5. 拿茶叶
> 6. 泡茶

> 乱序重排
>
> 1. 洗水壶
> 2. 烧开水（洗茶壶+洗茶杯）
> 3. 拿茶叶
> 4. 泡茶
>
> 洗水壶和洗茶杯这个两步骤跟烧开水没有关系，所以并行在一起了。

# 内存屏障

尽管我们看到乱序执行初始目的是为了提高效率,但是它看来其好像在这多核时代不尽人意,其中的某些”自作聪明”的优化导致多线程程序产生各种各样的意外.因此有必要存在一种机制来消除乱序执行带来的坏影响,也就是说应该允许程序员显式的告诉处理器对某些地方禁止乱序执行.这种机制就是所谓内存屏障.不同架构的处理器在其指令集中提供了不同的指令来发起内存屏障,对应在编程语言当中就是提供特殊的关键字来调用处理器相关的指令.

内存屏障（as-if-serial语义）可以解决乱序重排 

