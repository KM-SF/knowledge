## MESI 协议

在MESI协议中，每个cache line有4个状态，可用2个bit表示，它们分别是：

| 状态               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| M(Modified) 已修改 | 这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。 |
| E(Exclusive) 独占  | 这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中。 |
| S(Shared) 共享     | 这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中。 |
| I(Invalid) 已失效  | 这行数据无效                                                 |

MESI为了保证多个CPU缓存中共享数据的一致性，定义了cache line的四种状态，而CPU对cache line的四种操作可能会产生不一致的状态，因此缓存控制器监听到本地操作和远程操作的时候，需要对地址一致的cache line 状态进行一致性修改，从而保证数据在多个缓存之间保持一致性(M:modified  E:Exclusive  S:shared  I:invalid) 。

+ 「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。而「已失效」状态，表示的是这个 Cache Block 里的数据已经失效了，不可以读取该状态的数据。

+ 「独占」和「共享」状态都代表 Cache Block 里的数据是干净的，也就是说，这个时候 Cache Block 里的数据和内存里面的数据是一致性的。

+ 「独占」和「共享」的差别在于，独占状态的时候，数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。这个时候，如果要向独占的 Cache 写数据，就可以直接自由地写入，而不需要通知其他 CPU 核心，因为只有你这有这个数据，就不存在缓存一致性的问题了，于是就可以随便操作该数据。

+ 另外，在「独占」状态下的数据，如果有其他核心从内存读取了相同的数据到各自的 Cache ，那么这个时候，独占状态下的数据就会变成共享状态。

+ 那么，「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，所以当我们要更新 Cache 里面的数据的时候，不能直接修改，而是要先向所有的其他 CPU 核心广播一个请求，要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后再更新当前 Cache 里面的数据。

事实上，整个 MESI 的状态可以用一个有限状态机来表示它的状态流转。还有一点，对于不同状态触发的事件操作，可能是来自本地 CPU 核心发出的广播事件，也可以是来自其他 CPU 核心通过总线发出的广播事件。下图即是 MESI 协议的状态图：

![](/操作系统/CPU/images/MESI状态图.png)

MESI 协议的四种状态之间的流转过程，我汇总成了下面的表格，你可以更详细的看到每个状态转换的原因：

![](/操作系统/CPU/images/MESI状态图表格.png)

------

https://www.cnblogs.com/caibixiang123/p/9326714.html

https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453154398&idx=2&sn=0bf4ce1e1207895f4fb94338720d5401&scene=21#wechat_redirect