# 概念

+ 每一个FILE文件流都有一个缓冲区buffer，默认大小为8192byte
+ write的底层也可以分配一个内核I/O缓冲区，所以write也不一定是直接写到文件的，也可能写到内核I/O缓冲区中，至于究竟写到了文件中还是内核缓冲区中对于进程来说是没有差别的

+ 一个系统默认允许打开最大文件描述符个数：1024**（对应单个进程）**。允许修改。
+ 每一个文件描述符fd都有对应一个文件指针，该文件指针指向一个文件表项。
+ 文件表项内容：
  + 文件状态标记
  + 当前文件偏移量
  + v节点指针
+ **两个不同的fd可以指向相同的文件表项，如果都指向相同的文件表项，则两个fd的操作都会互相影响。**

# 阻塞和非阻塞

## 阻塞

+ 当进程调用一个阻塞的系统函数时，**该进程被置于睡眠（Sleep）状态，这时内核调度其它进程运行**，直到该进程等待的事件发生了（比如网络上接收到数据包，或者调用sleep指定的睡眠时间到了）它才有可能继续运行。
+ 与睡眠状态相对的是运行（Running）状态，在Linux内核中，处于运行状态的进程分为两种情况：
  + 正在被调度执行：CPU处于该进程的上下文环境中，程序计数器（eip）里保存着该进程的指令地址，通用寄存器里保存着该进程运算过程的中间结果，正在执行该进程的指令，正在读写该进程的地址空间。
  + 就绪状态：**该进程不需要等待什么事件发生，随时都可以执行，但CPU暂时还在执行另一个进程，所以该进程在一个就绪队列中等待被内核调度**。系统中可能同时有多个就绪的进程，那么该调度谁执行呢？内核的调度算法是基于优先级和时间片的，而且会根据每个进程的运行情况动态调整它的优先级和时间片，让每个进程都能比较公平地得到机会执行，同时要兼顾用户体验，不能让和用户交互的进程响应太慢。

## 非阻塞

+ 如果在一个fd时指定了O_NONBLOCK标志，read/write就不会阻塞。**以read为例，如果fd暂时没有数据可读就返回-1，同时置errno为EWOULDBLOCK（或者EAGAIN，这两个宏定义的值相同）**，表示本来应该阻塞在这里（would block，虚拟语气），事实上并没有阻塞而是直接返回错误，调用者应该试着再读一次（again）。这种行为方式称为轮询（Poll），调用者只是查询一下，而不是阻塞在这里死等，这样可以同时监视多个fd。

> while(1) {
> 	非阻塞read(设备1);
> 	if(设备1有数据到达)
> 		处理数据;
> 	非阻塞read(设备2);
> 	if(设备2有数据到达)
> 		处理数据;
> ...
> }

+ 优点：如果read(设备1)是阻塞的，那么只要设备1没有数据到达就会一直阻塞在设备1的read调用上，即使设备2有数据到达也不能处理，使用非阻塞I/O就可以避免设备2得不到及时处理。
+ 缺点：如果所有设备都一直没有数据到达，调用者需要反复查询做无用功，如果阻塞在那里，操作系统可以调度别的进程执行，就不会做无用功了。可以通过IO复用技术解决select，poll，epoll、

# 函数

+ 该系列函数成功都返回0，失败返回-1并且设置一个全局的错误号。可以通过perror来打印。

>头文件：
>
>\#include <sys/types.h>
>
>\#include <sys/stat.h>
>
>\#include <fcntl.h>



> **打开或创建一个文件：open**
>
> int open(const char *pathname, int flags);
> int open(const char *pathname, int flags, mode_t mode);
> 返回值：成功返回新分配的文件描述符，出错返回-1并设置errno
>
> + pathname参数是要打开或创建的文件名，和fopen一样，pathname既可以是相对路径也可以是绝对路径。
> + flags参数有一系列常数值可供选择，可以同时选择多个常数用按位或运算符连接起来，所以这些常数的宏定义都以O_开头，表示or
>   + 必选项：以下三个常数中必须指定一个，且仅允许指定一个。
>     * O_RDONLY 只读打开
>     * O_WRONLY 只写打开
>     * O_RDWR 可读可写打开
>   + 其他可选选项：
>     + O_APPEND 表示追加。如果文件已有内容，这次打开文件所写的数据附加到文件的末尾而不覆盖原来的内容。
>     + O_CREAT 若此文件不存在则创建它。使用此选项时需要提供第三个参数mode，表示该文件的访问权限。
>     * O_EXCL 如果同时指定了O_CREAT，并且文件已存在，则出错返回。
>     + O_TRUNC 如果文件已存在，并且以只写或可读可写方式打开，则将其长度截断（Trun-cate）为0字节。
>     + O_NONBLOCK 对于设备文件，以O_NONBLOCK方式打开可以做非阻塞I/O（Nonblock I/O）
> + 第三个参数mode指定文件权限，可以用八进制数表示，比如0644表示-rw-r-r–，也可以用S_IRUSR、S_IWUSR等宏定义按位或起来表示
> + **返回的文件描述符一定是该进程尚未使用的最小描述符**



> **关闭一个已打开的文件：close**
>
> int close(int fd);
> 返回值：成功返回0，出错返回-1并设置errno
>
> + 参数fd是要关闭的文件描述符。
> + 当一个进程终止时，内核对该进程所有尚未关闭的文件描述符调用close关闭，所以即使用户程序不调用close，在终止时内核也会自动关闭它打开的所有文件
> + 每使用open后，要记得跟上close。要不然会fd泄漏，造成系统资源浪费



> **从打开的设备或文件中读取数据：read**
>
> ssize_t read(int fd, void *buf, size_t count);
> 返回值：成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0
>
> + 参数count是请求读取的字节数，读上来的数据保存在缓冲区buf中，同时文件的当前读写位置向后移。注意这个读写位置和使用C标准I/O库时的读写位置有可能不同，这个读写位置是记在内核中的，而使用C标准I/O库时的读写位置是用户空间I/O缓冲区中的位置
> + 返回值类型是ssize_t，表示有符号的size_t
>   + 0（表示数据读完）
>     + 读到文件末尾
>     + 管道写端关闭
>     + socket对端的写端关闭
>   + -1（表示异常，通过errno来区分是什么异常）
>     + errno==EINTR，被信号中断
>     + errno==EAGAIN（EWOULDBLOCK），以非阻塞方式去读，并且缓冲区没有数据
>     + 其他：错误情况。
>   + \>0（表示实际写的字节数）
>     + 入参：buf=1024，缓冲区数据大于等于1024，实际返回1024字节
>     + 入参：buf=1024，缓冲区数据小于1024，实际返回缓冲区数据大小
> + **缓冲区内有10K的数据，count值为1K数据，返回值为1k，但是read会继续调用10次，把所有数据读出来。**
> + **缓冲区内有1K的数据，count值为10K数据，返回值为1k，只读一次。**



> **向打开的设备或文件中写数据：write**
>
> ssize_t write(int fd, const void *buf, size_t count);
>
> + 返回值：成功返回实际写入的字节数，出错返回-1并设置errno
>   + 0（表示没有数据写入）
>   + -1（表示异常，通过errno来区分是什么异常）
>     + 写缓冲区满了
>     + errno==EINTR，被信号中断
>     + errno==EAGAIN（EWOULDBLOCK），以非阻塞方式去写，并且缓冲区已经满了还继续写
>     + 其他：错误情况。
>   + \>0（表示实际读取到的字节数）
>     + 入参：buf=1024，缓冲区剩余空间大于等于1024，实际返回1024字节
>     + 入参：buf=1024，缓冲区剩余空间小于1024，实际返回缓冲区剩余空间
> + 注意：
>   + 如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止（默认）。
>   + 如果所有指向socket对端的读端的文件描述符都关闭了，这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止（默认）。



> **设置读写偏移量（移动文件指针）：lseek**
>
> off_t lseek(int fd, off_t offset, int whence);
>
> 返回值：成功返回当前偏移量，失败返回-1
>
> + fd：表示要操作的文件描述符
> + offset：相对于whence（基准）的偏移量
> + whence ：SEEK_SET（文件指针开始），SEEK_CUR（文件指针当前位置） ，SEEK_END为文件指针尾
>
> + 每个打开的文件都记录着当前读写位置，打开文件时读写位置是0（默认），表示文件开头，通常读写多少个字节就会将读写位置往后移多少个字节。
> + 偏移量允许超过文件末尾，这种情况下对该文件的下一次写操作将延长文件，中间空洞的部分读出来都是0。



> **改变一个已打开的文件的属性，可以重新设置读、写、追加、非阻塞等标志（这些标志称为File Status Flag），而不必重新open文件：fcnt**
>
> int fcntl(int fd, int cmd);
> int fcntl(int fd, int cmd, long arg);
> int fcntl(int fd, int cmd, struct flock *lock);
>
> + 复制一个现有的描述符：F_DUPFD
> + 获取/设置文件状态：F_GETFD/F_SETFD
>   + 可设置的状态：O_APPEND/O_NONBLOCK
> + 获取/设置异步IO所有权：F_GETOWN/F_SETOWN
> + 获取/设置文件锁：F_GETLK/F_SETLK/F_SETLKW



> **文件描述符的复制（重定向）:dup/dup2**
>
> + int dup(int oldfd);
>   + 返回值：文件描述符表中没有被占用的最小文件描述符
>   + 例如：oldfd是3号文件描述符，返回4号文件描述符。那么3号和4号都是指向相同的文件。
>
> + int dup2(int oldfd, int newfd);
>   + old->new，如果new是一个被打开的文件描述符，再拷贝之前会先关掉new
>   + old和new是同一个文件描述符，不会关掉new直接返回old

# read和write

+ read/write 数据实际上，数据是存放在内核中的缓冲区中的，①读数据，实际上是用户将内核缓冲区中的数据读到应用层缓冲区；②写数据，实际上是用户将应用层缓冲区中的数据，写入到内核缓冲区。
+ 在网络通信中，调用 read 后，从内核缓冲区读数据，要分为 2 步：①要等待内核缓冲区中有数据。②有数据了才能去读走数据，将数据从内核缓冲区拷贝到应用层缓冲区。因此，当内核缓冲区中没有数据可以读时，就会阻塞！
+ 同理，调用write后，写入内核缓冲区，要分为2步：①要等待内核缓冲区中有剩余空间。②由剩余空间才能去写入数据，将数据从应用层缓冲区拷贝到内核冲区。因此，当内核缓冲区中没有数据可以写空间时，就会阻塞！

# 进程与文件

+ **进程调用open或者create创建一个文件，然后立即调用unlink，因为该文件仍旧是打开状态，所以不会将其内容删除。只有当进程关闭该文件或者终止时（在这种情况下，内核关闭该进程所有打开的文件），该文件的内容才被删除。**

+ **每个进程都有自己的文件描述符表（1024个），进程之间的文件描述符表互不影响**。[测试代码](https://github.com/594301947/knowledge/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6/code/process_fd.c)

  **fork的一个特性是：父进程的所有打开文件描述符都会被复制到子进程中。就好像执行了dup函数。父进程和子进程的文件指针都指向相同的文件表项**

+ **用fork创建出来的父子进程有以下特点：（fork之前创建的fd）**

  + 父子进程共享同一个文件表项（文件状态，偏移量，v节点指针）。[测试代码](https://github.com/594301947/knowledge/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%96%87%E4%BB%B6/code/fork_fd.c )
  + 子进程写fd，会更新父进程的偏移量
  + 子进程同时写fd，在没有同步手段前提，会发生数据混乱。
  + 父子进程close(fd)，会关闭自己的fd，不干扰对方的。

+ fork之后创建的文件描述符就和父进程没关系

+ 文件描述符表保存在PCB中。每打开一个新文件，则占用一个文件描述符，而且使用的是空闲的最小文件描述符

+ 一个进程默认会打开三个文件描述符：

  + 标准输入：STDIN_FILENO 0
  + 标准输出：STDOUT_FILENO 1
  + 标准错误：STDERR_FILENO 2

> 进程控制块与文件描述符：![进程控制块与文件描述符](/操作系统/文件/images/PCB与文件描述符.png)

> 文件表项：![文件表项](/操作系统/文件/images/文件表项.png)

> 父子进程与文件表项：![父子进程与文件表项](/操作系统/文件/images/父子进程与文件.png)

# 线程与文件

+ 在多线程中打开同一个文件
  + 每个线程都会有各自的文件描述符fd，该fd的文件指针都指向不同的文件表项。
  + 每个线程操作自己的fd，都只是改变自己的偏移量，并不会影响其他的线程。
  + 每个线程close(fd)，不会影响其他线程
+ 在多线程中，打开一个文件，将该fd当做参数传递到其他线程
  + 那么所有线程都共用该fd。
  + 有线程操作fd，都会影响其他线程的偏移量。
  + 多个线程同时写该fd，在没有同步手段的前提下，会造成数据混乱
  + 有一个线程close(fd)，都会影响其他线程。