# ext2文件系统

## 结构图

![](/操作系统/文件/images/ext2.png)

**文件系统中存储的最小单位是块（Block）**，一个块究竟多大是在格式化时确定的，例如mke2fs的-b选项可以设定块大小为1024、2048或4096字节。

**而上图中启动块（BootBlock）的大小是确定的，就是1KB，启动块是由PC标准规定的，用来存储磁盘分区信息和启动信息，任何文件系统都不能使用启动块。**

## 块组

启动块之后才是ext2文件系统的开始，ext2文件系统将整个分区划成若干个同样大小的**块组**（Block Group），每个块组都由以下部分组成。**一个块组由：超级块，块组描述符表，块位图，inode位图，inode表，数据块组成。而超级块和块组描述符表每个块组都一样，一般都是0号块组的副本。**

### 超级块

超级块（Super Block） 描述**整个分区**的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。

### 块组描述符表

块组描述符表（GDT，Group Descriptor Table） **由很多块组描述符组成，整个分区分成多少个块组就对应有多少个块组描述符。**每个块组描述符（Group Descriptor）存储一个块组的描述信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。和超级块类似，块组描述符表在每个块组的开头也都有一份拷贝，这些信息是非常重要的，一旦超级块意外损坏就会丢失整个分区的数据，一旦块组描述符意外损坏就会丢失整个块组的数据，因此它们都有多份拷贝。通常内核只用到第0个块组中的拷贝，当执行e2fsck检查文件系统一致性时，第0个块组中的超级块和块组描述符表就会拷贝到其它块组，这样当第0个块组的开头意外损坏时就可以用其它拷贝来恢复，从而减少损失。

### 块位图

**块位图就是用来描述整个块组中哪些块已用哪些块空闲的**，它本身占一个块，其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用。块指数据块和其他描述信息块（超级块，块组描述表，inode表等等）

### inode位图

inode位图（inode Bitmap） 和块位图类似，本身占一个块，其中每个bit表示一个inode是否空闲可用。

### inode表

一个文件除了数据需要存储之外，一些描述信息也需要存储，例如文件类型（常规、目录、符号链接等），权限，文件大小，创建/修改/访问时间等，也就是ls -l命令看到的那些信息，这些信息存在inode中而不是数据块中。**每个**
**文件都有一个inode，一个inode存储文件描述信息，一个块组中的所有inode组成了inode表。**

inode表占多少个块在格式化时就要决定并写入块组描述符中。

如果inode块太少，则需要存放小文件时，数据块还没用完了，但是inode块已经没有了，不够用。那会造成数据块浪费。

如果inode块太多，则存放大文件时，数据块用完了，inode块还没用完，造成inode块浪费

### 数据块

+ 对于常规文件，文件的数据存储在数据块中。
+ 对于目录，该目录下的所有文件名和目录名存储在数据块中，**注意文件名保存在它所在目录的数据块中**，除文件名之外，ls -l命令看到的其它信息都保存在该文件的inode中。**注意这个概念：目录也是一种文件，是一种特殊类型的文件。**
+ 对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。
+ 设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中。

## 总结

1. ext系统由一个启动块和多个块组组成
2. 每个块组由多个块组成。超级块，块组描述符表，块位图，inode位图，inode表，数据块组成。而超级块和块组描述符表每个块组都一样，一般都是0号块组的副本。
3. 超级块：描述**整个分区**的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。
4. 块组描述表：描述一个块组的信息（有多少个inode，多少个数据块等等）。是所有块组的集合，在每个块组都会备份一份
5. 块位图：描述整个块组中哪些块已用哪些块空闲的，那些块已经用了
6. inode位图：描述哪些inode块已经使用
7. inode表：inode块集合，inode块保存文件信息
8. 数据块：保存数据

# VSF（虚拟文件系统）

Linux支持ext，ext2，xia，minix，umsdos，msdes，fat32 ，ntfs,proc，stub，ncp，hpfs，affs 以及 ufs 等多种文件系统。为了实现这一目的，Linux 对所有的文件系统采用统一的文件界面，用户通过文件的操作界面来实现对不同文件系统的操作。对于用户来说，我们不要去关心不同文件系统的具体操作过程，而只是对一个虚拟的文件操作界面来进行操作，这个操作界面就是 Linux 的虚拟文件系统(VFS ) 

形象地说，Linux 的[内核](https://baike.baidu.com/item/内核)好象一个 PC 机的母板，VFS 就是上面的一个插槽，具体的文件系统就是一块块的接 121 卡。因此，每一个文件系统之间互不干扰，而只是调用相应的程序来实现其功能。在 Linux 的[内核](https://baike.baidu.com/item/内核)文件中，VFS 和具体的文件系统程序都放在 Linux\FS 中，其中每一种文件系统对应一个子目录，另外还有一些共用的 VFS 程序。在具体的实现上，每个文件系统都有自己的文件操作[数据结构](https://baike.baidu.com/item/数据结构)file—operations。所以，VFS 作为 ILinux[内核](https://baike.baidu.com/item/内核)中的一个软件层，用于给[用户空间](https://baike.baidu.com/item/用户空间)的程序提供文件系统接口，同时也提供了内核中的一个抽象功能，允许不同的文件系统很好地共存。VFS 使 Linux 同时安装、支持许多不同类型的文件系统成为可能。VFS 拥有关于各种[特殊文件系统](https://baike.baidu.com/item/特殊文件系统)的公共界面，如超级块、inode、文件操作函数入口等。实际文件系统的细节，统一由 VFS 的公共界面来索引，它们对系统核心和用户进程来说是透明的。

总结：VSF就是对文件系统提出一套标准化的规定，让文件系统遵循这套标准进行开发。对外屏蔽了文件系统的实现细节，对外暴露统一的接口。文件系统都是搭载在VSF上面，操作对应文件系统上面进行操作，会先走到VSF上。在由VSF转到对应的文件系统上面进行操作。

## 文件系统的读写过程是怎么样的

+ 程序调用read或者write的系统调用函数
+ 系统调用函数会触发一个80的软中断
+ 软中断的过程会把把对应的**系统调用后（内核函数数组对应的下标）**放在eax寄存器里面。每个系统调用函数都有对应的一个内核函数，该函数保存再一个数组中。
+ 然后会执行sys_calltable函数，实际上就是执行内核函数（ 系统调用函数对应的内核函数sys_write）
+ 然后内核函数里面会通过vfs得到具体对应的是哪个文件系统
+ 然后vfs就调用对应文件系统的具体函数。

## 我们分布式存储是如何实现在挂载目录下执行的操作都会走到我们存储代码。（例如就是我们在挂载点下直接touch一个文件。这个操作是通过什么的方式发送到我们glfs内部的）

+ 我们挂载对应目录的时候会告诉vfs该目录对应的文件系统nfs
+ 然后当执行到touch的时候，会先通过系统调用走到内核中
+ 内核中的vfs会区分对应的该路径是哪个文件系统下面的，然后调用文件系统nfs下的注册函数（文件系统需要自己实现touch函数）
+ glfs监听了2049端口，nfs客户端就跟我们glfs建立通信发送请求。然后我们收到nfs协议请求后解析再走我们glfs的逻辑
+ 内核只做转发，不做操作。然后我们用户态怎么做就是我们控制了，比如我们会一层一层wind到posix层，然后posix调用creat在指定目录创建文件

------

参考：

https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/10986803?fr=aladdin

https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453145565&idx=2&sn=d6764171c1f8dd99a7747ace5278ac7b&scene=21#wechat_redirect