### 用队列实现栈

+ 力扣225：[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
实现 MyStack 类：
void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 
注意：
你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
```

+ 题解：
  + 难点在于push。
  + 每次push的时候都先把值push到tmp队列
  + 然后再把real队列的数据push到tmp
  + 然后交换数据。就可以实现逆序

```cpp
class MyStack {
    queue<int> tmp;
    queue<int> real;
public:
    MyStack() {

    }

    void push(int x) {
  		// 先加入到tmp  
        tmp.push(x);
        // 然后将real的数据加到tmp。因为每次都是这个顺序，所以可以保证所有数据都是逆序
        while (!real.empty()) {
            tmp.push(real.front());
            real.pop();
        }
        // 交换数据
        swap(tmp, real);
    }

    int pop() {
        int val = real.front();
        real.pop();
        return val;
    }

    int top() {
        return real.front();
    }

    bool empty() {
        return tmp.empty() && real.empty();
    }
};
```

### 用栈实现队列

+ 力扣232：[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```
232. 用栈实现队列
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false

说明：
你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
 
进阶：
你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。
```

+ 题解：

```cpp
class MyQueue {
    stack<int> tmp;
    stack<int> real;
public:
    MyQueue() {}

    void push(int x) {
        tmp.push(x);
    }

    int pop() {
        int val = peek();
        real.pop();
        return val;
    }

    int peek() {
        // 如果real栈为空，则从tmp依次插入
        if (real.empty()) {
            while (!tmp.empty()) {
                real.push(tmp.top());
                tmp.pop();
            }
        }
        int val = real.top();
        return val;
    }

    bool empty() {
        return tmp.empty() && real.empty();
    }
};
```

### 最小栈

+ 力扣155：[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

+ 题解：
  + 使用两个stack保存数据
  + 一个stack则为正常的栈
  + 一个minStack保存sk每一位n上的最小数（0~n位上）

```cpp

class MinStack {
    // 正常的栈操作
    stack<int> sk;

    // 保存sk每一位n上的最小数（0~n位上）。
    // 例如：sk：-2, 0, -3 则minSk：-2, -2, -3
    stack<int> minSk;
public:
    MinStack() {

    }

    void push(int val) {
        sk.push(val);
        int minVal = val;
        if (!minSk.empty())
            minVal = min(val, minSk.top());
        // 保存包含当前这位的最小数
        minSk.push(minVal);
    }

    void pop() {
        sk.pop();
        minSk.pop();
    }

    int top() {
        return sk.top();
    }

    int getMin() {
        return minSk.top();
    }
};
```

------

