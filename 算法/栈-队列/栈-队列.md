### 用队列实现栈

+ 力扣225：[225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

```
请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
实现 MyStack 类：
void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
 
注意：
你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
```

+ 题解：
  + 难点在于push。
  + 每次push的时候都先把值push到tmp队列
  + 然后再把real队列的数据push到tmp
  + 然后交换数据。就可以实现逆序

```cpp
class MyStack {
    queue<int> tmp;
    queue<int> real;
public:
    MyStack() {

    }

    void push(int x) {
  		// 先加入到tmp  
        tmp.push(x);
        // 然后将real的数据加到tmp。因为每次都是这个顺序，所以可以保证所有数据都是逆序
        while (!real.empty()) {
            tmp.push(real.front());
            real.pop();
        }
        // 交换数据
        swap(tmp, real);
    }

    int pop() {
        int val = real.front();
        real.pop();
        return val;
    }

    int top() {
        return real.front();
    }

    bool empty() {
        return tmp.empty() && real.empty();
    }
};
```

### 用栈实现队列

+ 力扣232：[232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```
232. 用栈实现队列
请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：
实现 MyQueue 类：
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false

说明：
你只能使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
 
进阶：
你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。
```

+ 题解：

```cpp
class MyQueue {
    stack<int> tmp;
    stack<int> real;
public:
    MyQueue() {}

    void push(int x) {
        tmp.push(x);
    }

    int pop() {
        int val = peek();
        real.pop();
        return val;
    }

    int peek() {
        // 如果real栈为空，则从tmp依次插入
        if (real.empty()) {
            while (!tmp.empty()) {
                real.push(tmp.top());
                tmp.pop();
            }
        }
        int val = real.top();
        return val;
    }

    bool empty() {
        return tmp.empty() && real.empty();
    }
};
```

### 最小栈

+ 力扣155：[155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

```
设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]
解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

+ 题解：
  + 使用两个stack保存数据
  + 一个stack则为正常的栈
  + 一个minStack保存sk每一位n上的最小数（0~n位上）

```cpp

class MinStack {
    // 正常的栈操作
    stack<int> sk;

    // 保存sk每一位n上的最小数（0~n位上）。
    // 例如：sk：-2, 0, -3 则minSk：-2, -2, -3
    stack<int> minSk;
public:
    MinStack() {

    }

    void push(int val) {
        sk.push(val);
        int minVal = val;
        if (!minSk.empty())
            minVal = min(val, minSk.top());
        // 保存包含当前这位的最小数
        minSk.push(minVal);
    }

    void pop() {
        sk.pop();
        minSk.pop();
    }

    int top() {
        return sk.top();
    }

    int getMin() {
        return minSk.top();
    }
};
```

------

### 简化路径

+ 力扣71：[71. 简化路径](https://leetcode-cn.com/problems/simplify-path/)

```
给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 '/' 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠 '/' 。 对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。

请注意，返回的 规范路径 必须遵循下述格式：

始终以斜杠 '/' 开头。
两个目录名之间必须只有一个斜杠 '/' 。
最后一个目录名（如果存在）不能 以 '/' 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或 '..'）。
返回简化后得到的 规范路径 。

输入：path = "/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。 

输入：path = "/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。

输入：path = "/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

输入：path = "/a/./b/../../c/"
输出："/c"
```

+ 题解：

  + 根据/进行切割成多个子string

    + 空字符串
    + 一个点.
    + 两个点..
    + 只包含英文字母、数字或 _ 的目录名。

  + 对于「空字符串」以及「一个点」，我们实际上无需对它们进行处理，因为「空字符串」没有任何含义，而「一个点」表示当前目录本身，我们无需切换目录。

  + 对于「两个点」或者「目录名」，我们则可以用一个栈来维护路径中的每一个目录名。当我们遇到「两个点」时，需要将目录切换到上一级，因此只要栈不为空，我们就弹出栈顶的目录。当我们遇到「目录名」时，就把它放入栈。

```cpp
class Solution {
 public:
  vector<string> split(string path, char ch) {
    vector<string> vec;
    int start = 0;
    int end = 0;
    while ((end = path.find('/', start)) != string::npos) {
      vec.push_back({path.begin() + start, path.begin() + end});
      start = end + 1;
    }
    if (start < path.length())
      vec.push_back({path.begin() + start, path.end()});

    return vec;
  }
  string simplifyPath(string path) {
    vector<string> sk;
    vector<string> name = split(path, '/');
    for (int i = 0; i < name.size(); i++) {
      // 遇到..则弹出栈的一个元素
      if (name[i] == "..") {
        if (!sk.empty()) sk.pop_back();
      } else if (name[i] != "." && name[i].length() > 0) {
        sk.push_back(name[i]);
      }
    }
    string ans;
    if (sk.empty()) {
      ans = "/";
    } else {
      for (auto& str : sk) {
        ans += '/' + str;
      }
    }
    return ans;
  }
};
```

###      有效的括号

+ 力扣20：[20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

```
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

输入：s = "()[]{}"
输出：true

输入：s = "()[]{}"
输出：true
```

+ 题解

```cpp
class Solution {
 public:
  bool isValid(string s) {
    unordered_map<char, char> map{
        {'}', '{'},
        {']', '['},
        {')', '('},
    };
    stack<char> sk;
    for (auto ch : s) {
      if (ch == '}' || ch == ']' || ch == ')') {
      	// 此时为空栈则为false
        if (sk.empty()) return false;
        // 判断栈顶元素是不是配对
        if (sk.top() != map[ch]) return false;
        sk.pop();
      } else {
        sk.push(ch);
      }
    }
    return sk.empty(); // 栈为空，则所有配对，否则有单个情况
  }
};
```

### 比较含退格的字符串

+ 力扣844：[844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)

```
给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。
如果相等，返回 true ；否则，返回 false 。
注意：如果对空文本输入退格字符，文本继续为空。

输入：s = "ab#c", t = "ad#c"
输出：true
解释：S 和 T 都会变成 “ac”。

输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 “c”，但 t 仍然是 “b”。
```

+ 题解：
  + 遇到非#则加入到新字符串
  + 遇到#则将新字符串弹出最后一个元素

```cpp
class Solution {
 public:
  string delCh(string s) {
    string ans;
    int fast = 0;
    while (fast < s.length()) {
      if (s[fast] != '#') {
        ans.push_back(s[fast]);
      } else {
        if (ans.length() > 0) ans.pop_back();
      }
      fast++;
    }
    return ans;
  };
  bool backspaceCompare(string s, string t) { return delCh(s) == delCh(t); }
};
```

###  整理字符串

+ 力扣1544：[1544. 整理字符串](https://leetcode-cn.com/problems/make-the-string-great/)

```
给你一个由大小写英文字母组成的字符串 s 。
一个整理好的字符串中，两个相邻字符 s[i] 和 s[i+1]，其中 0<= i <= s.length-2 ，要满足如下条件:
若 s[i] 是小写字符，则 s[i+1] 不可以是相同的大写字符。
若 s[i] 是大写字符，则 s[i+1] 不可以是相同的小写字符。
请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 两个相邻 字符并删除，直到字符串整理好为止。
请返回整理好的 字符串 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。
注意：空字符串也属于整理好的字符串，尽管其中没有任何字符。

输入：s = "leEeetcode"
输出："leetcode"
解释：无论你第一次选的是 i = 1 还是 i = 2，都会使 "leEeetcode" 缩减为 "leetcode" 。

输入：s = "abBAcC"
输出：""
解释：存在多种不同情况，但所有的情况都会导致相同的结果。例如：
```

+ 题解：
  + 遇到当前字符与新字符串最后一个字符互为大小写则弹出新字符最后一个字符
  + 互为大小写公式：abs(ch1 - ch2) == abs('a' - 'A')

```cpp
class Solution {
 public:
  string makeGood(string s) {
    string sk;
    for (auto& ch : s) {
      if (!sk.empty() && abs(ch - sk.back()) == abs('a' - 'A')) {
        sk.pop_back();
      } else {
        sk.push_back(ch);
      }
    }
    return sk;
  }
};
```

### 删除字符串中的所有相邻重复项

+ 力扣1047：[删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

```
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。
在 S 上反复执行重复项删除操作，直到无法继续删除。
在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

+ 题解：
  + 遇到当前字符与新字符串最后一个字符相同则弹出新字符最后一个字符

```cpp
class Solution {
 public:
  string removeDuplicates(string s) {
    string sk;
    for (auto& ch : s) {
      if (!sk.empty() && ch == sk.back()) {
        sk.pop_back();
      } else {
        sk.push_back(ch);
      }
    }
    return sk;
  }
};
```

### 删除字符串中的所有相邻重复项 I

+ 力扣1209：[删除字符串中的所有相邻重复项 II](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string-ii/)

```
给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。
你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。
在执行完所有删除操作后，返回最终得到的字符串。
本题答案保证唯一。

输入：s = "abcd", k = 2
输出："abcd"
解释：没有要删除的内容。

输入：s = "deeedbbcccbdaa", k = 3
输出："aa"
解释： 
先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"
再删除 "bbb"，得到 "dddaa"
最后删除 "ddd"，得到 "aa"
```

+ 题解
  + 用一个栈统计当前位置的字符出现了多少次
  + 当前字符与前一个不同时，往栈中压入 `1`。否则栈顶元素加 `1`。
  + 判断当前栈顶元素是否等于k，如果等于k则删除s的k个元素

```cpp
class Solution {
 public:
  string removeDuplicates(string s, int k) {
    stack<int> count;
    for (int i = 0; i < s.length(); i++) {
      if (i == 0 || s[i] != s[i - 1]) {
        count.push(1);
      } else {
        if ((++count.top()) == k) {
          // 在i-k+1的位置上删除k个元素
          s.erase(i - k + 1, k);
          count.pop();
          // 重新设置i的位置
          i = i - k;
        }
      }
    }
    return s;
  }
};
```

### 字符串解码

+ 力扣394：[394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)

```
给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

输入：s = "3[a]2[bc]"
输出："aaabcbc"

输入：s = "3[a2[c]]"
输出："accaccacc"

输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

+ 题解：
  + 暴力模拟：用一个栈模拟

```cpp
class Solution {
 public:
  int GetNum(vector<string>& sk) {
    int num = 0;
    int carry = 1;
    while (!sk.empty() && isdigit(sk.back()[0])) {
      num += int(sk.back()[0] - '0') * carry;
      sk.pop_back();
      carry *= 10;
    }
    return num;
  }

  string decodeString(string s) {
    string ans;
    vector<string> sk;
    int num = 1;
    for (int idx = 0; idx < s.length(); idx++) {
      char ch = s[idx];
      if (ch == ']') {

        // 弹出[]内的所有字符
        string tmp;
        while (sk.back() != "[") {
          tmp = sk.back() + tmp;
          sk.pop_back();
        }
        sk.pop_back();

        // 增加几次
        int num = GetNum(sk);
        while (num--) {
          sk.push_back({tmp.begin(), tmp.end()});
        }
      } else {
        sk.push_back({ch});
      }
    }
    for (auto& elm : sk) ans += elm;
    return ans;
  }
};
```

+ 优秀的解法：[ 字符串解码（辅助栈法 / 递归法，清晰图解）](https://leetcode-cn.com/problems/decode-string/solution/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/)

```cpp
string decodeString(string s) {
	//两个栈分别压int res和用pair
	stack<pair<int, string>> sta;
	int num = 0; string res = "";
	//循环检查字符串
	for (int i = 0; i < s.size(); i++) {
		//遇到数字则存入num
		if (s[i] >= '0'&&s[i] <= '9') {
			num *= 10;
			num += (s[i] - '0');//这里括号是否需要
		}
		else if (s[i] == '[') {//遇到[压栈数字和字符串，置零置空
            // 压入[]要执行的次数
            // 和[]前面的字符串，用于下次遇到]进行拼接
			sta.push(make_pair(num, res));
			num = 0;
			res = "";
		}
		else if (s[i] == ']') {//遇到]出栈数字和字符串，组装
			int n = sta.top().first;//n指示的是res的循环次数，不是a的
			string a = sta.top().second;	// ${string}[]，[]之前的字符串
			sta.pop();
			for (int i = 0; i < n; i++)  a = a + res; //循环n次
			res = a;
		}
		else {//遇到字符存入字符
			res += s[i];
		}		
	}
	return res;
}
```

