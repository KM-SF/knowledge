## 最好用的方法

1. 先试用暴力递归的方式写出答案
   1. 可变参数的维度（整数，数组），最好是整数，面试中如果是数组则这个暴力递归可以抛弃换一个
   2. 可变参数的个数，个数决定了dp转换出来的表结构是几维

2. 对上面暴力递归的方式进行改进（记忆搜索方法）
   1. 分析暴力递归的可变参数
   2. 有几个可变参数就需要几维数组，然后每个可变参数的取值范围就是数组的大小
   3. 递归终止条件加多一个判断dp数组上面的值是否存在，存在则直接放回
3. 对记忆搜索方法进行改进（动态规划）
   1. 记忆搜索方法需要几维数组，这里也是需要几维数组
   2. 标出暴力递归的最终结束位置，即这个动态规划最后的结果
   3. 初始化记忆搜索方法中，不用计算可以得到的答案的位置
   4. 看记忆搜索方法中，看下当前位置是怎么依赖其他位置的值，进行计算
   5. 看下动态规划的dp是从哪个位置计算到哪个位置（for循环的顺序）
   6. 将记忆搜索方法的递归的计算方法直接拷贝到for循环执行体中

## 坐标系

### 剑指 Offer 10- I.斐波那契数列

+ 剑指offer10：[斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

```
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
```

+ 题解

```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }
        return dp[n] ;
    }
};
```

### 爬楼梯

+ 力扣70：[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

+ 题解：

  + 解法跟斐波那契一样。

  + 转换方程：

    F(0) = 0,   F(1) = 1，F(2) = 2
    F(N) = F(N - 1) + F(N - 2), 其中 N > 2.

```cpp
class Solution {
 public:
  int climbStairs(int n) {
    if (n <= 2) return n;
    vector<int> dp(n + 1, 0);
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i < n + 1; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
  }
};
```

### 零钱兑换

+ 力扣322：[零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

输入：coins = [2], amount = 3
输出：-1
```

+ 题解：
  + dp[i] = min(dp[i-coins[j]]+1)
  + 当需要i块钱时，可以i-coins[j] +1 (i-coins[j]>0)。
  + 可以由coins的所有硬币dp[i-coins[j]]+1凑成
  + 需要的硬币数最少则等于dp[i]需要的硬币数

```cpp
class Solution {
 public:
  int coinChange(vector<int>& coins, int amount) {
    // 给dp赋初值，最多的硬币数就是全部使用面值1的硬币进行换
    // amount + 1 是不可能达到的换取数量，于是使用其进行填充
    // dp[i] 标示：amoun等于i最少可以有多少种方法
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;
    for (int i = 1; i < amount + 1; i++) {
      // 当需要i块钱时，可以由coins的所有硬币dp[i-coins[j]]+1凑成
      // 需要的硬币数最少则等于dp[i]需要的硬币数
      for (int j = 0; j < coins.size(); j++) {
        if (i - coins[j] >= 0) {
          dp[i] = min(dp[i], dp[i - coins[j]] + 1);  //
        }
      }
    }
    return dp[amount] > amount ? -1 : dp[amount];
  }
};
```

### 最长递增子序列

+ 力扣300：[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

+ 题解：[300. 最长递增子序列（动态规划 + 二分查找，清晰图解）](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/)

  + 状态定义：dp[i]的值代表 nums 以 nums[i]结尾的最长子序列长度。

  + 转移方程： 设 j∈[0,i)，考虑每轮计算新 dp[i]时，遍历 [0,i)列表区间，做以下判断：

    1. 当 nums[i] > nums[j]时： nums[i]可以接在 nums[j]之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j] + 1；
    2. 当 nums[i] <= nums[j]时： nums[i]无法接在 nums[j]之后，此情况上升子序列不成立，跳过。
    3. 上述所有 1. 情况 下计算出的 dp[j] + 1的最大值，为直到 ii 的最长上升子序列长度（即 dp[i] ）。实现方式为遍历 j 时，每轮执行 dp[i] = max(dp[i], dp[j] + 1))。
  
  + 转移方程： dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。    
  + 初始状态：dp[i]所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
  + 返回值：返回 dp列表最大值，即可得到全局最长上升子序列长度。

```cpp
class Solution {
 public:
  int lengthOfLIS(vector<int>& nums) {
    vector<int> dp(nums.size(), 1);
    int ans = 0;
    for (int i = 0; i < nums.size(); i++) {
      for (int j = 0; j < i; j++) {
        // 如果i元素大于j元素，则dp[i]等于dp[j]+1
        if (nums[i] > nums[j]) {
          dp[i] = max(dp[i], dp[j] + 1);
        }
      }
      ans = max(ans, dp[i]);
    }
    return ans;
  }
};
```

### 最大子数组和

+ 力扣53：[最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

+ 题解：

  + 状态定义：dp[i]的值代表 nums 以 nums[i]结尾的最大和的连续子数组。
  + 转移方程： dp[i] = max(nums[i] +dp[i-1],nums[i])。    
  
  
    + 初始状态：dp[0]=nums[0]，从下标1开始遍历
  
  
    + 返回值：返回 dp列表最大值，即可得到全局最大子数组和
  

```cpp
class Solution {
 public:
  int maxSubArray(vector<int>& nums) {
    vector<int> dp(nums.size(), 0);
    int ans = nums[0];
    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); i++) {
      dp[i] = max(nums[i] + dp[i - 1], nums[i]);
      ans = max(ans, dp[i]);
    }
    return ans;
  }
};
```

### 乘积最大子数组

+ 力扣152：[乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

```
给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。

输入: [-2,3,-4]
输出: 24
```

+ 题解：
  + 题解跟上面最大子数组和差不多，只是会出现两个负号相乘等于整数的情况
  + 状态定义：
    + dpMax[i]的值代表 nums 以 nums[i]结尾的最大乘积的连续子数组。
    + dpMin[i]的值代表 nums 以 nums[i]结尾的最小乘积的连续子数组。
  + 转移方程：
    + dpMax[idx] = max(max(dpMax[idx - 1] * nums[idx], dpMin[idx - 1] * nums[idx]), nums[idx]);	dpMin可能是负数，负数*负数等于正数
    + dpMin[idx] = min(min(dpMax[idx - 1] * nums[idx], dpMin[idx - 1] * nums[idx]), nums[idx]);    正数*负数等于负数
  + 初始状态：dpMax[0]=nums[0]，dpMin[0]=nums[0]，从下标1开始遍历
  + 返回值：返回 dpMax列表最大值，即可得到全局最大子数组乘积

```cpp
class Solution {
public:
    int maxProduct(vector<int> &nums) {
        int ans = nums[0];
        vector<int> dpMax(nums.size(), 0);
        vector<int> dpMin(nums.size(), 0);
        dpMax[0] = nums[0];
        dpMin[0] = nums[0];
        for (int idx = 1; idx < nums.size(); idx++) {
            dpMax[idx] = max(max(dpMax[idx - 1] * nums[idx], dpMin[idx - 1] * nums[idx]), nums[idx]);
            dpMin[idx] = min(min(dpMax[idx - 1] * nums[idx], dpMin[idx - 1] * nums[idx]), nums[idx]);
            ans = max(ans, dpMax[idx]);
        }
        return ans;
    }
};
```

### 不同路径

+ 力扣62：[不同路径](https://leetcode-cn.com/problems/unique-paths/)

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

输入：m = 3, n = 7
输出：28
```

+ 题解：
  + 状态定义：dp[i]\[j]表示走到第i行j列总共有多少条路径
  + 转移方程：dp[i]\[j] = dp[i-1]\[j]+dp[i]\[j-1]; 表示该格子的路径总数等于上一个格子路径+左边格子路径
  + 初始状态：
    + dp[i]\[0]=1最左边一列，只能往下走，所以只有一条路径
    + dp[i]\[0]=1最上面一行，只能往右走，所以只有一条路径
  + 返回值：dp[m-1]\[n-1]，dp的最后一行一列

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m ; i++) {
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        for (int i = 1; i < m ; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

### 不同路径 II

+ 力扣63：[不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。

输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

+ 题解：
  + 跟上面`不同路径`差不多。只是如果遇到障碍就直接跳过

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size(); int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m ; i++) {
            // 遇到障碍了，无法往下继续走，所以下面的都是0
            if (obstacleGrid[i][0]==1) break;
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            // 遇到障碍了，无法往右继续走，所以右边的都是0
            if (obstacleGrid[0][i]==1) break;
            dp[0][i] = 1;
        }
        for (int i = 1; i < m ; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j]==1) continue;
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

### 最小路径和

+ 力扣64：[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

```
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。

输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

+ 题解：
  + 解法跟上面`不同路径`差不多。只是不是累加上面和左边的结果，而是从上面或者左边选择最小值

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m = grid.size(); int n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = grid[0][0];
        // 最左边一列的结果都是累加
        for (int i = 1; i < m ; i++) {
            dp[i][0] = dp[i-1][0]+grid[i][0];
        }
        // 最上面一行的结果都是累加
        for (int i = 1; i < n; i++) {
            dp[0][i] = dp[0][i-1]+grid[0][i];
        }
        for (int i = 1; i < m ; i++) {
            for (int j = 1; j < n; j++) {
                // 从上面和左边的dp结果选择较小的
                dp[i][j] = min(dp[i-1][j],dp[i][j-1]) +grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
};
```

### 完全平方数

+ 力扣279：[完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

```
给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4

输入：n = 13
输出：2
解释：13 = 4 + 9
```

+ 题解：
  + 状态定义：dp[i]表示和为i 需要的完全平方数最少数量
  + 转移方程：dp[i]的取值为：i-j*j的最少情况+j * j 这种情况。dp[i] = min(dp[i], dp[i - j * j] + 1);
  + 初始状态：
    + dp[1]=1 数字1只有1种情况
    + dp[i]=i 数字i最坏情况需要i个1，所以是i
  + 返回值：dp[n]


```cpp
class Solution {
 public:
  int numSquares(int n) {
    vector<int> dp(n + 1);
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i < n + 1; i++) {
      // 最坏的情况就是i个1，所以初始化为i
      dp[i] = i;
      // 只需要遍历j*j<=i次，因为如果j*j>i的话，j+1就没有意义了
      for (int j = 1; j * j <= i; j++) {
        // i-j*j的最少情况 + j*j这个一种情况
        dp[i] = min(dp[i], dp[i - j * j] + 1);
      }
    }
    return dp[n];
  }
};
```

 整数拆分

+ 力扣343：[ 整数拆分](https://leetcode-cn.com/problems/integer-break/)

```
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积 。

输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

+ 题解
  + 状态定义：dp[i]表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积
  + 转移方程：假设对正整数 ii 拆分出的第一个正整数是 j（1 <= j < i），则有以下两种方案：
    + 将 i 拆分成 j 和 i-j的和，且 i-j **不再**拆分成多个正整数，此时的乘积是 j×(i−j)；
    + 将 i 拆分成 j 和i−j 的和，且 i-j **继续**拆分成多个正整数，此时的乘积是 j×dp[i−j]。
  + dp[i] = max(dp[i], max(dp[i - j] * j, (i - j) * j))
  + 初始状态：
    + dp[0]=0 
    + dp[1]=0
  + 返回值：dp[n]

```
class Solution {
 public:
  int integerBreak(int n) {
    vector<int> dp(n + 1, 0);

    for (int i = 2; i < n + 1; i++) {
      for (int j = 1; j < i; j++) {
        dp[i] = max(dp[i], max(dp[i - j] * j, (i - j) * j));
      }
    }
    return dp[n];
  }
};
```

### 比特位计数

+ 力扣338：[比特位计数](https://leetcode-cn.com/problems/counting-bits/)

```
给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

+ 题解：
  + 状态定义：dp[i]表示将正整数 i 总共有多少个1
  + 转移方程：dp[i] = dp[i & (i - 1)] + 1;
    + i & (i - 1) 每次去掉最右边的1
    + i的1个数等于i&(i-1)的个数 + 1
  + 初始状态：dp[0]=0 
  + 返回值：dp

```cpp
class Solution {
 public:
  vector<int> countBits(int n) {
    vector<int> dp(n + 1);
    /*
    通过位运算计算
    for (int i = 1; i < n + 1; i++) {
      int m = i;
      int cnt = 0;
      while (m) {
        cnt++;
        m &= (m - 1);
      }
      dp[i] = cnt;
    }
    */

    // i & (i - 1) 每次去掉最右边的1
    // i的1个数等于i&(i-1)的个数 + 1
    for (int i = 1; i < n + 1; i++) {
      // 利用统计i & (i - 1)的情况 + 自己的一个1得到总共1个数
      dp[i] = dp[i & (i - 1)] + 1;
    }
    return dp;
  }
};
```



### 最长回文子串

+ 力扣5：[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

  ```
  给你一个字符串 s，找到 s 中最长的回文子串。
  
  输入：s = "babad"
  输出："bab"
  解释："aba" 同样是符合题意的答案。
  
  输入：s = "cbbd"
  输出："bb"
  ```

+ 题解：

  + 一个回文去掉两头以后，剩下的部分依然是回文
  + 如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；
  + 如果一个字符串的头尾两个字符相等，才有必要继续判断下去。
    + 如果里面的子串是回文，整体就是回文串；
    + 如果里面的子串不是回文串，整体就不是回文串。
  + 第 1 步：定义状态：dp[i][j] 表示子串 s[i..j] 是否为回文子串，这里子串 s[i..j] 定义为左闭右闭区间，可以取到 s[i] 和 s[j]。
  + 第 2 步：思考状态转移方程：dp[i][j] = (s[i] == s[j]) and dp\[i + 1][j - 1]
    + 表达式 `[i + 1, j - 1]` 不构成区间，即长度严格小于 `2`，即 `j - 1 - (i + 1) + 1 < 2` ，整理得 `j - i < 3`。
    + 如果子串 `s[i + 1..j - 1]` 只有 1 个字符，即去掉两头，剩下中间部分只有 11 个字符，显然是回文
    + 如果子串 `s[i + 1..j - 1]` 为空串，那么子串 `s[i, j]` 一定是回文子串
    + 因此，在 `s[i] == s[j]` 成立和 `j - i < 3` 的前提下，直接可以下结论，`dp[i][j] = true`，否则才执行状态转移

  ```python
  class Solution(object):
      def longestPalindrome(self, s):
          """
          :type s: str
          :rtype: str
          """
          string = s
          n = len(string)
          f = [[False] * (n) for _ in range(n)]
          for idx in range(n):
              f[idx][idx] = True # 单个字母是回文
          max_val = 1
          begin = 0
          for j in range(1, n):
              for i in range(j):
                  if string[i] != string[j]: # 首尾不相等，则返回false
                      f[i][j] = False
                  else:
                      if j - i < 3: # 判断区间是不是严格小于2
                          f[i][j] = True
                      else:
                          f[i][j] = f[i + 1][j - 1]
                  if f[i][j] and j - i + 1 > max_val:
                      max_val = j - i + 1
                      begin = i
          return string[begin:begin + max_val]
  ```

  

