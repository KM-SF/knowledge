## 最好用的方法

1. 先试用暴力递归的方式写出答案
   1. 可变参数的维度（整数，数组），最好是整数，面试中如果是数组则这个暴力递归可以抛弃换一个
   2. 可变参数的个数，个数决定了dp转换出来的表结构是几维

2. 对上面暴力递归的方式进行改进（记忆搜索方法）
   1. 分析暴力递归的可变参数
   2. 有几个可变参数就需要几维数组，然后每个可变参数的取值范围就是数组的大小
   3. 递归终止条件加多一个判断dp数组上面的值是否存在，存在则直接放回
3. 对记忆搜索方法进行改进（动态规划）
   1. 记忆搜索方法需要几维数组，这里也是需要几维数组
   2. 标出暴力递归的最终结束位置，即这个动态规划最后的结果
   3. 初始化记忆搜索方法中，不用计算可以得到的答案的位置
   4. 看记忆搜索方法中，看下当前位置是怎么依赖其他位置的值，进行计算
   5. 看下动态规划的dp是从哪个位置计算到哪个位置（for循环的顺序）
   6. 将记忆搜索方法的递归的计算方法直接拷贝到for循环执行体中

## 坐标系

### 剑指 Offer 10- I.斐波那契数列

+ 剑指offer10：[斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

```
写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
```

+ 题解

```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1, 0);
        dp[1] = 1;
        for (int i = 2; i < n + 1; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        }
        return dp[n] ;
    }
};
```

### 爬楼梯

+ 力扣70：[爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

+ 题解：

  + 解法跟斐波那契一样。

  + 转换方程：

    F(0) = 0,   F(1) = 1，F(2) = 2
    F(N) = F(N - 1) + F(N - 2), 其中 N > 2.

```cpp
class Solution {
 public:
  int climbStairs(int n) {
    if (n <= 2) return n;
    vector<int> dp(n + 1, 0);
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i < n + 1; i++) {
      dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
  }
};
```

### 零钱兑换

+ 力扣322：[零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。

输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

输入：coins = [2], amount = 3
输出：-1
```

+ 题解：
  + dp[i] = min(dp[i-coins[j]]+1)
  + 当需要i块钱时，可以i-coins[j] +1 (i-coins[j]>0)。
  + 可以由coins的所有硬币dp[i-coins[j]]+1凑成
  + 需要的硬币数最少则等于dp[i]需要的硬币数

```cpp
class Solution {
 public:
  int coinChange(vector<int>& coins, int amount) {
    // 给dp赋初值，最多的硬币数就是全部使用面值1的硬币进行换
    // amount + 1 是不可能达到的换取数量，于是使用其进行填充
    // dp[i] 标示：amoun等于i最少可以有多少种方法
    vector<int> dp(amount + 1, amount + 1);
    dp[0] = 0;
    for (int i = 1; i < amount + 1; i++) {
      // 当需要i块钱时，可以由coins的所有硬币dp[i-coins[j]]+1凑成
      // 需要的硬币数最少则等于dp[i]需要的硬币数
      for (int j = 0; j < coins.size(); j++) {
        if (i - coins[j] >= 0) {
          dp[i] = min(dp[i], dp[i - coins[j]] + 1);  //
        }
      }
    }
    return dp[amount] > amount ? -1 : dp[amount];
  }
};
```

### 最长递增子序列

+ 力扣300：[最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

+ 题解：[300. 最长递增子序列（动态规划 + 二分查找，清晰图解）](https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-dong-tai-gui-hua-2/)

  + 状态定义：dp[i]的值代表 nums 以 nums[i]结尾的最长子序列长度。

  + 转移方程： 设 j∈[0,i)，考虑每轮计算新 dp[i]时，遍历 [0,i)列表区间，做以下判断：

    1. 当 nums[i] > nums[j]时： nums[i]可以接在 nums[j]之后（此题要求严格递增），此情况下最长上升子序列长度为 dp[j] + 1；
    2. 当 nums[i] <= nums[j]时： nums[i]无法接在 nums[j]之后，此情况上升子序列不成立，跳过。
    3. 上述所有 1. 情况 下计算出的 dp[j] + 1的最大值，为直到 ii 的最长上升子序列长度（即 dp[i] ）。实现方式为遍历 j 时，每轮执行 dp[i] = max(dp[i], dp[j] + 1))。
  
  + 转移方程： dp[i] = max(dp[i], dp[j] + 1) for j in [0, i)。    
  + 初始状态：dp[i]所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1。
  + 返回值：返回 dp列表最大值，即可得到全局最长上升子序列长度。

```cpp
class Solution {
 public:
  int lengthOfLIS(vector<int>& nums) {
    vector<int> dp(nums.size(), 1);
    int ans = 0;
    for (int i = 0; i < nums.size(); i++) {
      for (int j = 0; j < i; j++) {
        // 如果i元素大于j元素，则dp[i]等于dp[j]+1
        if (nums[i] > nums[j]) {
          dp[i] = max(dp[i], dp[j] + 1);
        }
      }
      ans = max(ans, dp[i]);
    }
    return ans;
  }
};
```

### 最大子数组和

+ 力扣53：[最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

```
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

+ 题解：

  + 状态定义：dp[i]的值代表 nums 以 nums[i]结尾的最大和的连续子数组。
  + 转移方程： dp[i] = max(nums[i] +dp[i-1],nums[i])。    


  + 初始状态：dp[0]=nums[0]，从下标1开始遍历
  + 返回值：返回 dp列表最大值，即可得到全局最大子数组和

```cpp
class Solution {
 public:
  int maxSubArray(vector<int>& nums) {
    vector<int> dp(nums.size(), 0);
    int ans = nums[0];
    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); i++) {
      dp[i] = max(nums[i] + dp[i - 1], nums[i]);
      ans = max(ans, dp[i]);
    }
    return ans;
  }
};
```



### 最长回文子串

+ 力扣5：[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

  ```
  给你一个字符串 s，找到 s 中最长的回文子串。
  
  输入：s = "babad"
  输出："bab"
  解释："aba" 同样是符合题意的答案。
  
  输入：s = "cbbd"
  输出："bb"
  ```

+ 题解：

  + 一个回文去掉两头以后，剩下的部分依然是回文
  + 如果一个字符串的头尾两个字符都不相等，那么这个字符串一定不是回文串；
  + 如果一个字符串的头尾两个字符相等，才有必要继续判断下去。
    + 如果里面的子串是回文，整体就是回文串；
    + 如果里面的子串不是回文串，整体就不是回文串。
  + 第 1 步：定义状态：dp[i][j] 表示子串 s[i..j] 是否为回文子串，这里子串 s[i..j] 定义为左闭右闭区间，可以取到 s[i] 和 s[j]。
  + 第 2 步：思考状态转移方程：dp[i][j] = (s[i] == s[j]) and dp\[i + 1][j - 1]
    + 表达式 `[i + 1, j - 1]` 不构成区间，即长度严格小于 `2`，即 `j - 1 - (i + 1) + 1 < 2` ，整理得 `j - i < 3`。
    + 如果子串 `s[i + 1..j - 1]` 只有 1 个字符，即去掉两头，剩下中间部分只有 11 个字符，显然是回文
    + 如果子串 `s[i + 1..j - 1]` 为空串，那么子串 `s[i, j]` 一定是回文子串
    + 因此，在 `s[i] == s[j]` 成立和 `j - i < 3` 的前提下，直接可以下结论，`dp[i][j] = true`，否则才执行状态转移

  ```python
  class Solution(object):
      def longestPalindrome(self, s):
          """
          :type s: str
          :rtype: str
          """
          string = s
          n = len(string)
          f = [[False] * (n) for _ in range(n)]
          for idx in range(n):
              f[idx][idx] = True # 单个字母是回文
          max_val = 1
          begin = 0
          for j in range(1, n):
              for i in range(j):
                  if string[i] != string[j]: # 首尾不相等，则返回false
                      f[i][j] = False
                  else:
                      if j - i < 3: # 判断区间是不是严格小于2
                          f[i][j] = True
                      else:
                          f[i][j] = f[i + 1][j - 1]
                  if f[i][j] and j - i + 1 > max_val:
                      max_val = j - i + 1
                      begin = i
          return string[begin:begin + max_val]
  ```

  

