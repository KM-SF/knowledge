# 类型

## 总分类

1. 计数：
   1. 有多少种方式走到右下角
   2. 有多少种方法选出k个数使得和是sum
2. **求最大最小值：频率最高**
   1. 从左上角走到右下角路径的最大数字和
   2. 最长上升子序长度
3. 求存在性
   1. 取石子游戏，先手是否必胜
   2. 能不能选出K个数使得和是sum

## 子分类

1. 坐标型：
   1. 给定一个序列或者网格。找到序列中某个序列或者网格中的某条路径
   2. 下标为序列下标i或者网格坐标(i,j)。f[i]：以第i个元素的结尾的某种性质，f[i]\[j]：到格子(i,j)的路径性质
2. 序列型：**前i个**关键字，
3. 划分型：
4. 背包型

|        | 数组大小           | 结果                         |
| ------ | ------------------ | ---------------------------- |
| 坐标型 | n，n^2             | f[n-1]或者max{f[0]...f[n-1]} |
| 序列型 | n+1                | f[n-1]                       |
| 划分型 | n+1                | f[n-1]                       |
| 背包型 | n，n^2（背包重量） | f[target]或者f[n]\[targhet]  |

# 例子

+ 这里用一个例子进行下面步骤的讲解。

+ 问题：LeetCode（322）

  > + 你有三种硬币，分别面值是2元，5元，7元。每种硬币都有足够多
  > + 买一本书需要27元
  > + 如何用最少的硬币组合正好付清，不需要对方找钱

# 步骤

## 步骤一：确定状态

+ 确定状态：状态在动态规划中的作用属于定海神针
+ 举例：解动态规划的时候需要开一个数组，数组的每个元素f[i]或者f[i] [j]代表什么。类似于解数学题中的，X,Y,Z代表什么
+ 确定状态需要两个意识：
  1. 最后一步（最优的策略）：
     1. 我们不知道最优策略是什么，但是最优策略肯定是k枚硬币a1,a2,...,ak面值加起来是27
     2. 所以一定有**最后一枚硬币：ak**
     3. 除掉这枚硬币，前面的面值加起来是27-ak
  2. 子问题：
     1. **我们不需要关心前面K-1的硬币是怎么拼出27-ak，但是我们能确定前面的硬币是可以拼出27-ak**
     2. **因为是最优策略，所以27-ak的硬币数一定是最少的，否则不是最优解**
     3. 那这样我们就变成最少用多少硬币可以拼接成27-ak值
     4. 我们假设F(X)=最少用多少枚硬币拼出X
     5. ak的是多少：
        1. ak只能是2,5,7（因为硬币的值就是257）
        2. 假设ak=2，f(27)=f(27-2)+1(加上最后一枚硬币2)
        3. 假设ak=5，f(27)=f(27-5)+1(加上最后一枚硬币5)
        4. 假设ak=7，f(27)=f(27-7)+1(加上最后一枚硬币7)
     6. **那么最少硬币数：f(27)=min( f(27-2)+1, f(27-5)+1, f(27-7)+1 )**

## 步骤二：转移方程

+ 将()改成[]
+ 我们由步骤一可以得到最优得状态是：f[X]=最少用多少枚硬币拼出X。f[X]=min( f[X-2]+1, f[X-5]+1, f[X-7]+1 )

## 步骤三：初始条件和边界情况

+ 由步骤二可以得到方程：f[X]=min( f[X-2]+1, f[X-5]+1, f[X-7]+1 )
+ 那么有两个问题：X-2，X-5或者X-7小于0怎么办，什么时候停下来 
+ 如果不能拼出Y，就定义f[Y]=正无穷。例如：f[-1]=f[-2]=f[负数]=正无穷
+ 初始条件：f[0]=0 

## 步骤四：计算顺序

+ 计算等号左边f[x]时，等号右边的值都已知。则是从左往右（从小到大），否则从右往左（从大到小）。
  + 计算f[x]时，f[x-2]，f[x-5]，f[x-7]都已经知道

## 步骤总结

1. 确定状态
   1. 最后一步（最优策略中使用的最后一枚硬币）
   2. 化成子问题（最少的硬币拼出更小的面值27-ak）
2. 转移方程：
   1. f[x]=min(f[x-2]+1,f[x-5]+1,f[x-7]+1)
3. 初始化和边界情况
   1. f[0]=0
   2. 不能拼出f[y]，则f[y]=正无穷
4. 计算顺序
   1. 先从最先能得到结果的开始计算

# 上面例子答案：

```python
def coinChange(coins, amount):
    """
    :type coins: List[int]
    :type amount: int
    :rtype: int
    """
	num = len(coins)
    // 0...n：[n+1]
    // 0...n-1：[n]
    f = [sys.maxsize for i in range(amount+1)]
    f[0] = 0
    i = 1
    while(i<=amount):
        j = 0
        # f[i] = min(f[i-coins[j]]+1 ... )
        while(j<num):
            if i>=coins[j] and f[i-coins[j]]!=sys.maxsize:
                f[i] = min(f[i-coins[j]]+1,f[i])
            j += 1
        i += 1
    
    if f[amount] == sys.maxsize:
        f[amount] = -1
    return f[amount];
```

# 开数组的位数

跟目标的需要多少个参数，1个则一位，2个则2位

## 背包问题

+ 转移方程公式：

  ```
  dp[i][j] 表示使用前i个装满容积j的方法个数
  dp[0][0] = 1
  dp[i][j] += dp[i-1][j-k*size];
  ```

+ 例子：

  + [背包问题](https://www.lintcode.com/problem/backpack)
  + [背包问题 V](https://www.lintcode.com/problem/backpack-v)
  + [组合总和 IV](https://www.lintcode.com/problem/combination-sum-iv)