# 总结

### 模板：

对于需要从左子树获得信息（left），从右子树获得信息（right），然后将left和right信息整合在一起的可以使用一下模板

```cpp
// 从左右子树得到的结果
struct Info {
	int height; // 例子：高度。需要的信息
    // ... 依次补充需要从子树拿到什么信息
    Info(int h) {
        height = h;
    }
};

// 返回值
Info* dfs(TreeNode *root) {
    if (!root) {
        // todo
        return Info(0);
    }
    
    Info* left = dfs(root->left);
    Info* right = dfs(root->right);
    // TODO: 信息整合
    // left,right -> res
    return Info(max(left->height, right->height));
}
```

### 深度优先搜索：递归

#### 先序遍历：

```python
# 需要先记录结果，在进行递归（自顶向下）
class Solution(object):
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
        	return
		# TODO: do work
        preorderTraversal(root.left)
        preorderTraversal(root.right)
```

#### 中序遍历：

```python
class Solution(object):
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
        	return

        inorderTraversal(root.left)
   		# TODO: do work
        inorderTraversal(root.right)
```

#### 后序遍历：

```python
# 需要先进行递归，在进行记录结果（自底向下）
class Solution(object):
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
        	return

        postorderTraversal(root.left)
        postorderTraversal(root.right)
   		# TODO: do work
```

### 广度优先搜索：

用到队列（先进先出），处理每一层，将每一层节点入队。

```python
class Solution(object):
    def levelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: bool
        """
        if not root:
            return False

        qlist = [root]
        while len(qlist):
            n = len(qlist)
            for _ in range(n):
                node = qlist[0]
                index = index_map[node]
                qlist.pop(0)
                left_node = node.left
                right_node = node.right
                if left_node:
                    qlist.append(left_node)

                if right_node:
                    qlist.append(right_node)
                
                #TODO：do work

```

### Morris遍历：

需要空间复杂度为O（1）时，需要用这个遍历![](/算法/images/二叉树Morris遍历.png)

```cpp
class Solution {
public:
    vector<int> Morris(TreeNode *root) {
        vector<int> res;
        if (!root) return res;
        TreeNode *cur = root;
        TreeNode *mostRight = nullptr;

        while (cur) {
            if (!cur->left) {
                // 先序遍历的位置 2
                // 中序遍历的位置 2
                res.push_back(cur->val);
                cur = cur->right;
            } else {
                // 从左子树开始遍历
                mostRight = cur->left;
                while (mostRight->right && mostRight->right != cur) {
                    mostRight = mostRight->right;
                }

                if (mostRight->right == nullptr) {
                    // 先序遍历的位置 1
                    mostRight->right = cur;
                    cur = cur->left;
                } else {
                    // 中序遍历的位置 1
                    res.push_back(cur->val);
                    mostRight->right = nullptr;
                    cur = cur->right;
                }
            }
        }
        return res;
    }
};
```

### 知识点

+ 将树转换成一个数组的形式，那么会有这个公式：假设root的下标为index（下标从0开始），那么root的left下标为index*2 + 1，root的right下标为index*2 + 2
+ 完全二叉树的定义：**它是一棵空树或者它的叶子节点只除在最后两层，若最后一层不满则叶子节点只在最左侧。**
+ 对于完全二叉树而言：就有数组的大小（总节点个数-1）等于最大的下标
+ **满二叉树的层数为h，则总节点数为：2^h - 1.**
+ 二叉搜索树的特性是：当前节点的值大于左子树所有节点的值，当前节点的值小于右子树所有节点的值。（**优先考虑中序遍历LTR**，因为刚好L<T<R。再用一个值保存前一个节点）
+ 平衡二叉树（AVL Tree）：一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

### 类

```python
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    @classmethod
    def build(cls, val_list):
        node_list = list()
        n = len(val_list)
        for index in range(n):
            val = val_list[index]
            node = TreeNode(val)
            node_list.append(node)
        for index in range(n):
            left_index = index * 2 + 1
            right_index = index * 2 + 2
            node = node_list[index]
            if left_index < n:
                left_node = node_list[left_index]
                node.left = left_node
            if right_index < n:
                right_node = node_list[right_index]
                node.right = right_node
        return node_list[0]

    @staticmethod
    def maxDepth(root):
        if not root:
            return 0

        left_cnt = TreeNode.maxDepth(root.left) + 1
        right_cnt = TreeNode.maxDepth(root.right) + 1
        return max(left_cnt, right_cnt)

    @staticmethod
    def printf(root):
        # 空格的次数
        depth = TreeNode.maxDepth(root)
        queue_list = [root]
        while len(queue_list):
            print("\t" * depth),
            node_cnt = len(queue_list)  # 当前这一层node的个数
            for _ in range(node_cnt):
                node = queue_list[0]
                queue_list.pop(0)
                left_node = node.left
                right_node = node.right
                if left_node:
                    queue_list.append(left_node)
                if right_node:
                    queue_list.append(right_node)
                print(node.val),
                print("\t" * depth),
            depth -= 1
            print("\n"),
```

## 打印树

### 二叉树的层序遍历

+ 力扣102：[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

  ```
  给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
  
  二叉树：[3,9,20,null,null,15,7],
  返回其层序遍历结果：
  [
    [3],
    [9,20],
    [15,7]
  ]
  ```

+ 题解：

  + 首先根元素入队
  + 当队列不为空的时候
    - 求当前队列的长度 n (该层的节点个数)
    - 依次从队列中取 n 个元素进行拓展，每个元素得到其左节点和右节点。左右节点不为None则再加入队列中，然后进入下一次迭代

  ```cpp
  class Solution {
  public:
      vector<vector<int>> levelOrder(TreeNode* root) {
      vector<vector<int>> ans;
      if (!root) return ans;
      queue<TreeNode *> q;
      q.push(root);
      while (!q.empty()) {
        int n = q.size();
        vector<int> tmp;
        while (n--) {
          TreeNode *node = q.front();
          q.pop();
          tmp.push_back(node->val);
          if (node->left) q.push(node->left);
          if (node->right) q.push(node->right);
        }
        ans.push_back(tmp);
      }
      return ans;
      }
  };
  ```

### 二叉树的前序遍历

+ 力扣144：[二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

  ```
  给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
  
  输入：root = [1,null,2,3]
  输出：[1,2,3]
  ```

+ 题解：

  + 二叉树的前序遍历：输出根节点->左子树->右子树。（TLR）
  + 实现方式有两种：递归（已经在总结给出，较为常用），这里给出非递归
  + 根据上面的规律，我们可以用一个栈进行保存
  + 获取根节点，输出根节点的值
  + 获取根节点的左子树，右子树
  + 如果右子树不为None，则右子树先入栈（因为较后输出）
  + 如果左子树不为None，则左子树再入栈
  + 依次循环，结束条件是栈为空

  ```cpp
  class Solution {
  public:
      vector<int> preorderTraversal(TreeNode* root) {
      vector<int> ans;
      if (!root) return ans;
      stack<TreeNode *> stk;
      stk.push(root);
      while (!stk.empty()) {
        TreeNode *node = stk.top();
        stk.pop();
        ans.push_back(node->val);
        if (node->right) stk.push(node->right);
        if (node->left) stk.push(node->left);
      }
      return ans;
      }
  };
  ```

### 二叉树的后序遍历

+ 力扣145：[二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

  ```
  给定一个二叉树，返回它的 后序 遍历。
  
  输入: [1,null,2,3] 
  输出: [3,2,1]
  ```

+ 题解：

  + 二叉树的后序遍历：输出左子树->右子树->根节点。（LRT）
  + 我们可以看前序遍历（TLR）和后序遍历（LRT）很像，只是T放在前后问题
  + 那么我们可以看：TLR -> TRL -> LRT
  + 那是不是通过修改下前序遍历，左子树和右子树入栈的顺序得到TRL，然后再反转下结果就可以到

  ```cpp
  class Solution {
  public:
      vector<int> postorderTraversal(TreeNode* root) {
      vector<int> ans;
      if (!root) return ans;
      stack<TreeNode *> stk;
      stk.push(root);
      while (!stk.empty()) {
        TreeNode *node = stk.top();
        stk.pop();
        ans.push_back(node->val);
        if (node->left) stk.push(node->left);
        if (node->right) stk.push(node->right);
      }
      reverse(ans.begin(), ans.end());
      return ans;
      }
  };
  ```

### 二叉树的中序遍历

+ 力扣94：[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

  ```
  给定一个二叉树的根节点 root ，返回它的 中序 遍历。
  
  输入：root = [1,null,2,3]
  输出：[1,3,2]
  ```

+ 题解：[颜色标记法-一种通用且简明的树遍历方法](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/)

  + 使用颜色标记节点的状态，新节点为0，已访问的节点为1。
  + 如果遇到的节点为0，则将其标记为1，然后将其右子节点、自身、左子节点依次入栈。
  + 如果遇到的节点为1，则将节点的值输出。
  + 前序遍历和后序遍历都可以用该方法

  ```cpp
  class Solution {
  public:
      vector<int> inorderTraversal(TreeNode* root) {
      vector<int> ans;
      if (!root) return ans;
      stack<pair<TreeNode *, int>> stk;
      stk.push({root, 0});
      while (!stk.empty()) {
        pair<TreeNode *, int> node = stk.top();
        stk.pop();
        if (node.second == 0) {
          if (node.first->right) stk.push({node.first->right, 0});
          stk.push({node.first, 1});
          if (node.first->left) stk.push({node.first->left, 0});
        } else {
          ans.push_back(node.first->val);
        }
      }
      return ans;
      }
  };
  ```

## 层次遍历应用

### 二叉树的右视图

+ 力扣199：[二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

  ```
  给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
  
  输入: [1,2,3,null,5,null,4]
  输出: [1, 3, 4]
  ```

+ 题解：

  + 利用层次遍历
  + 每一层最后一个节点的值加入到结果

  ```cpp
  class Solution {
  public:
      vector<int> rightSideView(TreeNode* root) {
      vector<int> ans;
      if (!root) return ans;
      queue<TreeNode *> q;
      q.push(root);
      while (!q.empty()) {
        int n = q.size();
        TreeNode *node = nullptr;
        while (n--) {
          node = q.front();
          q.pop();
          if (node->left) q.push(node->left);
          if (node->right) q.push(node->right);
        }
        ans.push_back(node->val);
      }
      return ans;
      }
  };
  ```

## 树的特性

### 二叉树的完全性检验

+ 力扣958：[二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

  ```
  给定一个二叉树，确定它是否是一个完全二叉树。
  百度百科中对完全二叉树的定义如下：
  若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）
  
  输入：[1,2,3,4,5,6]
  输出：true
  解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
  
  输入：[1,2,3,4,5,null,7]
  输出：false
  解释：值为 7 的结点没有尽可能靠向左侧。
  ```

+ 题解：

  + 将树转换成一个数组的形式，那么会有这个公式：**假设root的下标为index（下标从0开始），那么root的left下标为index*2 + 1，root的right下标为index*2 + 2**
  + **对于完全二叉树而言：就有数组的大小（总节点个数-1）等于最大的下标**

  ```cpp
  class Solution {
  public:
      bool isCompleteTree(TreeNode* root) {
      if (!root) return true;
      // 保存当前节点，所在下标
      queue<pair<TreeNode *, int>> q;
      q.push({root, 0});
      int cnt = 0;
      while (!q.empty()) {
        int n = q.size();
        TreeNode *node = nullptr;
        while (n--) {
          pair<TreeNode *, int> node = q.front();
          q.pop();
          // 如果当前的下标值和总数不一样则认为不是完全二叉树
          if (node.second != cnt) return false;
          if (node.first->left) q.push({node.first->left, node.second * 2+1});
          if (node.first->right) q.push({node.first->right, node.second * 2 + 2});
          cnt++;
        }
      }
      return true;
      }
  };
  ```

### 完全二叉树的节点个数

+ 力扣222：[完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

  ```
  给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
  
  完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
  
  输入：root = [1,2,3,4,5,6]
  输出：6
  
  输入：root = []
  输出：0
  
  输入：root = [1]
  输出：1
  ```

+ 题解：[题解](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/c-san-chong-fang-fa-jie-jue-wan-quan-er-cha-shu-de/)

  + **这是一棵完全二叉树**：除最后一层外，其余层全部铺满；且最后一层向左停靠
  + 如果根节点的左子树深度等于右子树深度，则说明**左子树为满二叉树**（可以画图）
  + 如果根节点的左子树深度大于右子树深度，则说明**右子树为满二叉树**（可以画图）
  + 满二叉树的层数为h，则总节点数为：2^h - 1.（1 << depth - 1）
  + 那么可以得到一个公式（获得当前root总节点个数）：root = （1 << left_depth | right_depth - 1）+ fun(root.right | root.left)  + 1
    + 左子树（右子树）满二叉树的总节点数 + 递归右子树（左子树）总节点数 + 1（root节点）

  ```cpp
  class Solution {
  public:
    int getDepth(TreeNode *root) {
      int cnt = 0;
      while (root) {
        cnt++;
        root = root->left;
      }
      return cnt;
    }
    int countNodes(TreeNode *root) {
      if (!root) return 0;
      int left = getDepth(root->left);
      int right = getDepth(root->right);
  	// 根据完全二叉树的性质：
      // 如果左子树高度等于右子树高度。则左子树为满二叉树。
      // 如果左子树高度不等于右子树高度。则右子树为满二叉树。
      // 满二叉树的总结点数：2^h - 1 （深度从1开始计算）
      if (left == right)
        // 该root节点的个数等于：左子树满二叉树的总个数 + 递归右子树（非满二叉树） + 1（root节点）
        return countNodes(root->right) + (1 << left);
      else
        // 右子树是满二叉树
        return countNodes(root->left) + (1 << right);
    }
  };
  ```

## 前序遍历应用

### 二叉树的最小深度

+ 力扣111：[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

  ```python
  给定一个二叉树，找出其最小深度。
  最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
  
  输入：root = [3,9,20,null,null,15,7]
  输出：2
  
  输入：root = [2,null,3,null,4,null,5,null,6]
  输出：5
  ```

+ 题解：该问题实际就是问根节点到叶子的最短路径

  + 用一个值用于保存结果
  + 计算到叶子节点的层数（左右节点为None）
  + 保存最小值

  ```cpp
  class Solution {
    int ans = INT_MAX;
  
   public:
    void helper(TreeNode *root, int depth) {
      if (!root) return;
      if (!root->left && !root->right) {
        ans = min(ans, depth+1);
        return;
      }
      helper(root->left, depth + 1);
      helper(root->right, depth + 1);
    }
    int minDepth(TreeNode *root) {
      if (!root) return 0;
      helper(root, 0);
      return ans;
    }
  };
  ```

### 对称二叉树

+ 力扣101：[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

  ```
  给定一个二叉树，检查它是否是镜像对称的。
  
  例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
  ```

+ 题解：

  + 每个树的右子树都与另一个树的左子树镜像对称
  + 它们的两个根结点具有相同的值

  ```python
  class Solution(object):
      def isSymmetric(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.right) and check(pnode.right, qnode.left)
  
  
          if not root:
              return False
  
          return check(root.left, root.right)
  ```

### 相同树

+ 力扣100：[相同的树](https://leetcode-cn.com/problems/same-tree/)

  ```
  给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
  如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
  
  输入：p = [1,2,3], q = [1,2,3]
  输出：true
  
  输入：p = [1,2], q = [1,null,2]
  输出：false
  ```
  
+ 题解：这道题跟上面到对称二叉树查不到

  + 每个树的右（左）子树都与另一个树的右（左）子树相同
  + 它们的两个根结点具有相同的值

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          return check(p,q)
  ```

### 另一个树的子树

+ 力扣572：[另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

  ```
  给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
  
  输入：s = [3,4,5,1,2] t = [4,1,2]
  输出：true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
  
  输入：s = [3,4,5,1,2,null,null,null,null,0] t = [4,1,2]
  输出：false
  
  ```

+ 题解：这道题跟上面相同树一样

  + 结合上面的相同树，将s的每个节点当成root，进行比较

  ```python
  class Solution(object):
      def isSubtree(self, s, t):
          """
          :type s: TreeNode
          :type t: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          qlist = [s]
          while len(qlist):
              n = len(qlist)
              for index in range(n):
                  node = qlist[0]
                  qlist.pop(0)
                  if check(node, t):
                      return True
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
          return False
  		"""
  		深度搜索
  		# 遍历root节点，左节点，右节点
          if not s:
              return False
          return check(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
  		"""
  ```

### 同构树

+ 腾讯题：[同构树-TX](https://blog.csdn.net/weixin_43088751/article/details/104079228)

  ```
  简单来说，对于二叉树，如果一个树的孩子节点通过左右变换可以变成另外一个树，那么这两个树是同构的。
  ```

+ 题解：

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              # 同构树下面两种情况其中1中
              # 1.左子树等于左子树，右子树等于右子树 
              # 2.左子树等于右子树，左子树等于右子树
              return (check(pnode.left, qnode.left) and check(pnode.right, qnode.right)) or (check(pnode.left, qnode.right) and check(pnode.right, qnode.left))
  
          return check(p,q)
  ```

### 翻转二叉树

+ 力扣226：[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

  ```
  翻转一棵二叉树。
  
  输入：[4,2,7,1,3,6,9]
  输出：[4,7,2,9,6,3,1]
  ```

+ 题解：利用前序遍历（TLR）

  + 先遍历到root
  + 然后交换root的left和right（交换后下面的结构就已经变换了，可以画图）

  ```python
  class Solution(object):
      def invertTree(self, root):
          """
          :type root: TreeNode
          :rtype: TreeNode
          """
          if not root:
              return
  
          node = root.left
          root.left = root.right
          root.right = node
          self.invertTree(root.left)
          self.invertTree(root.right)
          return root
  ```

### 左叶子之和

+ 力扣404[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

  ```
  计算给定二叉树的所有左叶子之和。
  
  输入：[3,9,20,None,None,15,7]
  输出：24
  ```

+ 题解：

  + 判断一个节点的左节点是不是叶子节点，如果是则累加该节点的值

  ```cpp
  class Solution {
       int ans = 0;
  
  public:
    bool isLeaf(TreeNode *root) { return root && !root->left && !root->right; }
    int sumOfLeftLeaves(TreeNode *root) {
      if (!root) return ans;
      if (isLeaf(root->left)) {
        ans += root->left->val;
      }
      sumOfLeftLeaves(root->left);
      sumOfLeftLeaves(root->right);
      return ans;
    }
  };
  ```

## 中序遍历应用

### 验证二叉搜索树

+ 力扣98：[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

  ```
  给定一个二叉树，判断其是否是一个有效的二叉搜索树。
  假设一个二叉搜索树具有如下特征：
  节点的左子树只包含小于当前节点的数。
  节点的右子树只包含大于当前节点的数。
  所有左子树和右子树自身必须也是二叉搜索树。
  
  输入: [5,1,4,null,null,3,6]。
  输出：false
  ```

+ 题解：[中序遍历轻松拿下，🤷‍♀️必须秒懂！](https://leetcode-cn.com/problems/validate-binary-search-tree/solution/zhong-xu-bian-li-qing-song-na-xia-bi-xu-miao-dong-/)

  + 中序遍历
  + 因为二叉搜索树的特性是：当前节点的值大于左子树所有节点的值，当前节点的值小于右子树所有节点的值
  + 所以可以利用中序遍历：LTR => L < T < R

  ```cpp
  class Solution {
    TreeNode *preNode;
  
   public:
    bool isValidBST(TreeNode *root) {
      if (!root) return true;
      int left = isValidBST(root->left);
      if (preNode && preNode->val >= root->val) return false;
      preNode = root;
      int right = isValidBST(root->right);
      return left && right;
      }
  };
  ```

### 面试题 17.12. BiNode

+ 力扣：[面试题 17.12. BiNode](https://leetcode-cn.com/problems/binode-lcci/)

  ```
  二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。
  返回转换后的单向链表的头节点。
  
  输入： [4,2,5,1,3,null,6,0]
  输出： [0,null,1,null,2,null,3,null,4,null,5,null,6]
  ```

+ 题解：

  + 利用二叉搜索树的特性：L<T<R，使用中序遍历。再用一个节点（pre_node）保存前一个节点的值
  + 申请一个虚节点，作为头指针
  + pre_node < root 
  + root.left = None
  + pre_node.right = root
  + pre_node = root

  ```cpp
  class Solution {
      TreeNode *preNode = nullptr;
  public:
      void helper(TreeNode *head, TreeNode *root) {
          if (!root) return;
          helper(head, root->left);
          if (!preNode) head->right = root;
          else preNode->right = root;
          root->left = nullptr;
          preNode = root;
  
          helper(head, root->right);
      }
  
      TreeNode *convertBiNode(TreeNode *root) {
          TreeNode * head = new TreeNode(-1);
          helper(head, root);
          return head->right;
      }
  };
  ```

### 二叉搜索树的最小绝对差

+ 力扣530：[二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

  ```
  给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。
  
  输入：
     1
      \
       3
      /
     2
  输出：
  1
  解释：
  最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。
  ```

+ 题解：

  + 利用二叉搜索树的特性：L<T<R，使用中序遍历。再用一个节点保存前一个节点的值
  + 在做差值，保留最小值

  ```cpp
  class Solution {
      TreeNode* preNode = nullptr;
      int ans = INT32_MAX;
  public:
      int getMinimumDifference(TreeNode* root) {
          if (!root) return 0;
          getMinimumDifference(root->left);
          if (preNode) {
              ans = min(ans,abs(root->val-preNode->val));
          }
          preNode = root;
          getMinimumDifference(root->right);
          return ans;
      }
  };
  ```

## 后续遍历应用

### 二叉树最大深度

+ 力扣104：[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

  ```
  给定一个二叉树，找出其最大深度。
  二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
  说明: 叶子节点是指没有子节点的节点。
  
  给定二叉树 [3,9,20,null,null,15,7]，
  返回它的最大深度 3 。
  ```

+ 题解：深度遍优先搜索

  ```python
  class Solution:
      def maxDepth(self, root):
          if root is None: 
              return 0 
  
  		left_height = self.maxDepth(root.left) + 1 
  		right_height = self.maxDepth(root.right) + 1 
  		return max(left_height, right_height) 
  ```

### 平衡二叉树

+ 力扣110：[平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

  ```
  给定一个二叉树，判断它是否是高度平衡的二叉树。
  本题中，一棵高度平衡二叉树定义为：
  一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
  
  输入：root = [3,9,20,null,null,15,7]
  输出：true
  
  输入：root = [1,2,2,3,3,null,null,4,4]
  输出：false
  
  输入：root = []
  输出：true
  ```

+ 题解：

  + 后序遍历，自底向上
  + 计算每个节点的左节点层数和右节点层数
  + 差值大于1就不是平衡二叉树

  ```cpp
  class Solution {
    bool ans;
  
   public:
    int helper(TreeNode *root) {
      if (!root) return 0;
      int left = helper(root->left);
      int right = helper(root->right);
      ans = ( (abs(left - right) > 1 ? false : true) && ans);
      return max(left, right) + 1;
    }
    bool isBalanced(TreeNode *root) {
      if (!root) return true;
      ans=true;
      helper(root);
      return ans;
    }
  };
  ```

### 二叉树的直径

+ 力扣543：[二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

  ```
  给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
  注意：两结点之间的路径长度是以它们之间边的数目表示。
  
  输入：root = [1,2,3,4,5]
  输出：3  它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
  ```

+ 题解：[题解](https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/)

  + 对于该节点的左儿子向下遍历经过最多的节点数 LL （即以左儿子为根的子树的深度） 
  + 其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度）
  + 那么以该节点为起点的路径经过节点数的最大值即为 L+R+1
  + 记节点node 为起点的路径经过节点数的最大值为node_max，那么二叉树的直径就是所有节点node_max-1

  ```python
  class Solution(object):
      def diameterOfBinaryTree(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def maxDepth(root):
              if not root:
                  return 0
              # 左子树为根的深度
              left_depth = maxDepth(root.left)
              # 右子树为根的深度
              right_depth = maxDepth(root.right)
              # 该节点为根，其左右子树最深高度和，跟max_depth比较
              self.ans = max(self.ans, left_depth + right_depth + 1)
              # 返回该节点为根的最深高度
              return max(left_depth, right_depth) + 1
          if not root:
              return 0
          self.ans = 0
          maxDepth(root)
          return self.ans - 1 # 注意：两结点之间的路径长度是以它们之间边的数目表示。所以要深度-1
  ```

### 二叉树的坡度

+ 力扣563：[二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

  ```
  给定一个二叉树，计算 整个树 的坡度 。
  一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
  整个树 的坡度就是其所有节点的坡度之和。
  
  输入：root = [1,2,3]
  输出：1
  解释：
  节点 2 的坡度：|0-0| = 0（没有子节点）
  节点 3 的坡度：|0-0| = 0（没有子节点）
  节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）
  坡度总和：0 + 0 + 1 = 1
  
  输入：root = [4,2,9,3,5,null,7]
  输出：15
  解释：
  节点 3 的坡度：|0-0| = 0（没有子节点）
  节点 5 的坡度：|0-0| = 0（没有子节点）
  节点 7 的坡度：|0-0| = 0（没有子节点）
  节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）
  节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）
  ```

+ 题解：

  + 用于一个全局变量保存每个坡度的值
  + 递归函数的返回值：左子树的和+右子树的和+该节点的值（用于该节点的父节点来做差值）

  ```cpp
  class Solution {
    int ans = 0;
  
   public:
    int helper(TreeNode *root) {
      if (!root) return 0;
      int left = helper(root->left);
      int right = helper(root->right);
      ans += abs(left - right);
      return left + right + root->val;
    }
    int findTilt(TreeNode *root) {
      helper(root);
      return ans;
    }
  };
  ```

## 最近公共祖先

### 二叉树的最近公共祖先

+ 力扣236：[二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

  ```
  给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
  百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
  
  输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
  输出：3
  解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
  
  输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
  输出：5
  解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
  
  输入：root = [1,2], p = 1, q = 2
  输出：1
  ```
  
+ 题解：[二叉树的最近公共祖先（后序遍历 DFS ，清晰图解）](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)

  + 若 root是p,q的最近公共祖先 ，则只可能为以下情况之一：
  + p 和 q 在 root的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
  + p = root ，且q在root的左或右子树中；
  + q = root ，且p在root的左或右子树中；

  ```python
  class Solution(object):
      def lowestCommonAncestor(self, root, p, q):
          """
          :type root: TreeNode
          :type p: TreeNode
          :type q: TreeNode
          :rtype: TreeNode
          """
          if not root:
              return None
              
          if root == p or root == q: 
              return root
              
          left_node = self.lowestCommonAncestor(root.left, p , q)
          right_node = self.lowestCommonAncestor(root.right, p , q)
          
          # 当left和right同时不为空 ：说明p,q 分列在root的异侧（分别在左/右子树），因此root为最近公共祖先，返回 root；
          if left_node and right_node: 
              return root
  
  		# 当left和right同时为空 ：说明 root 的左/右子树中都不包含p,q，返回 null
          if not left_node and not right_node:
              return None
              
          # 当left为空，right不为空：p,q 都不在root的左子树中，直接返回right 。具体可分为两种情况：
          # p,q其中一个在root的右子树中，此时right指向p（假设为p）
          # p,q两节点都在root的右子树中，此时right指向最近公共祖先节点 
          if not left_node and right_node:
              return right_node
          # 同上
          if not right_node and left_node:
              return left_node
  ```

### 二叉搜索树的最近公共祖先

+ [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

  ```
  给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
  百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
  
  输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
  输出: 6 
  解释: 节点 2 和节点 8 的最近公共祖先是 6。
  
  输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
  输出: 2
  解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
  ```

+ 题解：

  + 利用二叉搜索树的性，左子树一定比根节点小，右子树一定比根节点打
  + 那么有三种情况：
    + p.val > root.val and q.val > root.val：都比root大，则公共祖先则再root的右子树上
    + p.val < root.val and q.val < root.val：都比root小，则公共祖先则再root的左子树上
    + (p.val < root.val and p.val > root.val) or (p.val > root.val and p.val < root.val)：在root节点的左右边，则公共祖先则是root节点

  ```python
  class Solution(object):
      def lowestCommonAncestor(self, root, p, q):
          """
          :type root: TreeNode
          :type p: TreeNode
          :type q: TreeNode
          :rtype: TreeNode
          """
          def helper(root,p,q):
              if not root:
                  return None
              if root.val > p.val and root.val > q.val:
                  return helper(root.left, p, q)
              elif root.val < q.val and root.val < p.val:
                  return helper(root.right, p, q)
              else:
                  return root
          return helper(root, p, q)
  ```

## 路径问题

### 路径总和

+ 力扣112：[ 路径总和](https://leetcode-cn.com/problems/path-sum/)

  ```
  给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 
  叶子节点 是指没有子节点的节点。
  
  输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
  输出：true
  
  输入：root = [1,2,3], targetSum = 5
  输出：false
  
  输入：root = [1,2], targetSum = 0
  输出：false
  ```

+ 题解：用前序遍历

  + 每次都减去加当前节点的值
  + 当递归到根节点的时候，判断当前节点的值是不是和目标值一样

  ```python
  # Definition for a binary tree node.
  # class TreeNode(object):
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution(object):
      def hasPathSum(self, root, targetSum):
          """
          :type root: TreeNode
          :type targetSum: int
          :rtype: bool
          """
  		if not root:
              return False
          if not root.left and not root.right:
              return targetSum == root.val
          return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
  ```

### 二叉树的所有路径

+ 力扣257：[二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

  ```
  给定一个二叉树，返回所有从根节点到叶子节点的路径。
  说明: 叶子节点是指没有子节点的节点。
  
  输出: ["1->2->5", "1->3"]
  解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
  ```

+ 题解：前序遍历

  ```cpp
  class Solution {
    vector<string> ans;
  
   public:
    void binaryTreePaths(TreeNode* root, string s) {
      if (!root) return;
      if (!root->left && !root->right) {
        s += to_string(root->val);
        ans.push_back(s);
        return;
      }
      s += to_string(root->val) + "->";
      binaryTreePaths(root->left, s);
      binaryTreePaths(root->right, s);
    }
    vector<string> binaryTreePaths(TreeNode* root) {
      binaryTreePaths(root, "");
      return ans;
    }
  };
  ```


### 求根到叶子节点数字之和

+ 力扣129：[求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

  ```
  给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。
  例如，从根到叶子节点路径 1->2->3 代表数字 123。
  计算从根到叶子节点生成的所有数字之和。
  说明: 叶子节点是指没有子节点的节点。
  
  输入: [4,9,0,5,1]
  输出: 1026
  解释:
  从根到叶子节点路径 4->9->5 代表数字 495.
  从根到叶子节点路径 4->9->1 代表数字 491.
  从根到叶子节点路径 4->0 代表数字 40.
  因此，数字总和 = 495 + 491 + 40 = 1026.
  ```

+ 题解：跟257题一样用前序遍历

  ```python
  class Solution(object):
      def sumNumbers(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          self.ans = 0
          def calc(root, sumNum):
              if not root:
                  return
              if not root.left and not root.right:
                  sumNum = sumNum*10 + root.val
                  self.ans += sumNum
                  return
              sumNum = sumNum*10 + root.val
              calc(root.left, sumNum)
              calc(root.right, sumNum)
          if not root:
              return 0
          calc(root, 0)
          return self.ans
  ```

### 路径总和II

+ 力扣113：[路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

  ```
  给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。
  说明: 叶子节点是指没有子节点的节点。
  
  输入：r = [5,4,8,11,None,13,4,7,2,None,None,None,None,5,1] sum = 22，
  输出：
  [
     [5,4,11,2],
     [5,8,4,5]
  ]
  ```

+ 题解：和129题一样

  ```python
  class Solution(object):
      def pathSum(self, root, targetSum):
          """
          :type root: TreeNode
          :type targetSum: int
          :rtype: List[List[int]]
          """
          self.ans = []
          def calc(root, targetSum, val_list):
              if not root:
                  return
              val_list.append(root.val)
              if not root.left and not root.right:
                  sumNum = sum(val_list)
                  if sumNum == targetSum:
                      self.ans.append(copy.deepcopy(val_list))
                  val_list.pop()
                  return
              calc(root.left, targetSum, val_list)
              calc(root.right, targetSum, val_list)
              val_list.pop() # 剔除当前节点，因为遍历完了
          if not root:
              return []
          calc(root, targetSum, [])
          return self.ans
  ```

### 二叉树中最大路径和（字节）

+ 力扣124：[ 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

  ```
  路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
  路径和 是路径中各节点值的总和。
  给你一个二叉树的根节点 root ，返回其 最大路径和 。
  
  ```

+ 题解：[二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-leetcode-/)

  + 二叉树 abc，a 是根结点（递归中的 root），bc 是左右子结点（代表其递归后的最优解）。最大的路径，可能的路径情况：
    + b + a + c。
    + b + a + a 的父结点。
    + a + c + a 的父结点。

  ```python
  class Solution(object):
      def maxPathSum(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          self.ans = float('-inf')
          def helper(root):
              if not root:
                  return 0
  
              # 当左右子树的最大值都小于0，则左右子树以下的节点都不选择
              left = max(helper(root.left), 0)
              right = max(helper(root.right),0)
  
              left_val = left + root.val
              right_val = right + root.val
              sum_val = left + right + root.val
              self.ans = max(self.ans, sum_val)
              return max(left_val, right_val)
  
          if not root:
              return 0
          helper(root)
          return self.ans
  ```

### 二叉树搜索树迭代器（字节）

+ 力扣173：[二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

+ 题解：

  + 可以用中序遍历的方式是二叉搜索树转成有序的节点
  + 用一个队列保存排序后的二叉树的结果
  + 然后直接操作队列

  ```python
  class BSTIterator(object):
  
      def __init__(self, root):
          """
          :type root: TreeNode
          """
          self._node_list = []
          self._inorder(root)
  
      def next(self):
          """
          :rtype: int
          """
          return self._node_list.pop(0)
  
  
      def hasNext(self):
          """
          :rtype: bool
          """
          return (len(self._node_list) != 0)
  
      def _inorder(self, root):
          if not root:
              return 
          self._inorder(root.left)
          self._node_list.append(root.val)
          self._inorder(root.right)
  ```

## 构造树

### 从前序与中序遍历序列构造二叉树

+ 力扣：[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

  ```
  根据一棵树的前序遍历与中序遍历构造二叉树。
  注意:
  你可以假设树中没有重复的元素。
  
  例如，给出
  前序遍历 preorder = [3,9,20,15,7]
  中序遍历 inorder = [9,3,15,20,7]
  返回如下的二叉树：
      3
     / \
    9  20
      /  \
     15   7
  ```

+ 题解：[从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/)（看视频+画图）

  + 前序遍历是：TLR
  + 中序遍历是：LTR
  + 从前序遍历中的得到根节点（preLeft）。得到根节点后，就可以知道根节点中序遍历的位置（inIndex）
  + 根节点的在中序遍历的位置知道后就可以得到，对应左子树的范围（【inLeft,inIndex-1】），右子树的范围（【inIndex+1,inRight】）
  + 因为中序遍历和前序遍历的左子树长度都一样，右子树长度也一样。那么可以得到左子树的长度： inIndex - inLeft = x - preLeft。可以得到 x =  inIndex - inLeft  + preLeft。
  + 从上面可以得到左子树的长度为len（【inLeft,inIndex-1】）,那么可以得到前序遍历中左子树的范围：（【preLeft+ 1 , inIndex- inLeft+ preLeft】）
  + 从上面可以得到右子树的长度为len（【inIndex+1,inright】）,那么可以得到前序遍历中右子树的范围：（【inIndex- inLeft+ preLeft+ 1 , preRight】）
  + 得到前中序中左子树和右子树的范围后可以继续递归：参数根据上面的来
    + node.left = f(*preorder*, *inorder_index*, *pre_left*, *pre_right*, *in_left*, *in_right*)
    + node.right= f(*preorder*, *inorder_index*, *pre_left*, *pre_right*, *in_left*, *in_right*)

  ```python
  class Solution(object):
      def buildTree(self, preorder, inorder):
          """
          :type preorder: List[int]
          :type inorder: List[int]
          :rtype: TreeNode
          """
          def f(preorder, inorder_index, pre_left, pre_right, in_left, in_right):
              if pre_left > pre_right or in_left > in_right:
                  return None
              val = preorder[pre_left]  # 前序遍历第一个节点是头结点
              node = TreeNode(val)
              in_index = inorder_index[val]  # 找到这个头结点在中序遍历中的位置
  
              # 得到中序遍历中头结点的下标后（画图）
              # 得到左子树的范围分别是  [pre_left + 1 , in_index - in_left + pre_left]（前序的）
              # 得到左子树的范围分别是  [in_left , in_index - 1]（中序的）
              node.left = f(preorder, inorder_index, pre_left + 1,
                            in_index - in_left + pre_left, in_left, in_index - 1)
  
              # 得到右子树的范围分别是  [in_index - in_left + pre_left + 1 , pre_right]（前序的）
              # 得到右子树的范围分别是  [in_index + 1 , in_right]（中序的）
              node.right = f(preorder, inorder_index, in_index - in_left + pre_left + 1,
                             pre_right, in_index + 1, in_right)
              return node
  
  
          preorder_len = len(preorder)
          inorder_len = len(inorder)
          if preorder_len != inorder_len:
              return None
  
          inorder_index = dict()
          # 保存中序中各个元素的下标
          for index in range(inorder_len):
              inorder_index[inorder[index]] = index
          return f(preorder, inorder_index, 0, preorder_len - 1, 0, inorder_len - 1)
  ```

### 从中序与后序遍历序列构造二叉树

+ 力扣106：[从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

  ```
  根据一棵树的中序遍历与后序遍历构造二叉树。
  注意:
  你可以假设树中没有重复的元素。
  
  例如，给出
  中序遍历 inorder = [9,3,15,20,7]
  后序遍历 postorder = [9,15,7,20,3]
  返回如下的二叉树：
      3
     / \
    9  20
      /  \
     15   7
  ```

+ 题解：跟上一道从前序与中序遍历序列构造二叉树思路差不多。就是要注意

  + 中序遍历：L T R
  + 后序遍历：L R T
  + 在计算中间值是要用中序遍历的 R - T == 后序遍历的 T - R

  ```python
  class Solution(object):
      def buildTree(self, inorder, postorder):
          """
          :type inorder: List[int]
          :type postorder: List[int]
          :rtype: TreeNode
          """
          def f(postorder, inorder_index, post_left, post_right, in_left, in_right):
              if post_left > post_right or in_left > in_right:
                  return None
              val = postorder[post_right]
              node = TreeNode(val)
              in_index = inorder_index[val]
  
              # 左子树
              node.left = f(postorder, inorder_index, post_left,
                          post_right - in_right + in_index - 1, in_left, in_index - 1)
  			# 右子树
              node.right = f(postorder, inorder_index, post_right - in_right + in_index,
                          post_right - 1, in_index + 1, in_right)
              return node
  
          postorder_len = len(postorder)
          inorder_len = len(inorder)
          if postorder_len != inorder_len:
              return None
  
          inorder_index = dict()
          # 保存中序中各个元素的下标
          for index in range(inorder_len):
              inorder_index[inorder[index]] = index
          return f(postorder, inorder_index, 0, postorder_len - 1, 0,
                  inorder_len - 1)
  ```


### 剑指 Offer 37. 序列化二叉树

+ 力扣：[剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

  ```
  请实现两个函数，分别用来序列化和反序列化二叉树。
  
  你需要设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。
  
  提示：输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。
  
  
  输入：root = [1,2,3,null,null,4,5]
  输出：[1,2,3,null,null,4,5]
  ```

+ 题解：[ 面试题37. 序列化二叉树（层序遍历 BFS ，清晰图解）](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/solution/mian-shi-ti-37-xu-lie-hua-er-cha-shu-ceng-xu-bian-/)

  + 采用前序遍历的方法
  + 序列化：前序遍历的结果转成字符串
  + 反序列：使用序列化得到的前序遍历的结果进行复原
    + 将结果拆解成单个元素放到队列
    + 然后再用前序遍历的方式一个一个将队列元素拿出来，拼接在一起
  
  
  ```python
  class Codec {
  public:
      string serialize(TreeNode *root) {
          if (!root) return "null,";
          string val;
          val += to_string(root->val) + ",";
          val += serialize(root->left);
          val += serialize(root->right);
          return val;
      }
  
      // Decodes your encoded data to tree.
      TreeNode *deserialize(string data) {
          queue<string> vecs = splitString(data);
          return helper(vecs);
      }
  
      TreeNode *helper(queue<string> &vecs) {
          if (vecs.empty()) return nullptr;
          string ch = vecs.front();
          vecs.pop();
          if (ch == "null") return nullptr;
          TreeNode *node = new TreeNode(atoi(ch.c_str()));
          node->left = helper(vecs);
          node->right = helper(vecs);
          return node;
      }
  
      queue<string> splitString(string data) {
          queue<string> res;
          int start = 0, end = 0;
          end = data.find(",");
          while (end != string::npos) {
              res.push(data.substr(start, end - start));
              start = end + 1;
              end = data.find(",", start);
          }
          if (start != data.size()) res.push(data.substr(start));
          return res;
      }
  };
  ```

# 剑指offer

### 剑指 Offer 27. 二叉树的镜像

+ 力扣：[剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

  ```
  请完成一个函数，输入一个二叉树，该函数输出它的镜像。
  
  例如输入：
  
       4
     /   \
    2     7
   / \   / \
  1   3 6   9
  镜像输出：
  
       4
     /   \
    7     2
   / \   / \
  9   6 3   1
  
  输入：root = [4,2,7,1,3,6,9]
  输出：[4,7,2,9,6,3,1]
  ```

+ 题解：

  + 直接交换左右节点

  ```c++
  class Solution {
  public:
      TreeNode* mirrorTree(TreeNode* root) {
          if (!root) return nullptr;
          TreeNode* tmp = root->left;
          root->left = root->right;
          root->right = tmp;
          this->mirrorTree(root->left);
          this->mirrorTree(root->right);
          return root;
      }
  };
  ```

### 剑指 Offer 28. 对称的二叉树

+ 力扣28：[剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

  ```
  请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。
  
  例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
      1
     / \
    2   2
   / \ / \
  3  4 4  3
  
  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
      1
     / \
    2   2
     \   \
     3    3
  
  输入：root = [1,2,2,3,4,4,3]
  输出：true
  
  输入：root = [1,2,2,null,3,null,3]
  输出：false
  ```

+ 题解：

  + 判断左子树和右子树的val是不是一样
  + 然后用左子树的左子树跟右子树的右子树比较，左子树的右子树和右子树的左子树比较

  ```c++
  class Solution {
  public:
    bool check(TreeNode* left_node, TreeNode* right_node) {
      if (!left_node && !right_node) return true;
      if (!left_node && right_node) return false;
      if (left_node && !right_node) return false;
      if (left_node->val != right_node->val) return false;
      return this->check(left_node->right, right_node->left) &&
             this->check(left_node->left, right_node->right);
    }
    bool isSymmetric(TreeNode* root) {
      if (!root) return true;
      return this->check(root->left, root->right);
    }
  };
  ```

### 剑指 Offer 32 - I. 从上到下打印二叉树

+ 力扣：[剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

  ```
  从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。
  给定二叉树: [3,9,20,null,null,15,7],
      3
     / \
    9  20
      /  \
     15   7
  返回：
  [3,9,20,15,7]
  ```

+ 题解：

  + 使用队列先进先出

  ```c++
  class Solution {
  public:
      vector<int> levelOrder(TreeNode* root) {
          vector<int> v;
          if (!root) return v;
          queue<TreeNode*> q;
          q.push(root);
          while (!q.empty()) {
              TreeNode* node = q.front();
              q.pop();
              v.push_back(node->val);
              if (node->left) q.push(node->left);
              if (node->right) q.push(node->right);
          }
          return v;
  
      }
  };
  ```

### 剑指 Offer 32 - II. 从上到下打印二叉树 II

+ 力扣：[剑指 Offer 32 - II. 从上到下打印二叉树 II](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/)

  ```
  从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
  例如:
  给定二叉树: [3,9,20,null,null,15,7],
  
      3
     / \
    9  20
      /  \
     15   7
  返回其层次遍历结果：
  
  [
    [3],
    [9,20],
    [15,7]
  ]
  ```

+ 题解：

  + 使用队列，先进先出
  + 然后用size记录当前层数的个数，并且遍历size次

  ```C++
  class Solution {
  public:
      vector<vector<int>> levelOrder(TreeNode* root) {
          vector<vector<int>> ret;
          if (!root) return ret;
          queue<TreeNode*> q;
          q.push(root);
          while (!q.empty()) {
              int size = q.size();
              vector<int> v;
              while (size) {
                  TreeNode* node = q.front();
                  q.pop();
                  v.push_back(node->val);
                  if (node->left) q.push(node->left);
                  if (node->right) q.push(node->right);
                  size--;
              }
              ret.push_back(v);
          }
          return ret;
      }
  };
  ```

### 剑指 Offer 32 - III. 从上到下打印二叉树 III

+ 力扣：[剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

  ```
  请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。
  例如:
  给定二叉树: [3,9,20,null,null,15,7],
  
      3
     / \
    9  20
      /  \
     15   7
  返回其层次遍历结果：
  
  [
    [3],
    [20,9],
    [15,7]
  ]
  ```

+ 题解：

  + 跟上面一样，只是需要判断层数然后翻转对应层数的结果

  ```c++
  class Solution {
  public:
      vector<vector<int>> levelOrder(TreeNode* root) {
          vector<vector<int>> ret;
          if (!root) return ret;
          queue<TreeNode*> q;
          q.push(root);
          while (!q.empty()) {
              int size = q.size();
              vector<int> v;
              while (size) {
                  TreeNode* node = q.front();
                  q.pop();
                  v.push_back(node->val);
                  if (node->left) q.push(node->left);
                  if (node->right) q.push(node->right);
                  size--;
              }
              if (ret.size() % 2 == 1) reverse(v.begin(), v.end());
              ret.push_back(v);
          }
          return ret;
      }
  };
  ```

### 剑指 Offer 54. 二叉搜索树的第k大节点

+ 力扣：[剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

  ```
  给定一棵二叉搜索树，请找出其中第k大的节点。
  输入: root = [3,1,4,null,2], k = 1
     3
    / \
   1   4
    \
     2
  输出: 4
  
  输入: root = [5,3,6,2,4,null,null,1], k = 3
         5
        / \
       3   6
      / \
     2   4
    /
   1
  输出: 4
  ```

+ 题解：

  + 二叉树的性质就是中序遍历是有序的（从小到大），所以利用中序遍历，
  + 然后因为是最大的值，所有反过来遍历可以得到从大到小
  + 当k==0的时候，就是对应的值。

  ```c++
  class Solution {
    int ret;
    int k;
  
   public:
    void dfs(TreeNode* root) {
      if (!root) return;
      dfs(root->right);
      this->k--;
      if (this->k == 0) ret = root->val;
      dfs(root->left);
    }
  
    int kthLargest(TreeNode* root, int k) {
      this->k = k;
      dfs(root);
      return ret;
    }
  };
  ```

### 剑指 Offer 55 - I. 二叉树的深度

+ 力扣：[剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

  ```
  输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。
  例如：
  
  给定二叉树 [3,9,20,null,null,15,7]，
  
      3
     / \
    9  20
      /  \
     15   7
  返回它的最大深度 3 。
  ```

+ 题解：

  ```c++
  class Solution {
  public:
      int maxDepth(TreeNode* root) {
          if (!root) return 0;
          return max(this->maxDepth(root->left) + 1, this->maxDepth(root->right) + 1);
      }
  };
  ```


### 剑指 Offer 55 - II. 平衡二叉树

+ 力扣：[剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

  ```
  输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。
  给定二叉树 [3,9,20,null,null,15,7]
  
      3
     / \
    9  20
      /  \
     15   7
  返回 true 。
  
  给定二叉树 [1,2,2,3,3,null,null,4,4]
         1
        / \
       2   2
      / \
     3   3
    / \
   4   4
  返回 false 。
  ```

+ 题解：

  + 自底向上，判断当前节点的左右子树差
  + 用一个变量保存结果

  ```c++
  class Solution {
    bool ans;
  
   public:
    int dfs(TreeNode* root) {
      if (!root) return 0;
      if (!this->ans) return 0;
      int left_height = this->dfs(root->left) + 1;
      int right_height = this->dfs(root->right) + 1;
      if (abs(left_height - right_height) > 1) this->ans = false;
      return max(left_height, right_height);
    }
    bool isBalanced(TreeNode* root) {
      this->ans = true;
      this->dfs(root);
      return this->ans;
    }
  };
  ```

### 剑指 Offer 68 - I. 二叉搜索树的最近公共祖先

+ 力扣：[剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

  ```
  给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
  
  百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
  
  输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
  输出: 6 
  解释: 节点 2 和节点 8 的最近公共祖先是 6。
  
  输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
  输出: 2
  解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。。
  ```

+ 题解：

  + 利用二叉搜索树的性，左子树一定比根节点小，右子树一定比根节点打
  + 那么有三种情况：
    + p.val > root.val and q.val > root.val：都比root大，则公共祖先则再root的右子树上
    + p.val < root.val and q.val < root.val：都比root小，则公共祖先则再root的左子树上
    + (p.val < root.val and p.val > root.val) or (p.val > root.val and p.val < root.val)：在root节点的左右边，则公共祖先则是root节点

  ```c++
  class Solution {
   public:
  
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
      if (!root || !p || !q) return nullptr;
      if (root->val > p->val && root->val > q->val)
        return this->lowestCommonAncestor(root->left, p, q);
      else if (root->val < p->val && root->val < q->val)
        return this->lowestCommonAncestor(root->right, p, q);
      else
        return root;
    }
  };
  ```

### 剑指 Offer 68 - II. 二叉树的最近公共祖先

+ 力扣：[剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

  ```
  给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
  百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
  
  输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
  输出：3
  解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
  
  输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
  输出：5
  解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
  
  输入：root = [1,2], p = 1, q = 2
  输出：1
  ```

+ 题解：

  + 若 root是p,q的最近公共祖先 ，则只可能为以下情况之一：
  + p 和 q 在 root的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
  + p = root ，且q在root的左或右子树中；
  + q = root ，且p在root的左或右子树中；

  ```c++
  class Solution {
  public:
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          if (!root) return nullptr;
          if (root == p || root == q) return root;
          TreeNode* left_node = this->lowestCommonAncestor(root->left, p, q);
          TreeNode* right_node = this->lowestCommonAncestor(root->right, p, q);
          //当left和right同时不为空 ：说明p,q 分列在root的异侧（分别在左/右子树），因此root为最近公共祖先，返回 root；
          if (left_node && right_node) return root;
          // 当left为空，right不为空：p,q 都不在root的左子树中，直接返回right 。具体可分为两种情况：
         // p,q其中一个在root的右子树中，此时right指向p（假设为p）
          // p,q两节点都在root的右子树中，此时right指向最近公共祖先节点 
          if (right_node && !left_node) return right_node;
          // 同上
          if (left_node && !right_node) return left_node;
          return nullptr;    
      }
  };
  ```

### 面试题34. 二叉树中和为某一值的路径

+ 力扣：[面试题34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

  ```c++
  输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。
  
  示例:
  给定如下二叉树，以及目标和 target = 22，
  
                5
               / \
              4   8
             /   / \
            11  13  4
           /  \    / \
          7    2  5   1
  返回:
  
  [
     [5,4,11,2],
     [5,8,4,5]
  ]
  ```

+ 题解：

  ```c++
  class Solution {
  public:
    vector<vector<int>> ans;
  
   public:
    void helper(TreeNode* root, int target, vector<int> v) {
      if (!root) return;
      v.push_back(root->val);
      if (!root->left && !root->right) {
        if (target == root->val) ans.push_back(v);
        return;
      }
  
      this->helper(root->left, target - root->val, v);
      this->helper(root->right, target - root->val, v);
      v.pop_back();
    }
    vector<vector<int>> pathSum(TreeNode* root, int target) {
      if (!root) return ans;
      vector<int> v;
      helper(root, target, v);
      return ans;
    }
  };
  ```

### 剑指 Offer 26. 树的子结构

+ 力扣：[剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

  ```
  输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)
  
  B是A的子结构， 即 A中有出现和B相同的结构和节点值。
  
  例如:
  给定的树 A:
  
       3
      / \
     4   5
    / \
   1   2
  给定的树 B：
  
     4 
    /
   1
  返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。
  ```

+ 题解：

  + 用一个递归判断是不是相同结构
  + 用一个递归遍历root的所有节点

  ```c++
  class Solution {
  public:
    bool helper(TreeNode* root, TreeNode* node) {
      if (!node) return true;
      if (!root) return false;
      if (root->val != node->val) return false;
      return this->helper(root->left, node->left) &&
             this->helper(root->right, node->right);
    }
    bool isSubStructure(TreeNode* A, TreeNode* B) {
      if (!B) return false;
      if (!A) return false;
      bool ans = helper(A, B);
      return ans || this->isSubStructure(A->left, B) ||
             this->isSubStructure(A->right, B);
    }
  };
  ```

### 剑指 Offer 07. 重建二叉树

+ 力扣：[剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

  ```
  输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
  
  前序遍历 preorder = [3,9,20,15,7]
  中序遍历 inorder = [9,3,15,20,7]
  返回如下的二叉树：
  
      3
     / \
    9  20
      /  \
     15   7
  ```

+ 题解：

  + 前序遍历是：TLR
  + 中序遍历是：LTR
  + 从前序遍历中的得到根节点（preLeft）。得到根节点后，就可以知道根节点中序遍历的位置（inIndex）
  + 根节点的在中序遍历的位置知道后就可以得到，对应左子树的范围（【inLeft,inIndex-1】），右子树的范围（【inIndex+1,inRight】）
  + 因为中序遍历和前序遍历的左子树长度都一样，右子树长度也一样。那么可以得到左子树的长度： inIndex - inLeft = x - preLeft。可以得到 x =  inIndex - inLeft  + preLeft。
  + 从上面可以得到左子树的长度为len（【inLeft,inIndex-1】）,那么可以得到前序遍历中左子树的范围：（【preLeft+ 1 , inIndex- inLeft+ preLeft】）
  + 从上面可以得到右子树的长度为len（【inIndex+1,inright】）,那么可以得到前序遍历中右子树的范围：（【inIndex- inLeft+ preLeft+ 1 , preRight】）
  + 得到前中序中左子树和右子树的范围后可以继续递归：参数根据上面的来
    + node.left = f(*preorder*, *inorder_index*, *pre_left*, *pre_right*, *in_left*, *in_right*)
    + node.right= f(*preorder*, *inorder_index*, *pre_left*, *pre_right*, *in_left*, *in_right*)

  ```c++
  class Solution {
    map<int, int> in_map;
  
   public:
    TreeNode* helper(vector<int>& preorder, int pre_left, int pre_right,
                     vector<int>& inorder, int in_left, int in_right) {
      if (pre_left > pre_right || in_left > in_right) return nullptr;
      int index = in_map[preorder[pre_left]];
      TreeNode* node = new TreeNode(preorder[pre_left]);
      node->left = helper(preorder, pre_left + 1, index - in_left + pre_left,
                          inorder, in_left, index - 1);
      node->right = helper(preorder, index - in_left + pre_left + 1, pre_right,
                           inorder, index + 1, in_right);
      return node;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
      int prelen = preorder.size();
      int inlen = inorder.size();
      if (prelen != inlen) return nullptr;
      for (int idx = 0; idx < inlen; ++idx) in_map[inorder[idx]] = idx;
      return helper(preorder, 0, prelen - 1, inorder, 0, inlen - 1);
    }
  };
  ```

  
