### æ€»ç»“

+ æ·±åº¦ä¼˜å…ˆæœç´¢ï¼šé€’å½’

  + å…ˆåºéå†ï¼š

    ```python
    # éœ€è¦å…ˆè®°å½•ç»“æœï¼Œåœ¨è¿›è¡Œé€’å½’ï¼ˆè‡ªé¡¶å‘ä¸‹ï¼‰
    class Solution(object):
        def preorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    		# TODO: do work
            preorderTraversal(root.left)
            preorderTraversal(root.right)
    ```

  + ä¸­åºéå†ï¼š

    ```python
    class Solution(object):
        def inorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    
            inorderTraversal(root.left)
       		# TODO: do work
            inorderTraversal(root.right)
    ```

  + ååºéå†ï¼š

    ```python
    # éœ€è¦å…ˆè¿›è¡Œé€’å½’ï¼Œåœ¨è¿›è¡Œè®°å½•ç»“æœï¼ˆè‡ªåº•å‘ä¸‹ï¼‰
    class Solution(object):
        def postorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    
            postorderTraversal(root.left)
            postorderTraversal(root.right)
       		# TODO: do work
    ```

+ å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼šç”¨åˆ°é˜Ÿåˆ—ï¼ˆå…ˆè¿›å…ˆå‡ºï¼‰ï¼Œå¤„ç†æ¯ä¸€å±‚ï¼Œå°†æ¯ä¸€å±‚èŠ‚ç‚¹å…¥é˜Ÿã€‚

  ```python
  class Solution(object):
      def levelOrder(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          if not root:
              return False
  
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              for _ in range(n):
                  node = qlist[0]
                  index = index_map[node]
                  qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
  
                  if right_node:
                      qlist.append(right_node)
                  
                  #TODOï¼šdo work
  
  ```

+ å°†æ ‘è½¬æ¢æˆä¸€ä¸ªæ•°ç»„çš„å½¢å¼ï¼Œé‚£ä¹ˆä¼šæœ‰è¿™ä¸ªå…¬å¼ï¼šå‡è®¾rootçš„ä¸‹æ ‡ä¸ºindexï¼ˆä¸‹æ ‡ä»0å¼€å§‹ï¼‰ï¼Œé‚£ä¹ˆrootçš„leftä¸‹æ ‡ä¸ºindex*2 + 1ï¼Œrootçš„rightä¸‹æ ‡ä¸ºindex*2 + 2

+ å®Œå…¨äºŒå‰æ ‘çš„å®šä¹‰ï¼š**å®ƒæ˜¯ä¸€æ£µç©ºæ ‘æˆ–è€…å®ƒçš„å¶å­èŠ‚ç‚¹åªå‡ºåœ¨æœ€åä¸¤å±‚ï¼Œè‹¥æœ€åä¸€å±‚ä¸æ»¡åˆ™å¶å­èŠ‚ç‚¹åªåœ¨æœ€å·¦ä¾§ã€‚**

+ å¯¹äºå®Œå…¨äºŒå‰æ ‘è€Œè¨€ï¼šå°±æœ‰æ•°ç»„çš„å¤§å°ï¼ˆæ€»èŠ‚ç‚¹ä¸ªæ•°-1ï¼‰ç­‰äºæœ€å¤§çš„ä¸‹æ ‡

+ **æ»¡äºŒå‰æ ‘çš„å±‚æ•°ä¸ºhï¼Œåˆ™æ€»èŠ‚ç‚¹æ•°ä¸ºï¼š2^h - 1.**

+ äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§æ˜¯ï¼šå½“å‰èŠ‚ç‚¹çš„å€¼å¤§äºå·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ï¼Œå½“å‰èŠ‚ç‚¹çš„å€¼å°äºå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ã€‚ï¼ˆä¼˜å…ˆè€ƒè™‘ä¸­åºéå†LTRï¼Œå› ä¸ºåˆšå¥½L<T<Rã€‚å†ç”¨ä¸€ä¸ªå€¼ä¿å­˜å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼‰

+ å¹³è¡¡äºŒå‰æ ‘ï¼ˆAVL Treeï¼‰ï¼šä¸€ä¸ªäºŒå‰æ ‘*æ¯ä¸ªèŠ‚ç‚¹* çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€‚

### ç±»

```python
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    @classmethod
    def build(cls, val_list):
        node_list = list()
        n = len(val_list)
        for index in range(n):
            val = val_list[index]
            node = TreeNode(val)
            node_list.append(node)
        for index in range(n):
            left_index = index * 2 + 1
            right_index = index * 2 + 2
            node = node_list[index]
            if left_index < n:
                left_node = node_list[left_index]
                node.left = left_node
            if right_index < n:
                right_node = node_list[right_index]
                node.right = right_node
        return node_list[0]

    @staticmethod
    def maxDepth(root):
        if not root:
            return 0

        left_cnt = TreeNode.maxDepth(root.left) + 1
        right_cnt = TreeNode.maxDepth(root.right) + 1
        return max(left_cnt, right_cnt)

    @staticmethod
    def printf(root):
        # ç©ºæ ¼çš„æ¬¡æ•°
        depth = TreeNode.maxDepth(root)
        queue_list = [root]
        while len(queue_list):
            print("\t" * depth),
            node_cnt = len(queue_list)  # å½“å‰è¿™ä¸€å±‚nodeçš„ä¸ªæ•°
            for _ in range(node_cnt):
                node = queue_list[0]
                queue_list.pop(0)
                left_node = node.left
                right_node = node.right
                if left_node:
                    queue_list.append(left_node)
                if right_node:
                    queue_list.append(right_node)
                print(node.val),
                print("\t" * depth),
            depth -= 1
            print("\n"),
```



### äºŒå‰æ ‘æœ€å¤§æ·±åº¦

+ åŠ›æ‰£104ï¼š[äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å¤§æ·±åº¦ã€‚
  äºŒå‰æ ‘çš„æ·±åº¦ä¸ºæ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚
  è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
  
  ç»™å®šäºŒå‰æ ‘ [3,9,20,null,null,15,7]ï¼Œ
  è¿”å›å®ƒçš„æœ€å¤§æ·±åº¦ 3 ã€‚
  ```

+ é¢˜è§£ï¼šæ·±åº¦éä¼˜å…ˆæœç´¢

  ```python
  class Solution:
      def maxDepth(self, root):
          if root is None: 
              return 0 
  
  		left_height = self.maxDepth(root.left) + 1 
  		right_height = self.maxDepth(root.right) + 1 
  		return max(left_height, right_height) 
  ```

### äºŒå‰æ ‘çš„æœ€å°æ·±åº¦

+ åŠ›æ‰£111ï¼š[äºŒå‰æ ‘çš„æœ€å°æ·±åº¦](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

  ```python
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚
  æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚
  
  è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
  è¾“å‡ºï¼š2
  
  è¾“å…¥ï¼šroot = [2,null,3,null,4,null,5,null,6]
  è¾“å‡ºï¼š5
  ```

+ é¢˜è§£ï¼šè¯¥é—®é¢˜å®é™…å°±æ˜¯é—®æ ¹èŠ‚ç‚¹åˆ°å¶å­çš„æœ€çŸ­è·¯å¾„

  + ç”¨ä¸€ä¸ªå€¼ç”¨äºä¿å­˜ç»“æœ
  + è®¡ç®—åˆ°å¶å­èŠ‚ç‚¹çš„å±‚æ•°ï¼ˆå·¦å³èŠ‚ç‚¹ä¸ºNoneï¼‰
  + ä¿å­˜æœ€å°å€¼

  ```python
  class Solution(object):
      def minDepth(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def f(root, cnt, min_cnt):
              if not root.left and not root.right:
                  min_cnt = min(cnt, min_cnt)
                  return min_cnt
              cnt += 1
              if root.left:
                  min_cnt = f(root.left, cnt, min_cnt)
              if root.right:
                  min_cnt = f(root.right, cnt, min_cnt)
              return min_cnt
  
          if not root :
              return 0
          cnt = 1
          min_cnt = sys.maxint
          min_cnt = f(root, cnt, min_cnt)
          return min_cnt
  ```

### å¯¹ç§°äºŒå‰æ ‘

+ åŠ›æ‰£101ï¼š[å¯¹ç§°äºŒå‰æ ‘](https://leetcode-cn.com/problems/symmetric-tree/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ£€æŸ¥å®ƒæ˜¯å¦æ˜¯é•œåƒå¯¹ç§°çš„ã€‚
  
  ä¾‹å¦‚ï¼ŒäºŒå‰æ ‘ [1,2,2,3,4,4,3] æ˜¯å¯¹ç§°çš„ã€‚
  ä½†æ˜¯ä¸‹é¢è¿™ä¸ª [1,2,2,null,3,null,3] åˆ™ä¸æ˜¯é•œåƒå¯¹ç§°çš„:
  ```

+ é¢˜è§£ï¼š

  + æ¯ä¸ªæ ‘çš„å³å­æ ‘éƒ½ä¸å¦ä¸€ä¸ªæ ‘çš„å·¦å­æ ‘é•œåƒå¯¹ç§°
  + å®ƒä»¬çš„ä¸¤ä¸ªæ ¹ç»“ç‚¹å…·æœ‰ç›¸åŒçš„å€¼

  ```python
  class Solution(object):
      def isSymmetric(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # éƒ½åˆ°ç©ºèŠ‚ç‚¹åˆ™è®¤ä¸ºä¸€æ ·
              if not pnode and not qnode:
                  return True
              # æœ‰ä¸€ä¸ªéç©ºï¼Œå¦å¤–ç©ºï¼Œåˆ™è®¤ä¸ºä¸ä¸€æ ·
              if not pnode or not qnode:
                  return False
              # æœ‰å€¼ä¸åŒä¹Ÿä¸ä¸€æ ·
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.right) and check(pnode.right, qnode.left)
  
  
          if not root:
              return False
  
          return check(root.left, root.right)
  ```

### ç›¸åŒæ ‘

+ åŠ›æ‰£100ï¼š[ç›¸åŒçš„æ ‘](https://leetcode-cn.com/problems/same-tree/)

  ```
  ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ p å’Œ q ï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°æ¥æ£€éªŒè¿™ä¸¤æ£µæ ‘æ˜¯å¦ç›¸åŒã€‚
  å¦‚æœä¸¤ä¸ªæ ‘åœ¨ç»“æ„ä¸Šç›¸åŒï¼Œå¹¶ä¸”èŠ‚ç‚¹å…·æœ‰ç›¸åŒçš„å€¼ï¼Œåˆ™è®¤ä¸ºå®ƒä»¬æ˜¯ç›¸åŒçš„ã€‚

  è¾“å…¥ï¼šp = [1,2,3], q = [1,2,3]
  è¾“å‡ºï¼štrue
  
  è¾“å…¥ï¼šp = [1,2], q = [1,null,2]
  è¾“å‡ºï¼šfalse
  ```
  
+ é¢˜è§£ï¼šè¿™é“é¢˜è·Ÿä¸Šé¢åˆ°å¯¹ç§°äºŒå‰æ ‘æŸ¥ä¸åˆ°

  + æ¯ä¸ªæ ‘çš„å³ï¼ˆå·¦ï¼‰å­æ ‘éƒ½ä¸å¦ä¸€ä¸ªæ ‘çš„å³ï¼ˆå·¦ï¼‰å­æ ‘ç›¸åŒ
  + å®ƒä»¬çš„ä¸¤ä¸ªæ ¹ç»“ç‚¹å…·æœ‰ç›¸åŒçš„å€¼

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # éƒ½åˆ°ç©ºèŠ‚ç‚¹åˆ™è®¤ä¸ºä¸€æ ·
              if not pnode and not qnode:
                  return True
              # æœ‰ä¸€ä¸ªéç©ºï¼Œå¦å¤–ç©ºï¼Œåˆ™è®¤ä¸ºä¸ä¸€æ ·
              if not pnode or not qnode:
                  return False
              # æœ‰å€¼ä¸åŒä¹Ÿä¸ä¸€æ ·
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          return check(p,q)
  ```

### å¦ä¸€ä¸ªæ ‘çš„å­æ ‘

+ åŠ›æ‰£572ï¼š[å¦ä¸€ä¸ªæ ‘çš„å­æ ‘](https://leetcode-cn.com/problems/subtree-of-another-tree/)

  ```
  ç»™å®šä¸¤ä¸ªéç©ºäºŒå‰æ ‘ s å’Œ tï¼Œæ£€éªŒÂ s ä¸­æ˜¯å¦åŒ…å«å’Œ t å…·æœ‰ç›¸åŒç»“æ„å’ŒèŠ‚ç‚¹å€¼çš„å­æ ‘ã€‚s çš„ä¸€ä¸ªå­æ ‘åŒ…æ‹¬ s çš„ä¸€ä¸ªèŠ‚ç‚¹å’Œè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰å­å­™ã€‚s ä¹Ÿå¯ä»¥çœ‹åšå®ƒè‡ªèº«çš„ä¸€æ£µå­æ ‘ã€‚
  
  è¾“å…¥ï¼šs = [3,4,5,1,2] t = [4,1,2]
  è¾“å‡ºï¼štrueï¼Œå› ä¸º t ä¸ s çš„ä¸€ä¸ªå­æ ‘æ‹¥æœ‰ç›¸åŒçš„ç»“æ„å’ŒèŠ‚ç‚¹å€¼ã€‚
  
  è¾“å…¥ï¼šs = [3,4,5,1,2,null,null,null,null,0] t = [4,1,2]
  è¾“å‡ºï¼šfalse
  
  ```

+ é¢˜è§£ï¼šè¿™é“é¢˜è·Ÿä¸Šé¢ç›¸åŒæ ‘ä¸€æ ·

  + ç»“åˆä¸Šé¢çš„ç›¸åŒæ ‘ï¼Œå°†sçš„æ¯ä¸ªèŠ‚ç‚¹å½“æˆrootï¼Œè¿›è¡Œæ¯”è¾ƒ

  ```python
  class Solution(object):
      def isSubtree(self, s, t):
          """
          :type s: TreeNode
          :type t: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # éƒ½åˆ°ç©ºèŠ‚ç‚¹åˆ™è®¤ä¸ºä¸€æ ·
              if not pnode and not qnode:
                  return True
              # æœ‰ä¸€ä¸ªéç©ºï¼Œå¦å¤–ç©ºï¼Œåˆ™è®¤ä¸ºä¸ä¸€æ ·
              if not pnode or not qnode:
                  return False
              # æœ‰å€¼ä¸åŒä¹Ÿä¸ä¸€æ ·
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          qlist = [s]
          while len(qlist):
              n = len(qlist)
              for index in range(n):
                  node = qlist[0]
                  qlist.pop(0)
                  if check(node, t):
                      return True
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
          return False
  		"""
  		æ·±åº¦æœç´¢
  		# éå†rootèŠ‚ç‚¹ï¼Œå·¦èŠ‚ç‚¹ï¼Œå³èŠ‚ç‚¹
          if not s:
              return False
          return check(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
  		"""
  ```

### åŒæ„æ ‘

+ è…¾è®¯é¢˜ï¼š[åŒæ„æ ‘-TX](https://blog.csdn.net/weixin_43088751/article/details/104079228)

  ```
  ç®€å•æ¥è¯´ï¼Œå¯¹äºäºŒå‰æ ‘ï¼Œå¦‚æœä¸€ä¸ªæ ‘çš„å­©å­èŠ‚ç‚¹é€šè¿‡å·¦å³å˜æ¢å¯ä»¥å˜æˆå¦å¤–ä¸€ä¸ªæ ‘ï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ªæ ‘æ˜¯åŒæ„çš„ã€‚
  ```

+ é¢˜è§£ï¼š

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # éƒ½åˆ°ç©ºèŠ‚ç‚¹åˆ™è®¤ä¸ºä¸€æ ·
              if not pnode and not qnode:
                  return True
              # æœ‰ä¸€ä¸ªéç©ºï¼Œå¦å¤–ç©ºï¼Œåˆ™è®¤ä¸ºä¸ä¸€æ ·
              if not pnode or not qnode:
                  return False
              # æœ‰å€¼ä¸åŒä¹Ÿä¸ä¸€æ ·
              if pnode.val != qnode.val:
                  return False
  
              # åŒæ„æ ‘ä¸‹é¢ä¸¤ç§æƒ…å†µå…¶ä¸­1ä¸­
              # 1.å·¦å­æ ‘ç­‰äºå·¦å­æ ‘ï¼Œå³å­æ ‘ç­‰äºå³å­æ ‘ 
              # 2.å·¦å­æ ‘ç­‰äºå³å­æ ‘ï¼Œå·¦å­æ ‘ç­‰äºå³å­æ ‘
              return (check(pnode.left, qnode.left) and check(pnode.right, qnode.right)) or (check(pnode.left, qnode.right) and check(pnode.right, qnode.left))
  
          return check(p,q)
  ```

### ç¿»è½¬äºŒå‰æ ‘

+ åŠ›æ‰£226ï¼š[ç¿»è½¬äºŒå‰æ ‘](https://leetcode-cn.com/problems/invert-binary-tree/)

  ```
  ç¿»è½¬ä¸€æ£µäºŒå‰æ ‘ã€‚
  
  è¾“å…¥ï¼š[4,2,7,1,3,6,9]
  è¾“å‡ºï¼š[4,7,2,9,6,3,1]
  ```

+ é¢˜è§£ï¼šåˆ©ç”¨å‰åºéå†ï¼ˆTLRï¼‰

  + å…ˆéå†åˆ°root
  + ç„¶åäº¤æ¢rootçš„leftå’Œrightï¼ˆäº¤æ¢åä¸‹é¢çš„ç»“æ„å°±å·²ç»å˜æ¢äº†ï¼Œå¯ä»¥ç”»å›¾ï¼‰

  ```python
  class Solution(object):
      def invertTree(self, root):
          """
          :type root: TreeNode
          :rtype: TreeNode
          """
          if not root:
              return
  
          node = root.left
          root.left = root.right
          root.right = node
          self.invertTree(root.left)
          self.invertTree(root.right)
          return root
  ```

### å·¦å¶å­ä¹‹å’Œ

+ åŠ›æ‰£404[404. å·¦å¶å­ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-of-left-leaves/)

  ```
  è®¡ç®—ç»™å®šäºŒå‰æ ‘çš„æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚
  
  è¾“å…¥ï¼š[3,9,20,None,None,15,7]
  è¾“å‡ºï¼š24
  ```

+ é¢˜è§£ï¼š

  + åˆ¤æ–­ä¸€ä¸ªèŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹æ˜¯ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯åˆ™ç´¯åŠ è¯¥èŠ‚ç‚¹çš„å€¼

  ```python
  class Solution(object):
      def sumOfLeftLeaves(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def isLeafNode(root):
              if not root.left and not root.right:
                  return True
              return False
  
          if not root:
              return 0
  
          ans = 0
          if root.left:
              if isLeafNode(root.left):
                  ans = root.left.val
              ans += self.sumOfLeftLeaves(root.left)
          # ä¸Šé¢å·²ç»åŠ è¿‡ä¸€æ¬¡äº†ï¼Œè¿™é‡Œå°±åªéœ€è¦è®¡ç®—rightçš„æƒ…å†µ
          if root.right:
              ans += self.sumOfLeftLeaves(root.right)
  
          return ans
  ```

### äºŒå‰æ ‘çš„å®Œå…¨æ€§æ£€éªŒ

+ åŠ›æ‰£958ï¼š[äºŒå‰æ ‘çš„å®Œå…¨æ€§æ£€éªŒ](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œç¡®å®šå®ƒæ˜¯å¦æ˜¯ä¸€ä¸ªå®Œå…¨äºŒå‰æ ‘ã€‚
  ç™¾åº¦ç™¾ç§‘ä¸­å¯¹å®Œå…¨äºŒå‰æ ‘çš„å®šä¹‰å¦‚ä¸‹ï¼š
  è‹¥è®¾äºŒå‰æ ‘çš„æ·±åº¦ä¸º hï¼Œé™¤ç¬¬ h å±‚å¤–ï¼Œå…¶å®ƒå„å±‚ (1ï½h-1) çš„ç»“ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§ä¸ªæ•°ï¼Œç¬¬ h å±‚æ‰€æœ‰çš„ç»“ç‚¹éƒ½è¿ç»­é›†ä¸­åœ¨æœ€å·¦è¾¹ï¼Œè¿™å°±æ˜¯å®Œå…¨äºŒå‰æ ‘ã€‚ï¼ˆæ³¨ï¼šç¬¬ h å±‚å¯èƒ½åŒ…å« 1~Â 2hÂ ä¸ªèŠ‚ç‚¹ã€‚ï¼‰
  
  è¾“å…¥ï¼š[1,2,3,4,5,6]
  è¾“å‡ºï¼štrue
  è§£é‡Šï¼šæœ€åä¸€å±‚å‰çš„æ¯ä¸€å±‚éƒ½æ˜¯æ»¡çš„ï¼ˆå³ï¼Œç»“ç‚¹å€¼ä¸º {1} å’Œ {2,3} çš„ä¸¤å±‚ï¼‰ï¼Œä¸”æœ€åä¸€å±‚ä¸­çš„æ‰€æœ‰ç»“ç‚¹ï¼ˆ{4,5,6}ï¼‰éƒ½å°½å¯èƒ½åœ°å‘å·¦ã€‚
  
  è¾“å…¥ï¼š[1,2,3,4,5,null,7]
  è¾“å‡ºï¼šfalse
  è§£é‡Šï¼šå€¼ä¸º 7 çš„ç»“ç‚¹æ²¡æœ‰å°½å¯èƒ½é å‘å·¦ä¾§ã€‚
  ```

+ é¢˜è§£ï¼š

  + å°†æ ‘è½¬æ¢æˆä¸€ä¸ªæ•°ç»„çš„å½¢å¼ï¼Œé‚£ä¹ˆä¼šæœ‰è¿™ä¸ªå…¬å¼ï¼š**å‡è®¾rootçš„ä¸‹æ ‡ä¸ºindexï¼ˆä¸‹æ ‡ä»0å¼€å§‹ï¼‰ï¼Œé‚£ä¹ˆrootçš„leftä¸‹æ ‡ä¸ºindex*2 + 1ï¼Œrootçš„rightä¸‹æ ‡ä¸ºindex*2 + 2**
  + **å¯¹äºå®Œå…¨äºŒå‰æ ‘è€Œè¨€ï¼šå°±æœ‰æ•°ç»„çš„å¤§å°ï¼ˆæ€»èŠ‚ç‚¹ä¸ªæ•°-1ï¼‰ç­‰äºæœ€å¤§çš„ä¸‹æ ‡**

  ```python
  class Solution(object):
      def isCompleteTree(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          if not root:
              return False
  
          cnt = 0  # è®¡ç®—æ€»ä¸ªæ•°
          index_map = {root: 0} # ä¿å­˜èŠ‚ç‚¹å¯¹åº”çš„ä¸‹æ ‡
          max_index = 0 # è®°å½•æœ€å¤§ä¸‹æ ‡
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              for _ in range(n):
                  cnt += 1
                  node = qlist[0]
                  index = index_map[node]
                  qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                      left_index = index * 2 + 1
                      index_map[left_node] = left_index
                      max_index = left_index
  
                  if right_node:
                      qlist.append(right_node)
                      right_index = index * 2 + 2
                      index_map[right_node] = right_index
                      max_index = right_index
  
  		# è¿™é‡Œæ˜¯ç”¨æ€»ä¸ªæ•°ï¼Œæ‰€ä»¥è¦æ€»ä¸ªæ•°-1ï¼Œå› ä¸ºä¸‹æ ‡ä»0å¼€å§‹
          return max_index == cnt-1
  ```


### å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°

+ åŠ›æ‰£222ï¼š[å®Œå…¨äºŒå‰æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

  ```
  ç»™ä½ ä¸€æ£µ å®Œå…¨äºŒå‰æ ‘ çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚
  
  å®Œå…¨äºŒå‰æ ‘ çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~Â 2hÂ ä¸ªèŠ‚ç‚¹ã€‚
  
  è¾“å…¥ï¼šroot = [1,2,3,4,5,6]
  è¾“å‡ºï¼š6
  
  è¾“å…¥ï¼šroot = []
  è¾“å‡ºï¼š0
  
  è¾“å…¥ï¼šroot = [1]
  è¾“å‡ºï¼š1
  ```

+ é¢˜è§£ï¼š[é¢˜è§£](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/c-san-chong-fang-fa-jie-jue-wan-quan-er-cha-shu-de/)

  + **è¿™æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘**ï¼šé™¤æœ€åä¸€å±‚å¤–ï¼Œå…¶ä½™å±‚å…¨éƒ¨é“ºæ»¡ï¼›ä¸”æœ€åä¸€å±‚å‘å·¦åœé 
  + å¦‚æœæ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘æ·±åº¦ç­‰äºå³å­æ ‘æ·±åº¦ï¼Œåˆ™è¯´æ˜**å·¦å­æ ‘ä¸ºæ»¡äºŒå‰æ ‘**ï¼ˆå¯ä»¥ç”»å›¾ï¼‰
  + å¦‚æœæ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘æ·±åº¦å¤§äºå³å­æ ‘æ·±åº¦ï¼Œåˆ™è¯´æ˜**å³å­æ ‘ä¸ºæ»¡äºŒå‰æ ‘**ï¼ˆå¯ä»¥ç”»å›¾ï¼‰
  + æ»¡äºŒå‰æ ‘çš„å±‚æ•°ä¸ºhï¼Œåˆ™æ€»èŠ‚ç‚¹æ•°ä¸ºï¼š2^h - 1.ï¼ˆ1 << depth - 1ï¼‰
  + é‚£ä¹ˆå¯ä»¥å¾—åˆ°ä¸€ä¸ªå…¬å¼ï¼ˆè·å¾—å½“å‰rootæ€»èŠ‚ç‚¹ä¸ªæ•°ï¼‰ï¼šroot = ï¼ˆ1 << left_depth | right_depth - 1ï¼‰+ fun(root.right | root.left)  + 1
    + å·¦å­æ ‘ï¼ˆå³å­æ ‘ï¼‰æ»¡äºŒå‰æ ‘çš„æ€»èŠ‚ç‚¹æ•° + é€’å½’å³å­æ ‘ï¼ˆå·¦å­æ ‘ï¼‰æ€»èŠ‚ç‚¹æ•° + 1ï¼ˆrootèŠ‚ç‚¹ï¼‰

  ```python
  class Solution(object):
      def countNodes(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def getDepth(root):
              if not root:
                  return 0
  
              cnt = 0
              while root:
                  root = root.left
                  cnt += 1
              return cnt
  
          if not root:
              return 0
          left_depth = getDepth(root.left)
          right_depth = getDepth(root.right)
          # æ ¹æ®å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨ï¼š
          # å¦‚æœå·¦å­æ ‘é«˜åº¦ç­‰äºå³å­æ ‘é«˜åº¦ã€‚åˆ™å·¦å­æ ‘ä¸ºæ»¡äºŒå‰æ ‘ã€‚
          # å¦‚æœå·¦å­æ ‘é«˜åº¦ä¸ç­‰äºå³å­æ ‘é«˜åº¦ã€‚åˆ™å³å­æ ‘ä¸ºæ»¡äºŒå‰æ ‘ã€‚
          # æ»¡äºŒå‰æ ‘çš„æ€»ç»“ç‚¹æ•°ï¼š2^h - 1 ï¼ˆæ·±åº¦ä»1å¼€å§‹è®¡ç®—ï¼‰
          if left_depth == right_depth:
              # è¯¥rootèŠ‚ç‚¹çš„ä¸ªæ•°ç­‰äºï¼šå·¦å­æ ‘æ»¡äºŒå‰æ ‘çš„æ€»ä¸ªæ•° + é€’å½’å³å­æ ‘ï¼ˆéæ»¡äºŒå‰æ ‘ï¼‰ + 1ï¼ˆrootèŠ‚ç‚¹ï¼‰
              return self.countNodes(root.right) + (1 << left_depth)  # (1 << left_depth -1) + 1
          else:
              # å³å­æ ‘æ˜¯æ»¡äºŒå‰æ ‘
              return self.countNodes(root.left) + (1 << right_depth)  # (1 << right_depth -1) + 1
  ```

### äºŒå‰æ ‘çš„ç›´å¾„

+ åŠ›æ‰£543ï¼š[äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

  ```
  ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚
  æ³¨æ„ï¼šä¸¤ç»“ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦æ˜¯ä»¥å®ƒä»¬ä¹‹é—´è¾¹çš„æ•°ç›®è¡¨ç¤ºã€‚
  
  è¾“å…¥ï¼šroot = [1,2,3,4,5]
  è¾“å‡ºï¼š3  å®ƒçš„é•¿åº¦æ˜¯è·¯å¾„ [4,2,1,3] æˆ–è€… [5,2,1,3]ã€‚
  ```

+ é¢˜è§£ï¼š[é¢˜è§£](https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/)

  + å¯¹äºè¯¥èŠ‚ç‚¹çš„å·¦å„¿å­å‘ä¸‹éå†ç»è¿‡æœ€å¤šçš„èŠ‚ç‚¹æ•° LL ï¼ˆå³ä»¥å·¦å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ï¼‰ 
  + å…¶å³å„¿å­å‘ä¸‹éå†ç»è¿‡æœ€å¤šçš„èŠ‚ç‚¹æ•° R ï¼ˆå³ä»¥å³å„¿å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ï¼‰
  + é‚£ä¹ˆä»¥è¯¥èŠ‚ç‚¹ä¸ºèµ·ç‚¹çš„è·¯å¾„ç»è¿‡èŠ‚ç‚¹æ•°çš„æœ€å¤§å€¼å³ä¸º L+R+1
  + è®°èŠ‚ç‚¹node ä¸ºèµ·ç‚¹çš„è·¯å¾„ç»è¿‡èŠ‚ç‚¹æ•°çš„æœ€å¤§å€¼ä¸ºnode_maxï¼Œé‚£ä¹ˆäºŒå‰æ ‘çš„ç›´å¾„å°±æ˜¯æ‰€æœ‰èŠ‚ç‚¹node_max-1

  ```python
  class Solution(object):
      def diameterOfBinaryTree(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def maxDepth(root):
              if not root:
                  return 0
              # å·¦å­æ ‘ä¸ºæ ¹çš„æ·±åº¦
              left_depth = maxDepth(root.left)
              # å³å­æ ‘ä¸ºæ ¹çš„æ·±åº¦
              right_depth = maxDepth(root.right)
              # è¯¥èŠ‚ç‚¹ä¸ºæ ¹ï¼Œå…¶å·¦å³å­æ ‘æœ€æ·±é«˜åº¦å’Œï¼Œè·Ÿmax_depthæ¯”è¾ƒ
              self.ans = max(self.ans, left_depth + right_depth + 1)
              # è¿”å›è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„æœ€æ·±é«˜åº¦
              return max(left_depth, right_depth) + 1
          if not root:
              return 0
          self.ans = 0
          maxDepth(root)
          return self.ans - 1 # æ³¨æ„ï¼šä¸¤ç»“ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦æ˜¯ä»¥å®ƒä»¬ä¹‹é—´è¾¹çš„æ•°ç›®è¡¨ç¤ºã€‚æ‰€ä»¥è¦æ·±åº¦-1
  ```

### äºŒå‰æ ‘çš„å¡åº¦

+ åŠ›æ‰£563ï¼š[äºŒå‰æ ‘çš„å¡åº¦](https://leetcode-cn.com/problems/binary-tree-tilt/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè®¡ç®— æ•´ä¸ªæ ‘ çš„å¡åº¦ ã€‚
  ä¸€ä¸ªæ ‘çš„ èŠ‚ç‚¹çš„å¡åº¦ å®šä¹‰å³ä¸ºï¼Œè¯¥èŠ‚ç‚¹å·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œå’Œå³å­æ ‘èŠ‚ç‚¹ä¹‹å’Œçš„ å·®çš„ç»å¯¹å€¼ ã€‚å¦‚æœæ²¡æœ‰å·¦å­æ ‘çš„è¯ï¼Œå·¦å­æ ‘çš„èŠ‚ç‚¹ä¹‹å’Œä¸º 0 ï¼›æ²¡æœ‰å³å­æ ‘çš„è¯ä¹Ÿæ˜¯ä¸€æ ·ã€‚ç©ºç»“ç‚¹çš„å¡åº¦æ˜¯ 0 ã€‚
  æ•´ä¸ªæ ‘ çš„å¡åº¦å°±æ˜¯å…¶æ‰€æœ‰èŠ‚ç‚¹çš„å¡åº¦ä¹‹å’Œã€‚
  
  è¾“å…¥ï¼šroot = [1,2,3]
  è¾“å‡ºï¼š1
  è§£é‡Šï¼š
  èŠ‚ç‚¹ 2 çš„å¡åº¦ï¼š|0-0| = 0ï¼ˆæ²¡æœ‰å­èŠ‚ç‚¹ï¼‰
  èŠ‚ç‚¹ 3 çš„å¡åº¦ï¼š|0-0| = 0ï¼ˆæ²¡æœ‰å­èŠ‚ç‚¹ï¼‰
  èŠ‚ç‚¹ 1 çš„å¡åº¦ï¼š|2-3| = 1ï¼ˆå·¦å­æ ‘å°±æ˜¯å·¦å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥å’Œæ˜¯ 2 ï¼›å³å­æ ‘å°±æ˜¯å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥å’Œæ˜¯ 3 ï¼‰
  å¡åº¦æ€»å’Œï¼š0 + 0 + 1 = 1
  
  è¾“å…¥ï¼šroot = [4,2,9,3,5,null,7]
  è¾“å‡ºï¼š15
  è§£é‡Šï¼š
  èŠ‚ç‚¹ 3 çš„å¡åº¦ï¼š|0-0| = 0ï¼ˆæ²¡æœ‰å­èŠ‚ç‚¹ï¼‰
  èŠ‚ç‚¹ 5 çš„å¡åº¦ï¼š|0-0| = 0ï¼ˆæ²¡æœ‰å­èŠ‚ç‚¹ï¼‰
  èŠ‚ç‚¹ 7 çš„å¡åº¦ï¼š|0-0| = 0ï¼ˆæ²¡æœ‰å­èŠ‚ç‚¹ï¼‰
  èŠ‚ç‚¹ 2 çš„å¡åº¦ï¼š|3-5| = 2ï¼ˆå·¦å­æ ‘å°±æ˜¯å·¦å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥å’Œæ˜¯ 3 ï¼›å³å­æ ‘å°±æ˜¯å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥å’Œæ˜¯ 5 ï¼‰
  èŠ‚ç‚¹ 9 çš„å¡åº¦ï¼š|0-7| = 7ï¼ˆæ²¡æœ‰å·¦å­æ ‘ï¼Œæ‰€ä»¥å’Œæ˜¯ 0 ï¼›å³å­æ ‘æ­£å¥½æ˜¯å³å­èŠ‚ç‚¹ï¼Œæ‰€ä»¥å’Œæ˜¯ 7 ï¼‰
  ```

+ é¢˜è§£ï¼š

  + ç”¨äºä¸€ä¸ªå…¨å±€å˜é‡ä¿å­˜æ¯ä¸ªå¡åº¦çš„å€¼
  + é€’å½’å‡½æ•°çš„è¿”å›å€¼ï¼šå·¦å­æ ‘çš„å’Œ+å³å­æ ‘çš„å’Œ+è¯¥èŠ‚ç‚¹çš„å€¼ï¼ˆç”¨äºè¯¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹æ¥åšå·®å€¼ï¼‰

  ```python
  class Solution(object):
      def findTilt(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          self.ans = 0
          def calc(root):
              if not root:
                  return 0
              left_val = calc(root.left)
              right_val = calc(root.right)
              self.ans += abs(left_val - right_val)
              return left_val + right_val + root.val
          
          if not root:
              return 0
          calc(root)
          return self.ans
  ```


### äºŒå‰æ ‘çš„å±‚åºéå†

+ åŠ›æ‰£102ï¼š[äºŒå‰æ ‘çš„å±‚åºéå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

  ```
  ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ å±‚åºéå† å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚
  
  äºŒå‰æ ‘ï¼š[3,9,20,null,null,15,7],
  è¿”å›å…¶å±‚åºéå†ç»“æœï¼š
  [
    [3],
    [9,20],
    [15,7]
  ]
  ```

+ é¢˜è§£ï¼š

  + é¦–å…ˆæ ¹å…ƒç´ å…¥é˜Ÿ
  + å½“é˜Ÿåˆ—ä¸ä¸ºç©ºçš„æ—¶å€™
    - æ±‚å½“å‰é˜Ÿåˆ—çš„é•¿åº¦ n (è¯¥å±‚çš„èŠ‚ç‚¹ä¸ªæ•°)
    - ä¾æ¬¡ä»é˜Ÿåˆ—ä¸­å– n ä¸ªå…ƒç´ è¿›è¡Œæ‹“å±•ï¼Œæ¯ä¸ªå…ƒç´ å¾—åˆ°å…¶å·¦èŠ‚ç‚¹å’Œå³èŠ‚ç‚¹ã€‚å·¦å³èŠ‚ç‚¹ä¸ä¸ºNoneåˆ™å†åŠ å…¥é˜Ÿåˆ—ä¸­ï¼Œç„¶åè¿›å…¥ä¸‹ä¸€æ¬¡è¿­ä»£

  ```python
  class Solution(object):
      def levelOrder(self, root):
          """
          :type root: TreeNode
          :rtype: List[List[int]]
          """
          if not root:
              return []
          
          ans = []
          qlist = [root]
          while len(qlist): # éå†å±‚æ•°
              level_list = []
              n = len(qlist)
              for _ in range(n): # éå†æ¯å±‚èŠ‚ç‚¹ä¸ªæ•°
                  node = qlist.pop(0) # æ¯æ¬¡é˜Ÿåˆ—å–å‡ºé˜Ÿå¤´
                  level_list.append(node.val)
  
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
              ans.append(level_list)
  
          return ans
  ```

### äºŒå‰æ ‘çš„å‰åºéå†

+ åŠ›æ‰£144ï¼š[äºŒå‰æ ‘çš„å‰åºéå†](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

  ```
  ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒèŠ‚ç‚¹å€¼çš„ å‰åº éå†ã€‚
  
  è¾“å…¥ï¼šroot = [1,null,2,3]
  è¾“å‡ºï¼š[1,2,3]
  ```

+ é¢˜è§£ï¼š

  + äºŒå‰æ ‘çš„å‰åºéå†ï¼šè¾“å‡ºæ ¹èŠ‚ç‚¹->å·¦å­æ ‘->å³å­æ ‘ã€‚ï¼ˆTLRï¼‰
  + å®ç°æ–¹å¼æœ‰ä¸¤ç§ï¼šé€’å½’ï¼ˆå·²ç»åœ¨æ€»ç»“ç»™å‡ºï¼Œè¾ƒä¸ºå¸¸ç”¨ï¼‰ï¼Œè¿™é‡Œç»™å‡ºéé€’å½’
  + æ ¹æ®ä¸Šé¢çš„è§„å¾‹ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ªæ ˆè¿›è¡Œä¿å­˜
  + è·å–æ ¹èŠ‚ç‚¹ï¼Œè¾“å‡ºæ ¹èŠ‚ç‚¹çš„å€¼
  + è·å–æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼Œå³å­æ ‘
  + å¦‚æœå³å­æ ‘ä¸ä¸ºNoneï¼Œåˆ™å³å­æ ‘å…ˆå…¥æ ˆï¼ˆå› ä¸ºè¾ƒåè¾“å‡ºï¼‰
  + å¦‚æœå·¦å­æ ‘ä¸ä¸ºNoneï¼Œåˆ™å·¦å­æ ‘å†å…¥æ ˆ
  + ä¾æ¬¡å¾ªç¯ï¼Œç»“æŸæ¡ä»¶æ˜¯æ ˆä¸ºç©º

  ```python
  class Solution(object):
      def preorderTraversal(self, root):
          """
          :type root: TreeNode
          :rtype: List[int]
          """
          if not root:
              return []
          
          ans = []
          slist = [root]
          while len(slist):
              node = slist.pop(0)
              ans.append(node.val)
              left_node = node.left
              right_node = node.right
              if right_node:
                  slist.insert(0,right_node)
              if left_node:
                  slist.insert(0,left_node)
  
          return ans
  ```

### äºŒå‰æ ‘çš„ååºéå†

+ åŠ›æ‰£145ï¼š[äºŒå‰æ ‘çš„ååºéå†](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å®ƒçš„ ååº éå†ã€‚
  
  è¾“å…¥: [1,null,2,3] 
  è¾“å‡º: [3,2,1]
  ```

+ é¢˜è§£ï¼š

  + äºŒå‰æ ‘çš„å‰åºéå†ï¼šè¾“å‡ºå·¦å­æ ‘->å³å­æ ‘->æ ¹èŠ‚ç‚¹ã€‚ï¼ˆLRTï¼‰
  + æˆ‘ä»¬å¯ä»¥çœ‹å‰åºéå†ï¼ˆTLRï¼‰å’Œååºéå†ï¼ˆLRTï¼‰å¾ˆåƒï¼Œåªæ˜¯Tæ”¾åœ¨å‰åé—®é¢˜
  + é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥çœ‹ï¼šTLR -> TRL -> LRT
  + é‚£æ˜¯ä¸æ˜¯é€šè¿‡ä¿®æ”¹ä¸‹å‰åºéå†ï¼Œå·¦å­æ ‘å’Œå³å­æ ‘å…¥æ ˆçš„é¡ºåºå¾—åˆ°TRLï¼Œç„¶åå†åè½¬ä¸‹ç»“æœå°±å¯ä»¥åˆ°

  ```python
  class Solution(object):
      def levelOrder(self, root):
          """
          :type root: TreeNode
          :rtype: List[List[int]]
          """
          if not root:
              return []
          
          ans = []
          qlist = [root]
          while len(qlist):
              level_list = []
              n = len(qlist)
              for _ in range(n):
                  node = qlist.pop(0)
                  level_list.append(node.val)
  
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
              ans.append(level_list)
  
          return ans
  ```

### äºŒå‰æ ‘çš„ä¸­åºéå†

+ åŠ›æ‰£94ï¼š[äºŒå‰æ ‘çš„ä¸­åºéå†](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å®ƒçš„ ä¸­åº éå†ã€‚
  
  è¾“å…¥ï¼šroot = [1,null,2,3]
  è¾“å‡ºï¼š[1,3,2]
  ```

+ é¢˜è§£ï¼š[é¢œè‰²æ ‡è®°æ³•-ä¸€ç§é€šç”¨ä¸”ç®€æ˜çš„æ ‘éå†æ–¹æ³•](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/)

  + ä½¿ç”¨é¢œè‰²æ ‡è®°èŠ‚ç‚¹çš„çŠ¶æ€ï¼Œæ–°èŠ‚ç‚¹ä¸º0ï¼Œå·²è®¿é—®çš„èŠ‚ç‚¹ä¸º1ã€‚
  + å¦‚æœé‡åˆ°çš„èŠ‚ç‚¹ä¸º0ï¼Œåˆ™å°†å…¶æ ‡è®°ä¸º1ï¼Œç„¶åå°†å…¶å³å­èŠ‚ç‚¹ã€è‡ªèº«ã€å·¦å­èŠ‚ç‚¹ä¾æ¬¡å…¥æ ˆã€‚
  + å¦‚æœé‡åˆ°çš„èŠ‚ç‚¹ä¸º1ï¼Œåˆ™å°†èŠ‚ç‚¹çš„å€¼è¾“å‡ºã€‚
  + å‰åºéå†å’Œååºéå†éƒ½å¯ä»¥ç”¨è¯¥æ–¹æ³•

  ```python
  class Solution(object):
      def inorderTraversal(self, root):
          """
          :type root: TreeNode
          :rtype: List[int]
          """
          if not root:
              return []
          
          ans = []
          # flag 0è¡¨ç¤ºæ–°èŠ‚ç‚¹
          # flag 1è¡¨ç¤ºå·²è®¿é—®èŠ‚ç‚¹
          slist = [(root, 0)]
          while len(slist):
              node, flag = slist.pop()
              if node is None:
                  continue
              if flag == 0:
                  left_node = node.left
                  right_node = node.right
                  slist.append((right_node, 0)) # å³å­æ ‘å…¥æ ˆï¼Œå› ä¸ºæœ€åè¾“å‡º
                  slist.append((node, 1)) # è‡ªå·±å†æ¬¡å…¥æ ˆï¼Œç”¨äºä¸‹æ¬¡è¾“å‡º
                  slist.append((left_node, 0)) # å·¦å­æ ‘å…¥æ ˆï¼Œç”¨äºä¸‹æ¬¡éå†
              else:
                  ans.append(node.val)
  
          return ans
  ```


### äºŒå‰æ ‘çš„å³è§†å›¾

+ åŠ›æ‰£199ï¼š[äºŒå‰æ ‘çš„å³è§†å›¾](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

  ```
  ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œæƒ³è±¡è‡ªå·±ç«™åœ¨å®ƒçš„å³ä¾§ï¼ŒæŒ‰ç…§ä»é¡¶éƒ¨åˆ°åº•éƒ¨çš„é¡ºåºï¼Œè¿”å›ä»å³ä¾§æ‰€èƒ½çœ‹åˆ°çš„èŠ‚ç‚¹å€¼ã€‚
  
  è¾“å…¥: [1,2,3,null,5,null,4]
  è¾“å‡º: [1, 3, 4]
  ```

+ é¢˜è§£ï¼š

  + åˆ©ç”¨å±‚æ¬¡éå†
  + æ¯ä¸€å±‚æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å€¼åŠ å…¥åˆ°ç»“æœ

  ```python
  class Solution(object):
      def rightSideView(self, root):
          """
          :type root: TreeNode
          :rtype: List[int]
          """
          if not root:
              return []
          
          ans = []
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              last_node = qlist[-1]
              ans.append(last_node.val)
              for _ in range(n):
                  node = qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
  
          return ans
  ```

### äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

+ åŠ›æ‰£236ï¼š[äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
  ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
  
  è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
  è¾“å‡ºï¼š3
  è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 1 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 3 ã€‚
  
  è¾“å…¥ï¼šroot = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
  è¾“å‡ºï¼š5
  è§£é‡Šï¼šèŠ‚ç‚¹ 5 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯èŠ‚ç‚¹ 5 ã€‚å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚
  
  è¾“å…¥ï¼šroot = [1,2], p = 1, q = 2
  è¾“å‡ºï¼š1
  ```
  
+ é¢˜è§£ï¼š[äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆï¼ˆååºéå† DFS ï¼Œæ¸…æ™°å›¾è§£ï¼‰](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)

  + è‹¥ rootæ˜¯p,qçš„æœ€è¿‘å…¬å…±ç¥–å…ˆ ï¼Œåˆ™åªå¯èƒ½ä¸ºä»¥ä¸‹æƒ…å†µä¹‹ä¸€ï¼š
  + p å’Œ q åœ¨ rootçš„å­æ ‘ä¸­ï¼Œä¸”åˆ†åˆ— root çš„ å¼‚ä¾§ï¼ˆå³åˆ†åˆ«åœ¨å·¦ã€å³å­æ ‘ä¸­ï¼‰ï¼›
  + p = root ï¼Œä¸”qåœ¨rootçš„å·¦æˆ–å³å­æ ‘ä¸­ï¼›
  + q = root ï¼Œä¸”påœ¨rootçš„å·¦æˆ–å³å­æ ‘ä¸­ï¼›

  ```python
  class Solution(object):
      def lowestCommonAncestor(self, root, p, q):
          """
          :type root: TreeNode
          :type p: TreeNode
          :type q: TreeNode
          :rtype: TreeNode
          """
          if not root:
              return None
              
          if root == p or root == q: 
              return root
              
          left_node = self.lowestCommonAncestor(root.left, p , q)
          right_node = self.lowestCommonAncestor(root.right, p , q)
          
          # å½“leftå’ŒrightåŒæ—¶ä¸ä¸ºç©º ï¼šè¯´æ˜p,q åˆ†åˆ—åœ¨rootçš„å¼‚ä¾§ï¼ˆåˆ†åˆ«åœ¨å·¦/å³å­æ ‘ï¼‰ï¼Œå› æ­¤rootä¸ºæœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œè¿”å› rootï¼›
          if left_node and right_node: 
              return root
  
  		# å½“leftå’ŒrightåŒæ—¶ä¸ºç©º ï¼šè¯´æ˜ root çš„å·¦/å³å­æ ‘ä¸­éƒ½ä¸åŒ…å«p,qï¼Œè¿”å› null
          if not left_node and not right_node:
              return None
              
          # å½“leftä¸ºç©ºï¼Œrightä¸ä¸ºç©ºï¼šp,q éƒ½ä¸åœ¨rootçš„å·¦å­æ ‘ä¸­ï¼Œç›´æ¥è¿”å›right ã€‚å…·ä½“å¯åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š
          # p,qå…¶ä¸­ä¸€ä¸ªåœ¨rootçš„å³å­æ ‘ä¸­ï¼Œæ­¤æ—¶rightæŒ‡å‘pï¼ˆå‡è®¾ä¸ºpï¼‰
          # p,qä¸¤èŠ‚ç‚¹éƒ½åœ¨rootçš„å³å­æ ‘ä¸­ï¼Œæ­¤æ—¶rightæŒ‡å‘æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹ 
          if not left_node and right_node:
              return right_node
          # åŒä¸Š
          if not right_node and left_node:
              return left_node
  ```

### è·¯å¾„æ€»å’Œ

+ åŠ›æ‰£112ï¼š[ è·¯å¾„æ€»å’Œ](https://leetcode-cn.com/problems/path-sum/)

  ```
  ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹Â root å’Œä¸€ä¸ªè¡¨ç¤ºç›®æ ‡å’Œçš„æ•´æ•°Â targetSum ï¼Œåˆ¤æ–­è¯¥æ ‘ä¸­æ˜¯å¦å­˜åœ¨ æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ çš„è·¯å¾„ï¼Œè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰èŠ‚ç‚¹å€¼ç›¸åŠ ç­‰äºç›®æ ‡å’ŒÂ targetSum 
  å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
  
  è¾“å…¥ï¼šroot = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
  è¾“å‡ºï¼štrue
  
  è¾“å…¥ï¼šroot = [1,2,3], targetSum = 5
  è¾“å‡ºï¼šfalse
  
  è¾“å…¥ï¼šroot = [1,2], targetSum = 0
  è¾“å‡ºï¼šfalse
  ```

+ é¢˜è§£ï¼šç”¨å‰åºéå†

  + æ¯æ¬¡éƒ½å‡å»åŠ å½“å‰èŠ‚ç‚¹çš„å€¼
  + å½“é€’å½’åˆ°æ ¹èŠ‚ç‚¹çš„æ—¶å€™ï¼Œåˆ¤æ–­å½“å‰èŠ‚ç‚¹çš„å€¼æ˜¯ä¸æ˜¯å’Œç›®æ ‡å€¼ä¸€æ ·

  ```python
  # Definition for a binary tree node.
  # class TreeNode(object):
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution(object):
      def hasPathSum(self, root, targetSum):
          """
          :type root: TreeNode
          :type targetSum: int
          :rtype: bool
          """
  		if not root:
              return False
          if not root.left and not root.right:
              return targetSum == root.val
          return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
  ```

### äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„

+ åŠ›æ‰£257ï¼š[äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„](https://leetcode-cn.com/problems/binary-tree-paths/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚
  è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
  
  è¾“å‡º: ["1->2->5", "1->3"]
  è§£é‡Š: æ‰€æœ‰æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ä¸º: 1->2->5, 1->3
  ```

+ é¢˜è§£ï¼šå‰åºéå†

  ```python
  class Solution(object):
      def binaryTreePaths(self, root):
          """
          :type root: TreeNode
          :rtype: List[str]
          """
          self.ans = []
          def paths(root, node_string):
              if not root:
                  return
              if not root.left and not root.right:
                  node_string += "{}".format(root.val)
                  self.ans.append(node_string)
                  return
              node_string += "{}->".format(root.val)
              paths(root.left, node_string)
              paths(root.right, node_string)
  
          if not root :
              return []
          paths(root, "")
          return self.ans
  ```


### æ±‚æ ¹åˆ°å¶å­èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ

+ åŠ›æ‰£129ï¼š[æ±‚æ ¹åˆ°å¶å­èŠ‚ç‚¹æ•°å­—ä¹‹å’Œ](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œå®ƒçš„æ¯ä¸ªç»“ç‚¹éƒ½å­˜æ”¾ä¸€ä¸ªÂ 0-9Â çš„æ•°å­—ï¼Œæ¯æ¡ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„éƒ½ä»£è¡¨ä¸€ä¸ªæ•°å­—ã€‚
  ä¾‹å¦‚ï¼Œä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 1->2->3 ä»£è¡¨æ•°å­— 123ã€‚
  è®¡ç®—ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹ç”Ÿæˆçš„æ‰€æœ‰æ•°å­—ä¹‹å’Œã€‚
  è¯´æ˜:Â å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
  
  è¾“å…¥: [4,9,0,5,1]
  è¾“å‡º: 1026
  è§£é‡Š:
  ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 4->9->5 ä»£è¡¨æ•°å­— 495.
  ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 4->9->1 ä»£è¡¨æ•°å­— 491.
  ä»æ ¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„ 4->0 ä»£è¡¨æ•°å­— 40.
  å› æ­¤ï¼Œæ•°å­—æ€»å’Œ = 495 + 491 + 40 = 1026.
  ```

+ é¢˜è§£ï¼šè·Ÿ257é¢˜ä¸€æ ·ç”¨å‰åºéå†

  ```python
  class Solution(object):
      def sumNumbers(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          self.ans = 0
          def calc(root, sumNum):
              if not root:
                  return
              if not root.left and not root.right:
                  sumNum = sumNum*10 + root.val
                  self.ans += sumNum
                  return
              sumNum = sumNum*10 + root.val
              calc(root.left, sumNum)
              calc(root.right, sumNum)
          if not root:
              return 0
          calc(root, 0)
          return self.ans
  ```

### è·¯å¾„æ€»å’ŒII

+ åŠ›æ‰£113ï¼š[è·¯å¾„æ€»å’Œ II](https://leetcode-cn.com/problems/path-sum-ii/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘å’Œä¸€ä¸ªç›®æ ‡å’Œï¼Œæ‰¾åˆ°æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚
  è¯´æ˜: å¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚
  
  è¾“å…¥ï¼šr = [5,4,8,11,None,13,4,7,2,None,None,None,None,5,1] sum = 22ï¼Œ
  è¾“å‡ºï¼š
  [
     [5,4,11,2],
     [5,8,4,5]
  ]
  ```

+ é¢˜è§£ï¼šå’Œ129é¢˜ä¸€æ ·

  ```python
  class Solution(object):
      def pathSum(self, root, targetSum):
          """
          :type root: TreeNode
          :type targetSum: int
          :rtype: List[List[int]]
          """
          self.ans = []
          def calc(root, targetSum, val_list):
              if not root:
                  return
              val_list.append(root.val)
              if not root.left and not root.right:
                  sumNum = sum(val_list)
                  if sumNum == targetSum:
                      self.ans.append(copy.deepcopy(val_list))
                  val_list.pop()
                  return
              calc(root.left, targetSum, val_list)
              calc(root.right, targetSum, val_list)
              val_list.pop() # å‰”é™¤å½“å‰èŠ‚ç‚¹ï¼Œå› ä¸ºéå†å®Œäº†
          if not root:
              return []
          calc(root, targetSum, [])
          return self.ans
  ```

### äºŒå‰æ ‘ä¸­æœ€å¤§è·¯å¾„å’Œ

+ åŠ›æ‰£124ï¼š[ äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

  ```
  è·¯å¾„ è¢«å®šä¹‰ä¸ºä¸€æ¡ä»æ ‘ä¸­ä»»æ„èŠ‚ç‚¹å‡ºå‘ï¼Œæ²¿çˆ¶èŠ‚ç‚¹-å­èŠ‚ç‚¹è¿æ¥ï¼Œè¾¾åˆ°ä»»æ„èŠ‚ç‚¹çš„åºåˆ—ã€‚åŒä¸€ä¸ªèŠ‚ç‚¹åœ¨ä¸€æ¡è·¯å¾„åºåˆ—ä¸­ è‡³å¤šå‡ºç°ä¸€æ¬¡ ã€‚è¯¥è·¯å¾„ è‡³å°‘åŒ…å«ä¸€ä¸ª èŠ‚ç‚¹ï¼Œä¸”ä¸ä¸€å®šç»è¿‡æ ¹èŠ‚ç‚¹ã€‚
  è·¯å¾„å’Œ æ˜¯è·¯å¾„ä¸­å„èŠ‚ç‚¹å€¼çš„æ€»å’Œã€‚
  ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶ æœ€å¤§è·¯å¾„å’Œ ã€‚
  
  ```

+ é¢˜è§£ï¼š[äºŒå‰æ ‘ä¸­çš„æœ€å¤§è·¯å¾„å’Œ](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/er-cha-shu-zhong-de-zui-da-lu-jing-he-by-leetcode-/)

  + äºŒå‰æ ‘ abcï¼Œa æ˜¯æ ¹ç»“ç‚¹ï¼ˆé€’å½’ä¸­çš„ rootï¼‰ï¼Œbc æ˜¯å·¦å³å­ç»“ç‚¹ï¼ˆä»£è¡¨å…¶é€’å½’åçš„æœ€ä¼˜è§£ï¼‰ã€‚æœ€å¤§çš„è·¯å¾„ï¼Œå¯èƒ½çš„è·¯å¾„æƒ…å†µï¼š
    + b + a + cã€‚
    + b + a + a çš„çˆ¶ç»“ç‚¹ã€‚
    + a + c + a çš„çˆ¶ç»“ç‚¹ã€‚

  ```python
  class Solution(object):
      def maxPathSum(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          self.ans = float('-inf')
          def helper(root):
              if not root:
                  return 0
  
              # å½“å·¦å³å­æ ‘çš„æœ€å¤§å€¼éƒ½å°äº0ï¼Œåˆ™å·¦å³å­æ ‘ä»¥ä¸‹çš„èŠ‚ç‚¹éƒ½ä¸é€‰æ‹©
              left = max(helper(root.left), 0)
              right = max(helper(root.right),0)
  
              left_val = left + root.val
              right_val = right + root.val
              sum_val = left + right + root.val
              self.ans = max(self.ans, sum_val)
              return max(left_val, right_val)
  
          if not root:
              return 0
          helper(root)
          return self.ans
  ```

### éªŒè¯äºŒå‰æœç´¢æ ‘

+ åŠ›æ‰£98ï¼š[éªŒè¯äºŒå‰æœç´¢æ ‘](https://leetcode-cn.com/problems/validate-binary-search-tree/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚
  å‡è®¾ä¸€ä¸ªäºŒå‰æœç´¢æ ‘å…·æœ‰å¦‚ä¸‹ç‰¹å¾ï¼š
  èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å«å°äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
  èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å«å¤§äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
  æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚
  
  è¾“å…¥: [5,1,4,null,null,3,6]ã€‚
  è¾“å‡ºï¼šfalse
  ```

+ é¢˜è§£ï¼š[ä¸­åºéå†è½»æ¾æ‹¿ä¸‹ï¼ŒğŸ¤·â€â™€ï¸å¿…é¡»ç§’æ‡‚ï¼](https://leetcode-cn.com/problems/validate-binary-search-tree/solution/zhong-xu-bian-li-qing-song-na-xia-bi-xu-miao-dong-/)

  + ä¸­åºéå†
  + å› ä¸ºäºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§æ˜¯ï¼šå½“å‰èŠ‚ç‚¹çš„å€¼å¤§äºå·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼ï¼Œå½“å‰èŠ‚ç‚¹çš„å€¼å°äºå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹çš„å€¼
  + æ‰€ä»¥å¯ä»¥åˆ©ç”¨ä¸­åºéå†ï¼šLTR => L < T < R

  ```python
  class Solution(object):
      def isValidBST(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          self.pre_val = float('-inf')
          def helper(root):
              if not root:
                  return True
              if not helper(root.left):
                  return False
              if root.val <= self.pre_val:
                  return False
              self.pre_val = root.val
              return helper(root.right)
          
          if not root:
              return False
          
          return helper(root)
  ```

### å¹³è¡¡äºŒå‰æ ‘

+ åŠ›æ‰£110ï¼š[å¹³è¡¡äºŒå‰æ ‘](https://leetcode-cn.com/problems/balanced-binary-tree/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯é«˜åº¦å¹³è¡¡çš„äºŒå‰æ ‘ã€‚
  æœ¬é¢˜ä¸­ï¼Œä¸€æ£µé«˜åº¦å¹³è¡¡äºŒå‰æ ‘å®šä¹‰ä¸ºï¼š
  ä¸€ä¸ªäºŒå‰æ ‘æ¯ä¸ªèŠ‚ç‚¹ çš„å·¦å³ä¸¤ä¸ªå­æ ‘çš„é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1 ã€‚
  
  è¾“å…¥ï¼šroot = [3,9,20,null,null,15,7]
  è¾“å‡ºï¼štrue
  
  è¾“å…¥ï¼šroot = [1,2,2,3,3,null,null,4,4]
  è¾“å‡ºï¼šfalse
  
  è¾“å…¥ï¼šroot = []
  è¾“å‡ºï¼štrue
  ```

+ é¢˜è§£ï¼š

  + ååºéå†ï¼Œè‡ªåº•å‘ä¸Š
  + è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹çš„å·¦èŠ‚ç‚¹å±‚æ•°å’Œå³èŠ‚ç‚¹å±‚æ•°
  + å·®å€¼å¤§äº1å°±ä¸æ˜¯å¹³è¡¡äºŒå‰æ ‘

  ```python
  class Solution(object):
      def isBalanced(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          self.ans = True
          def helper(root):
              if not root:
                  return 0
              if not root.left and not root.right:
                  return 1
              left = helper(root.left)
              right = helper(root.right)
              if abs(left-right) > 1:
                  self.ans = False
              return max(left, right) + 1
  
          if not root:
              return True
          helper(root)
          return self.ans
  ```

### é¢è¯•é¢˜ 17.12. BiNode

+ åŠ›æ‰£ï¼š[é¢è¯•é¢˜ 17.12. BiNode](https://leetcode-cn.com/problems/binode-lcci/)

  ```
  äºŒå‰æ ‘æ•°æ®ç»“æ„TreeNodeå¯ç”¨æ¥è¡¨ç¤ºå•å‘é“¾è¡¨ï¼ˆå…¶ä¸­leftç½®ç©ºï¼Œrightä¸ºä¸‹ä¸€ä¸ªé“¾è¡¨èŠ‚ç‚¹ï¼‰ã€‚å®ç°ä¸€ä¸ªæ–¹æ³•ï¼ŒæŠŠäºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºå•å‘é“¾è¡¨ï¼Œè¦æ±‚ä¾ç„¶ç¬¦åˆäºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œè½¬æ¢æ“ä½œåº”æ˜¯åŸå€çš„ï¼Œä¹Ÿå°±æ˜¯åœ¨åŸå§‹çš„äºŒå‰æœç´¢æ ‘ä¸Šç›´æ¥ä¿®æ”¹ã€‚
  è¿”å›è½¬æ¢åçš„å•å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ã€‚
  
  è¾“å…¥ï¼š [4,2,5,1,3,null,6,0]
  è¾“å‡ºï¼š [0,null,1,null,2,null,3,null,4,null,5,null,6]
  ```

+ é¢˜è§£ï¼š

  + åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§ï¼šL<T<Rï¼Œä½¿ç”¨ä¸­åºéå†ã€‚å†ç”¨ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆpre_nodeï¼‰ä¿å­˜å‰ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼
  + pre_node < root 
  + pre_node.left = None
  + pre_node.right = root
  + pre_node = root

  ```python
  class Solution(object):
      def convertBiNode(self, root):
          """
          :type root: TreeNode
          :rtype: TreeNode
          """
          self.head = TreeNode(-1)
          self.pre_node = None
          def helper(root):
              if not root:
                  return None
              helper(root.left)
              # ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
              if not self.pre_node:
                  self.head.right = root
              else:
                  self.pre_node.right = root
              root.left = None
              self.pre_node = root
              helper(root.right)
  
          helper(root)
          return self.head.right
  ```

### äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®

+ åŠ›æ‰£530ï¼š[äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·®](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

  ```
  ç»™ä½ ä¸€æ£µæ‰€æœ‰èŠ‚ç‚¹ä¸ºéè´Ÿå€¼çš„äºŒå‰æœç´¢æ ‘ï¼Œè¯·ä½ è®¡ç®—æ ‘ä¸­ä»»æ„ä¸¤èŠ‚ç‚¹çš„å·®çš„ç»å¯¹å€¼çš„æœ€å°å€¼ã€‚
  
  è¾“å…¥ï¼š
     1
      \
       3
      /
     2
  è¾“å‡ºï¼š
  1
  è§£é‡Šï¼š
  æœ€å°ç»å¯¹å·®ä¸º 1ï¼Œå…¶ä¸­ 2 å’Œ 1 çš„å·®çš„ç»å¯¹å€¼ä¸º 1ï¼ˆæˆ–è€… 2 å’Œ 3ï¼‰ã€‚
  ```

+ é¢˜è§£ï¼š

  + åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§ï¼šL<T<Rï¼Œä½¿ç”¨ä¸­åºéå†ã€‚å†ç”¨ä¸€ä¸ªèŠ‚ç‚¹ä¿å­˜å‰ä¸€ä¸ªèŠ‚ç‚¹çš„å€¼
  + åœ¨åšå·®å€¼ï¼Œä¿ç•™æœ€å°å€¼

  ```python
  class Solution(object):
      def getMinimumDifference(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          self.pre_val = None
          self.min_val = sys.maxint
  
          def helper(root):
              if not root:
                  return 
              helper(root.left)
  			# ç¬¬ä¸€ä¸ªèŠ‚ç‚¹
              if self.pre_val is None:
                  self.pre_val = root.val
              else:
                  self.min_val = min(self.min_val, abs(root.val - self.pre_val))
                  self.pre_val = root.val
  
              helper(root.right)
          
          if not root:
              return 0
          helper(root)
          return self.min_val
  ```

### äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ 

+ åŠ›æ‰£230ï¼š[äºŒå‰æœç´¢æ ‘ä¸­ç¬¬Kå°çš„å…ƒç´ ](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œå’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è®¾è®¡ä¸€ä¸ªç®—æ³•æŸ¥æ‰¾å…¶ä¸­ç¬¬ k ä¸ªæœ€å°å…ƒç´ ï¼ˆä» 1 å¼€å§‹è®¡æ•°ï¼‰ã€‚
  
  è¾“å…¥ï¼šroot = [3,1,4,null,2], k = 1
  è¾“å‡ºï¼š1
  
  è¾“å…¥ï¼šroot = [5,3,6,2,4,null,null,1], k = 3
  è¾“å‡ºï¼š3
  ```

+ é¢˜è§£ï¼š

  + åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§ï¼šL<T<Rï¼Œä½¿ç”¨ä¸­åºéå†ã€‚è¿™æ ·éå†å°±æ˜¯ä»å°åˆ°å¤§
  + ç„¶åè®°å½•å½“éå†åˆ°kçš„æ—¶å€™ï¼Œä¿å­˜è¯¥èŠ‚ç‚¹

  ```python
  class Solution(object):
      def kthSmallest(self, root, k):
          """
          :type root: TreeNode
          :type k: int
          :rtype: int
          """
          self.ans = None
          self.cnt = k
          def helper(root):
              if not root or self.ans is not None:
                  return 
              helper(root.left)
              self.cnt -= 1
              if self.cnt == 0:
                  self.ans = root.val
                  return
  
              helper(root.right)
  
          helper(root)
          return self.ans
  ```

### äºŒå‰æ ‘æœç´¢æ ‘è¿­ä»£å™¨ï¼ˆå­—èŠ‚ï¼‰

+ åŠ›æ‰£173ï¼š[äºŒå‰æœç´¢æ ‘è¿­ä»£å™¨](https://leetcode-cn.com/problems/binary-search-tree-iterator/)

+ é¢˜è§£ï¼š

  + å¯ä»¥ç”¨ä¸­åºéå†çš„æ–¹å¼æ˜¯äºŒå‰æœç´¢æ ‘è½¬æˆæœ‰åºçš„èŠ‚ç‚¹
  + ç”¨ä¸€ä¸ªé˜Ÿåˆ—ä¿å­˜æ’åºåçš„äºŒå‰æ ‘çš„ç»“æœ
  + ç„¶åç›´æ¥æ“ä½œé˜Ÿåˆ—

  ```python
  class BSTIterator(object):
  
      def __init__(self, root):
          """
          :type root: TreeNode
          """
          self._node_list = []
          self._inorder(root)
  
      def next(self):
          """
          :rtype: int
          """
          return self._node_list.pop(0)
  
  
      def hasNext(self):
          """
          :rtype: bool
          """
          return (len(self._node_list) != 0)
  
      def _inorder(self, root):
          if not root:
              return 
          self._inorder(root.left)
          self._node_list.append(root.val)
          self._inorder(root.right)
  ```

### äºŒå‰æœç´¢æ ‘çš„åç»§è€…

+ åŠ›æ‰£ï¼š[é¢è¯•é¢˜ 04.06. åç»§è€…](https://leetcode-cn.com/problems/successor-lcci/)

  ```
  è®¾è®¡ä¸€ä¸ªç®—æ³•ï¼Œæ‰¾å‡ºäºŒå‰æœç´¢æ ‘ä¸­æŒ‡å®šèŠ‚ç‚¹çš„â€œä¸‹ä¸€ä¸ªâ€èŠ‚ç‚¹ï¼ˆä¹Ÿå³ä¸­åºåç»§ï¼‰ã€‚
  å¦‚æœæŒ‡å®šèŠ‚ç‚¹æ²¡æœ‰å¯¹åº”çš„â€œä¸‹ä¸€ä¸ªâ€èŠ‚ç‚¹ï¼Œåˆ™è¿”å›nullã€‚
  
  è¾“å…¥: root = [2,1,3], p = 1
    2
   / \
  1   3
  è¾“å‡º: 2
  
  è¾“å…¥: root = [5,3,6,2,4,null,null,1], p = 6
        5
       / \
      3   6
     / \
    2   4
   /   
  1
  è¾“å‡º: null
  ```

+ é¢˜è§£ï¼š

  + åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„ç‰¹æ€§ï¼šL<T<Rï¼Œä½¿ç”¨ä¸­åºéå†ã€‚
  + ç”¨ä¸€ä¸ªpre_nodeä¿å­˜ç­‰äºpçš„èŠ‚ç‚¹
  + ä¸‹æ¬¡éå†æ—¶åˆ¤æ–­pre_nodeæ˜¯å¦ä¸ºNoneï¼Œä¸ä¸ºNoneåˆ™æ‰¾åˆ°ã€‚ç”¨ansä¿å­˜ç»“æœ

  ```python
  class Solution(object):
      def inorderSuccessor(self, root, p):
          """
          :type root: TreeNode
          :type p: TreeNode
          :rtype: TreeNode
          """
          self.pre_node = None
          self.ans = None
  
          def helper(root):
              if not root or self.ans is not None:
                  return 
  
              helper(root.left)
              
              # å·²ç»æ‰¾åˆ°ç»“æœï¼Œä¸åœ¨éå†
              if self.ans is not None:
                  return
                  
              if self.pre_node:
                  self.ans = root
                  return
  
              if root.val == p.val:
                  self.pre_node = root
              helper(root.right)
  
          if not root:
              return None
          helper(root)
          return self.ans
  ```

### äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

+ [äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

  ```
  ç»™å®šä¸€ä¸ªäºŒå‰æœç´¢æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚
  ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªç»“ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªç»“ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€
  
  è¾“å…¥: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
  è¾“å‡º: 6 
  è§£é‡Š: èŠ‚ç‚¹ 2 å’ŒèŠ‚ç‚¹ 8 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯ 6ã€‚
  
  è¾“å…¥: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
  è¾“å‡º: 2
  è§£é‡Š: èŠ‚ç‚¹ 2 å’ŒèŠ‚ç‚¹ 4 çš„æœ€è¿‘å…¬å…±ç¥–å…ˆæ˜¯ 2, å› ä¸ºæ ¹æ®å®šä¹‰æœ€è¿‘å…¬å…±ç¥–å…ˆèŠ‚ç‚¹å¯ä»¥ä¸ºèŠ‚ç‚¹æœ¬èº«ã€‚
  ```

+ é¢˜è§£ï¼š

  + åˆ©ç”¨äºŒå‰æœç´¢æ ‘çš„æ€§ï¼Œå·¦å­æ ‘ä¸€å®šæ¯”æ ¹èŠ‚ç‚¹å°ï¼Œå³å­æ ‘ä¸€å®šæ¯”æ ¹èŠ‚ç‚¹æ‰“
  + é‚£ä¹ˆæœ‰ä¸‰ç§æƒ…å†µï¼š
    + p.val > root.val and q.val > root.valï¼šéƒ½æ¯”rootå¤§ï¼Œåˆ™å…¬å…±ç¥–å…ˆåˆ™å†rootçš„å³å­æ ‘ä¸Š
    + p.val < root.val and q.val < root.valï¼šéƒ½æ¯”rootå°ï¼Œåˆ™å…¬å…±ç¥–å…ˆåˆ™å†rootçš„å·¦å­æ ‘ä¸Š
    + (p.val < root.val and p.val > root.val) or (p.val > root.val and p.val < root.val)ï¼šåœ¨rootèŠ‚ç‚¹çš„å·¦å³è¾¹ï¼Œåˆ™å…¬å…±ç¥–å…ˆåˆ™æ˜¯rootèŠ‚ç‚¹

  ```python
  class Solution(object):
      def lowestCommonAncestor(self, root, p, q):
          """
          :type root: TreeNode
          :type p: TreeNode
          :type q: TreeNode
          :rtype: TreeNode
          """
          def helper(root,p,q):
              if not root:
                  return None
              if root.val > p.val and root.val > q.val:
                  return helper(root.left, p, q)
              elif root.val < q.val and root.val < p.val:
                  return helper(root.right, p, q)
              else:
                  return root
          return helper(root, p, q)
  ```

  