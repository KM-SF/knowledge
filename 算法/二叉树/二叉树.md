### 总结

+ 深度优先搜索：递归

  + 先序遍历：

    ```python
    # 需要先记录结果，在进行递归（自顶向下）
    class Solution(object):
        def preorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    		# TODO: do work
            preorderTraversal(root.left)
            preorderTraversal(root.right)
    ```

  + 中序遍历：

    ```python
    class Solution(object):
        def inorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    
            inorderTraversal(root.left)
       		# TODO: do work
            inorderTraversal(root.right)
    ```

  + 后序遍历：

    ```python
    # 需要先进行递归，在进行记录结果（自底向下）
    class Solution(object):
        def postorderTraversal(self, root):
            """
            :type root: TreeNode
            :rtype: List[int]
            """
            if not root:
            	return
    
            postorderTraversal(root.left)
            postorderTraversal(root.right)
       		# TODO: do work
    ```

+ 广度优先搜索：用到队列（先进先出），处理每一层，将每一层节点入队。

  ```python
  class Solution(object):
      def levelOrder(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          if not root:
              return False
  
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              for _ in range(n):
                  node = qlist[0]
                  index = index_map[node]
                  qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
  
                  if right_node:
                      qlist.append(right_node)
                  
                  #TODO：do work
  
  ```

+ 将树转换成一个数组的形式，那么会有这个公式：假设root的下标为index（下标从0开始），那么root的left下标为index*2 + 1，root的right下标为index*2 + 2

+ 完全二叉树的定义：**它是一棵空树或者它的叶子节点只出在最后两层，若最后一层不满则叶子节点只在最左侧。**

+ 对于完全二叉树而言：就有数组的大小（总节点个数-1）等于最大的下标

+ **满二叉树的层数为h，则总节点数为：2^h - 1.**

### 类

```python
class TreeNode(object):
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

    @classmethod
    def build(cls, val_list):
        node_list = list()
        n = len(val_list)
        for index in range(n):
            val = val_list[index]
            node = TreeNode(val)
            node_list.append(node)
        for index in range(n):
            left_index = index * 2 + 1
            right_index = index * 2 + 2
            node = node_list[index]
            if left_index < n:
                left_node = node_list[left_index]
                node.left = left_node
            if right_index < n:
                right_node = node_list[right_index]
                node.right = right_node
        return node_list[0]

    @staticmethod
    def maxDepth(root):
        if not root:
            return 0

        left_cnt = TreeNode.maxDepth(root.left) + 1
        right_cnt = TreeNode.maxDepth(root.right) + 1
        return max(left_cnt, right_cnt)

    @staticmethod
    def printf(root):
        # 空格的次数
        depth = TreeNode.maxDepth(root)
        queue_list = [root]
        while len(queue_list):
            print("\t" * depth),
            node_cnt = len(queue_list)  # 当前这一层node的个数
            for _ in range(node_cnt):
                node = queue_list[0]
                queue_list.pop(0)
                left_node = node.left
                right_node = node.right
                if left_node:
                    queue_list.append(left_node)
                if right_node:
                    queue_list.append(right_node)
                print(node.val),
                print("\t" * depth),
            depth -= 1
            print("\n"),
```



### 二叉树最大深度

+ 力扣104：[二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

  ```
  给定一个二叉树，找出其最大深度。
  二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
  说明: 叶子节点是指没有子节点的节点。
  
  给定二叉树 [3,9,20,null,null,15,7]，
  返回它的最大深度 3 。
  ```

+ 题解：深度遍优先搜索

  ```python
  class Solution:
      def maxDepth(self, root):
          if root is None: 
              return 0 
  
  		left_height = self.maxDepth(root.left) + 1 
  		right_height = self.maxDepth(root.right) + 1 
  		return max(left_height, right_height) 
  ```

### 二叉树的最小深度

+ 力扣111：[二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

  ```python
  给定一个二叉树，找出其最小深度。
  最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
  
  输入：root = [3,9,20,null,null,15,7]
  输出：2
  
  输入：root = [2,null,3,null,4,null,5,null,6]
  输出：5
  ```

+ 题解：该问题实际就是问根节点到叶子的最短路径

  + 用一个值用于保存结果
  + 计算到叶子节点的层数（左右节点为None）
  + 保存最小值

  ```python
  class Solution(object):
      def minDepth(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def f(root, cnt, min_cnt):
              if not root.left and not root.right:
                  min_cnt = min(cnt, min_cnt)
                  return min_cnt
              cnt += 1
              if root.left:
                  min_cnt = f(root.left, cnt, min_cnt)
              if root.right:
                  min_cnt = f(root.right, cnt, min_cnt)
              return min_cnt
  
          if not root :
              return 0
          cnt = 1
          min_cnt = sys.maxint
          min_cnt = f(root, cnt, min_cnt)
          return min_cnt
  ```

### 对称二叉树

+ 力扣101：[对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

  ```
  给定一个二叉树，检查它是否是镜像对称的。
  
  例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
  ```

+ 题解：

  + 每个树的右子树都与另一个树的左子树镜像对称
  + 它们的两个根结点具有相同的值

  ```python
  class Solution(object):
      def isSymmetric(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.right) and check(pnode.right, qnode.left)
  
  
          if not root:
              return False
  
          return check(root.left, root.right)
  ```

### 相同树

+ 力扣100：[相同的树](https://leetcode-cn.com/problems/same-tree/)

  ```
  给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
  如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

  输入：p = [1,2,3], q = [1,2,3]
  输出：true
  
  输入：p = [1,2], q = [1,null,2]
  输出：false
  ```
  
+ 题解：这道题跟上面到对称二叉树查不到

  + 每个树的右（左）子树都与另一个树的右（左）子树相同
  + 它们的两个根结点具有相同的值

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          return check(p,q)
  ```

### 另一个树的子树

+ 力扣572：[另一个树的子树](https://leetcode-cn.com/problems/subtree-of-another-tree/)

  ```
  给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。
  
  输入：s = [3,4,5,1,2] t = [4,1,2]
  输出：true，因为 t 与 s 的一个子树拥有相同的结构和节点值。
  
  输入：s = [3,4,5,1,2,null,null,null,null,0] t = [4,1,2]
  输出：false
  
  ```

+ 题解：这道题跟上面相同树一样

  + 结合上面的相同树，将s的每个节点当成root，进行比较

  ```python
  class Solution(object):
      def isSubtree(self, s, t):
          """
          :type s: TreeNode
          :type t: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              return check(pnode.left, qnode.left) and check(pnode.right, qnode.right)
  
          qlist = [s]
          while len(qlist):
              n = len(qlist)
              for index in range(n):
                  node = qlist[0]
                  qlist.pop(0)
                  if check(node, t):
                      return True
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
          return False
  		"""
  		深度搜索
  		# 遍历root节点，左节点，右节点
          if not s:
              return False
          return check(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
  		"""
  ```

### 同构树

+ 腾讯题：[同构树-TX](https://blog.csdn.net/weixin_43088751/article/details/104079228)

  ```
  简单来说，对于二叉树，如果一个树的孩子节点通过左右变换可以变成另外一个树，那么这两个树是同构的。
  ```

+ 题解：

  ```python
  class Solution(object):
      def isSameTree(self, p, q):
          """
          :type p: TreeNode
          :type q: TreeNode
          :rtype: bool
          """
          def check(pnode, qnode):
              # 都到空节点则认为一样
              if not pnode and not qnode:
                  return True
              # 有一个非空，另外空，则认为不一样
              if not pnode or not qnode:
                  return False
              # 有值不同也不一样
              if pnode.val != qnode.val:
                  return False
  
              # 同构树下面两种情况其中1中
              # 1.左子树等于左子树，右子树等于右子树 
              # 2.左子树等于右子树，左子树等于右子树
              return (check(pnode.left, qnode.left) and check(pnode.right, qnode.right)) or (check(pnode.left, qnode.right) and check(pnode.right, qnode.left))
  
          return check(p,q)
  ```

### 翻转二叉树

+ 力扣226：[翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

  ```
  翻转一棵二叉树。
  
  输入：[4,2,7,1,3,6,9]
  输出：[4,7,2,9,6,3,1]
  ```

+ 题解：利用前序遍历（TLR）

  + 先遍历到root
  + 然后交换root的left和right（交换后下面的结构就已经变换了，可以画图）

  ```python
  class Solution(object):
      def invertTree(self, root):
          """
          :type root: TreeNode
          :rtype: TreeNode
          """
          if not root:
              return
  
          node = root.left
          root.left = root.right
          root.right = node
          self.invertTree(root.left)
          self.invertTree(root.right)
          return root
  ```

### 左叶子之和

+ 力扣404[404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

  ```
  计算给定二叉树的所有左叶子之和。
  
  输入：[3,9,20,None,None,15,7]
  输出：24
  ```

+ 题解：

  + 判断一个节点的左节点是不是叶子节点，如果是则累加该节点的值

  ```python
  class Solution(object):
      def sumOfLeftLeaves(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def isLeafNode(root):
              if not root.left and not root.right:
                  return True
              return False
  
          if not root:
              return 0
  
          ans = 0
          if root.left:
              if isLeafNode(root.left):
                  ans = root.left.val
              ans += self.sumOfLeftLeaves(root.left)
          # 上面已经加过一次了，这里就只需要计算right的情况
          if root.right:
              ans += self.sumOfLeftLeaves(root.right)
  
          return ans
  ```

### 二叉树的完全性检验

+ 力扣958：[二叉树的完全性检验](https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree/)

  ```
  给定一个二叉树，确定它是否是一个完全二叉树。
  百度百科中对完全二叉树的定义如下：
  若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）
  
  输入：[1,2,3,4,5,6]
  输出：true
  解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。
  
  输入：[1,2,3,4,5,null,7]
  输出：false
  解释：值为 7 的结点没有尽可能靠向左侧。
  ```

+ 题解：

  + 将树转换成一个数组的形式，那么会有这个公式：**假设root的下标为index（下标从0开始），那么root的left下标为index*2 + 1，root的right下标为index*2 + 2**
  + **对于完全二叉树而言：就有数组的大小（总节点个数-1）等于最大的下标**

  ```python
  class Solution(object):
      def isCompleteTree(self, root):
          """
          :type root: TreeNode
          :rtype: bool
          """
          if not root:
              return False
  
          cnt = 0  # 计算总个数
          index_map = {root: 0} # 保存节点对应的下标
          max_index = 0 # 记录最大下标
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              for _ in range(n):
                  cnt += 1
                  node = qlist[0]
                  index = index_map[node]
                  qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                      left_index = index * 2 + 1
                      index_map[left_node] = left_index
                      max_index = left_index
  
                  if right_node:
                      qlist.append(right_node)
                      right_index = index * 2 + 2
                      index_map[right_node] = right_index
                      max_index = right_index
  
  		# 这里是用总个数，所以要总个数-1，因为下标从0开始
          return max_index == cnt-1
  ```


### 完全二叉树的节点个数

+ 力扣222：[完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

  ```
  给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
  
  完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
  
  输入：root = [1,2,3,4,5,6]
  输出：6
  
  输入：root = []
  输出：0
  
  输入：root = [1]
  输出：1
  ```

+ 题解：[题解](https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/c-san-chong-fang-fa-jie-jue-wan-quan-er-cha-shu-de/)

  + **这是一棵完全二叉树**：除最后一层外，其余层全部铺满；且最后一层向左停靠
  + 如果根节点的左子树深度等于右子树深度，则说明**左子树为满二叉树**（可以画图）
  + 如果根节点的左子树深度大于右子树深度，则说明**右子树为满二叉树**（可以画图）
  + 满二叉树的层数为h，则总节点数为：2^h - 1.（1 << depth - 1）
  + 那么可以得到一个公式（获得当前root总节点个数）：root = （1 << left_depth | right_depth - 1）+ fun(root.right | root.left)  + 1
    + 左子树（右子树）满二叉树的总节点数 + 递归右子树（左子树）总节点数 + 1（root节点）

  ```python
  class Solution(object):
      def countNodes(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def getDepth(root):
              if not root:
                  return 0
  
              cnt = 0
              while root:
                  root = root.left
                  cnt += 1
              return cnt
  
          if not root:
              return 0
          left_depth = getDepth(root.left)
          right_depth = getDepth(root.right)
          # 根据完全二叉树的性质：
          # 如果左子树高度等于右子树高度。则左子树为满二叉树。
          # 如果左子树高度不等于右子树高度。则右子树为满二叉树。
          # 满二叉树的总结点数：2^h - 1 （深度从1开始计算）
          if left_depth == right_depth:
              # 该root节点的个数等于：左子树满二叉树的总个数 + 递归右子树（非满二叉树） + 1（root节点）
              return self.countNodes(root.right) + (1 << left_depth)  # (1 << left_depth -1) + 1
          else:
              # 右子树是满二叉树
              return self.countNodes(root.left) + (1 << right_depth)  # (1 << right_depth -1) + 1
  ```

### 二叉树的直径

+ 力扣543：[二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

  ```
  给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
  注意：两结点之间的路径长度是以它们之间边的数目表示。
  
  输入：root = [1,2,3,4,5]
  输出：3  它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
  ```

+ 题解：[题解](https://leetcode-cn.com/problems/diameter-of-binary-tree/solution/er-cha-shu-de-zhi-jing-by-leetcode-solution/)

  + 对于该节点的左儿子向下遍历经过最多的节点数 LL （即以左儿子为根的子树的深度） 
  + 其右儿子向下遍历经过最多的节点数 R （即以右儿子为根的子树的深度）
  + 那么以该节点为起点的路径经过节点数的最大值即为 L+R+1
  + 记节点node 为起点的路径经过节点数的最大值为node_max，那么二叉树的直径就是所有节点node_max-1

  ```python
  class Solution(object):
      def diameterOfBinaryTree(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          def maxDepth(root):
              if not root:
                  return 0
              # 左子树为根的深度
              left_depth = maxDepth(root.left)
              # 右子树为根的深度
              right_depth = maxDepth(root.right)
              # 该节点为根，其左右子树最深高度和，跟max_depth比较
              self.ans = max(self.ans, left_depth + right_depth + 1)
              # 返回该节点为根的最深高度
              return max(left_depth, right_depth) + 1
          if not root:
              return 0
          self.ans = 0
          maxDepth(root)
          return self.ans - 1 # 注意：两结点之间的路径长度是以它们之间边的数目表示。所以要深度-1
  ```

### 二叉树的坡度

+ 力扣563：[二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)

  ```
  给定一个二叉树，计算 整个树 的坡度 。
  一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。
  整个树 的坡度就是其所有节点的坡度之和。
  
  输入：root = [1,2,3]
  输出：1
  解释：
  节点 2 的坡度：|0-0| = 0（没有子节点）
  节点 3 的坡度：|0-0| = 0（没有子节点）
  节点 1 的坡度：|2-3| = 1（左子树就是左子节点，所以和是 2 ；右子树就是右子节点，所以和是 3 ）
  坡度总和：0 + 0 + 1 = 1
  
  输入：root = [4,2,9,3,5,null,7]
  输出：15
  解释：
  节点 3 的坡度：|0-0| = 0（没有子节点）
  节点 5 的坡度：|0-0| = 0（没有子节点）
  节点 7 的坡度：|0-0| = 0（没有子节点）
  节点 2 的坡度：|3-5| = 2（左子树就是左子节点，所以和是 3 ；右子树就是右子节点，所以和是 5 ）
  节点 9 的坡度：|0-7| = 7（没有左子树，所以和是 0 ；右子树正好是右子节点，所以和是 7 ）
  ```

+ 题解：

  + 用于一个全局变量保存每个坡度的值
  + 递归函数的返回值：左子树的和+右子树的和+该节点的值（用于该节点的父节点来做差值）

  ```python
  class Solution(object):
      def findTilt(self, root):
          """
          :type root: TreeNode
          :rtype: int
          """
          self.ans = 0
          def calc(root):
              if not root:
                  return 0
              left_val = calc(root.left)
              right_val = calc(root.right)
              self.ans += abs(left_val - right_val)
              return left_val + right_val + root.val
          
          if not root:
              return 0
          calc(root)
          return self.ans
  ```


### 二叉树的层序遍历

+ 力扣102：[二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

  ```
  给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。
  
  二叉树：[3,9,20,null,null,15,7],
  返回其层序遍历结果：
  [
    [3],
    [9,20],
    [15,7]
  ]
  ```

+ 题解：

  + 首先根元素入队
  + 当队列不为空的时候
    - 求当前队列的长度 n (该层的节点个数)
    - 依次从队列中取 n 个元素进行拓展，每个元素得到其左节点和右节点。左右节点不为None则再加入队列中，然后进入下一次迭代

  ```python
  class Solution(object):
      def levelOrder(self, root):
          """
          :type root: TreeNode
          :rtype: List[List[int]]
          """
          if not root:
              return []
          
          ans = []
          qlist = [root]
          while len(qlist): # 遍历层数
              level_list = []
              n = len(qlist)
              for _ in range(n): # 遍历每层节点个数
                  node = qlist.pop(0) # 每次队列取出队头
                  level_list.append(node.val)
  
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
              ans.append(level_list)
  
          return ans
  ```

### 二叉树的前序遍历

+ 力扣144：[二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

  ```
  给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
  
  输入：root = [1,null,2,3]
  输出：[1,2,3]
  ```

+ 题解：

  + 二叉树的前序遍历：输出根节点->左子树->右子树。（TLR）
  + 实现方式有两种：递归（已经在总结给出，较为常用），这里给出非递归
  + 根据上面的规律，我们可以用一个栈进行保存
  + 获取根节点，输出根节点的值
  + 获取根节点的左子树，右子树
  + 如果右子树不为None，则右子树先入栈（因为较后输出）
  + 如果左子树不为None，则左子树再入栈
  + 依次循环，结束条件是栈为空

  ```python
  class Solution(object):
      def preorderTraversal(self, root):
          """
          :type root: TreeNode
          :rtype: List[int]
          """
          if not root:
              return []
          
          ans = []
          slist = [root]
          while len(slist):
              node = slist.pop(0)
              ans.append(node.val)
              left_node = node.left
              right_node = node.right
              if right_node:
                  slist.insert(0,right_node)
              if left_node:
                  slist.insert(0,left_node)
  
          return ans
  ```

### 二叉树的后序遍历

+ 力扣145：[二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

  ```
  给定一个二叉树，返回它的 后序 遍历。
  
  输入: [1,null,2,3] 
  输出: [3,2,1]
  ```

+ 题解：

  + 二叉树的前序遍历：输出左子树->右子树->根节点。（LRT）
  + 我们可以看前序遍历（TLR）和后序遍历（LRT）很像，只是T放在前后问题
  + 那么我们可以看：TLR -> TRL -> LRT
  + 那是不是通过修改下前序遍历，左子树和右子树入栈的顺序得到TRL，然后再反转下结果就可以到

  ```python
  class Solution(object):
      def levelOrder(self, root):
          """
          :type root: TreeNode
          :rtype: List[List[int]]
          """
          if not root:
              return []
          
          ans = []
          qlist = [root]
          while len(qlist):
              level_list = []
              n = len(qlist)
              for _ in range(n):
                  node = qlist.pop(0)
                  level_list.append(node.val)
  
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
              ans.append(level_list)
  
          return ans
  ```

### 二叉树的中序遍历

+ 力扣94：[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

  ```
  给定一个二叉树的根节点 root ，返回它的 中序 遍历。
  
  输入：root = [1,null,2,3]
  输出：[1,3,2]
  ```

+ 题解：[颜色标记法-一种通用且简明的树遍历方法](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/)

  + 使用颜色标记节点的状态，新节点为0，已访问的节点为1。
  + 如果遇到的节点为0，则将其标记为1，然后将其右子节点、自身、左子节点依次入栈。
  + 如果遇到的节点为1，则将节点的值输出。
  + 前序遍历和后序遍历都可以用该方法

  ```python
  class Solution(object):
      def inorderTraversal(self, root):
          """
          :type root: TreeNode
          :rtype: List[int]
          """
          if not root:
              return []
          
          ans = []
          # flag 0表示新节点
          # flag 1表示已访问节点
          slist = [(root, 0)]
          while len(slist):
              node, flag = slist.pop()
              if node is None:
                  continue
              if flag == 0:
                  left_node = node.left
                  right_node = node.right
                  slist.append((right_node, 0)) # 右子树入栈，因为最后输出
                  slist.append((node, 1)) # 自己再次入栈，用于下次输出
                  slist.append((left_node, 0)) # 左子树入栈，用于下次遍历
              else:
                  ans.append(node.val)
  
          return ans
  ```


### 二叉树的右视图

+ 力扣199：[二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

  ```
  给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
  
  输入: [1,2,3,null,5,null,4]
  输出: [1, 3, 4]
  ```

+ 题解：

  + 利用层次遍历
  + 每一层最后一个节点的值加入到结果

  ```python
  class Solution(object):
      def rightSideView(self, root):
          """
          :type root: TreeNode
          :rtype: List[int]
          """
          if not root:
              return []
          
          ans = []
          qlist = [root]
          while len(qlist):
              n = len(qlist)
              last_node = qlist[-1]
              ans.append(last_node.val)
              for _ in range(n):
                  node = qlist.pop(0)
                  left_node = node.left
                  right_node = node.right
                  if left_node:
                      qlist.append(left_node)
                  if right_node:
                      qlist.append(right_node)
  
          return ans
  ```

### 二叉树的最近公共祖先

+ 力扣236：[二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

  ```
  给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
  
  百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
  
  输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
  输出：3
  解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
  
  输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
  输出：5
  解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
  
  输入：root = [1,2], p = 1, q = 2
  输出：1
  ```

+ 题解：[二叉树的最近公共祖先（后序遍历 DFS ，清晰图解）](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-xian-hou-xu/)

  + 若 root是p,q的最近公共祖先 ，则只可能为以下情况之一：
  + p 和 q 在 root的子树中，且分列 root 的 异侧（即分别在左、右子树中）；
  + p = root ，且q在root的左或右子树中；
  + q = root ，且p在root的左或右子树中；

  ```python
  class Solution(object):
      def lowestCommonAncestor(self, root, p, q):
          """
          :type root: TreeNode
          :type p: TreeNode
          :type q: TreeNode
          :rtype: TreeNode
          """
          if not root:
              return None
              
          if root == p or root == q: 
              return root
              
          left_node = self.lowestCommonAncestor(root.left, p , q)
          right_node = self.lowestCommonAncestor(root.right, p , q)
          
          # 当left和right同时不为空 ：说明p,q 分列在root的异侧（分别在左/右子树），因此root为最近公共祖先，返回 root；
          if left_node and right_node: 
              return root
  
  		# 当left和right同时为空 ：说明 root 的左/右子树中都不包含p,q，返回 null
          if not left_node and not right_node:
              return None
              
          # 当left为空，right不为空：p,q 都不在root的左子树中，直接返回right 。具体可分为两种情况：
          # p,q其中一个在root的右子树中，此时right指向p（假设为p）
          # p,q两节点都在root的右子树中，此时right指向最近公共祖先节点 
          if not left_node and right_node:
              return right_node
          # 同上
          if not right_node and left_node:
              return left_node
  ```

### 路径总和

+ 力扣112：[ 路径总和](https://leetcode-cn.com/problems/path-sum/)

  ```
  给你二叉树的根节点 root 和一个表示目标和的整数 targetSum ，判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 
  叶子节点 是指没有子节点的节点。
  
  输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
  输出：true
  
  输入：root = [1,2,3], targetSum = 5
  输出：false
  
  输入：root = [1,2], targetSum = 0
  输出：false
  ```

+ 题解：用前序遍历

  + 每次都减去加当前节点的值
  + 当递归到根节点的时候，判断当前节点的值是不是和目标值一样

  ```python
  # Definition for a binary tree node.
  # class TreeNode(object):
  #     def __init__(self, val=0, left=None, right=None):
  #         self.val = val
  #         self.left = left
  #         self.right = right
  class Solution(object):
      def hasPathSum(self, root, targetSum):
          """
          :type root: TreeNode
          :type targetSum: int
          :rtype: bool
          """
  		if not root:
              return False
          if not root.left and not root.right:
              return targetSum == root.val
          return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)
  ```

### 二叉树的所有路径

+ 力扣257：[二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

  ```
  给定一个二叉树，返回所有从根节点到叶子节点的路径。
  说明: 叶子节点是指没有子节点的节点。
  
  输出: ["1->2->5", "1->3"]
  解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
  ```

+ 题解：前序遍历

  ```python
  class Solution(object):
      def binaryTreePaths(self, root):
          """
          :type root: TreeNode
          :rtype: List[str]
          """
          self.ans = []
          def paths(root, node_string):
              if not root:
                  return
              if not root.left and not root.right:
                  node_string += "{}".format(root.val)
                  self.ans.append(node_string)
                  return
              node_string += "{}->".format(root.val)
              paths(root.left, node_string)
              paths(root.right, node_string)
  
          if not root :
              return []
          paths(root, "")
          return self.ans
  ```

  