# C++基础知识

## 以下四行代码的区别

+ const char * arr = "123";
  + 字符串123保存在常量区，const本来是修饰arr指向的值不能通过arr去修改，但是字符串“123”在常量区，本来就不能改变，所以加不加const效果都一样

+ char * brr = "123";
  + 字符串123保存在常量区，这个arr指针指向的是同一个位置，同样不能通过brr去修改"123"的值

+ const char crr[] = "123";
  + 这里123本来是在栈上的，但是编译器可能会做某些优化，将其放到常量区

+ char drr[] = "123";
  + 字符串123保存在栈区，可以通过drr去修改

## const关键字

Const 是C++中常用的类型修饰符,常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。

1. const修饰普通类型的变量（与宏对比的优点，可以进行类型检查，保护被修饰的变量，防止被意外修改）
2. const 修饰指针变量有三种情况：
   + const 修饰指针指向的内容，则内容为不可变量。
   + const 修饰指针，则指针为不可变量。
   + const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。
3. const参数传递有三种情况
   + 值传递的const传递，一般这种情况不需要const修饰，因为函数会自动产生临时变量复制实参值。
   + 当 const 参数为指针时，可以防止指针被意外篡改。
   + 自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。
4. const函数返回值有三种情况
   + const 修饰内置类型的返回值，修饰与不修饰返回值作用一样。
   + const 修饰自定义类型的作为返回值，此时返回的值不能作为左值使用，既不能被赋值，也不能被修改。
   + const 修饰返回的指针或者引用，是否返回一个指向 const 的指针，取决于我们想让用户干什么。
5. const修饰类成员函数
   + const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。const类成员函数可以作为重载
   + const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。

## static关键字

1. 全局静态变量
   + 在全局变量前加上关键字static，全局变量就定义成一个全局静态变量.
   + 内存中的位置：静态存储区，在整个程序运行期间一直存在。
   + 初始化：未经初始化的全局静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化）；
   + 作用域：全局静态变量在声明他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。
2. 局部静态变量
   + 在局部变量之前加上关键字static，局部变量就成为一个局部静态变量。
   + 内存中的位置：静态存储区
   + 初始化：未经初始化的局部静态变量会被自动初始化为0（自动对象的值是任意的，除非他被显式初始化），只会被初始化一次
   + 作用域：作用域仍为局部作用域，当定义它的函数或者语句块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变；
3. 静态函数
   + 在函数返回类型前加static，函数就定义为静态函数。函数的定义和声明在默认情况下都是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。
   + 作用域：函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；
   + warning：不要再头文件中声明static的全局函数，不要在cpp内声明非static的全局函数，如果你要在多个cpp中复用该函数，就把它的声明提到头文件里去，否则cpp内部声明需加上static修饰；
4. 类的静态成员
   + 在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，**静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用**
5. 类的静态函数
   + 静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。该函数没有this指针
   + **在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员（这点非常重要）。如果静态成员函数中要引用非静态成员时，可通过对象来引用。**从中可看出，调用静态成员函数使用如下格式：<类名>::<静态成员函数名>(<参数表>);

## volatile

https://zhuanlan.zhihu.com/p/62060524

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改。比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。

当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。例如：

```cpp
volatile int i=10;
int a = i;
int b = i; 
```

volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。

这说明这个 volatile 关键字发挥了它的作用。其实不只是“内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方：

**1) 中断服务程序中修改的供其它程序检测的变量需要加volatile；**

**2) 多任务环境下各任务间共享的标志应该加volatile；**

**3) 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；**

## 乱序重排/内存屏障

https://blog.csdn.net/dd864140130/article/details/56494925

现在来总结下所有可能发生乱序执行的情况:

- 现代处理器采用指令并行技术,在不存在数据依赖性的前提下,处理器可以改变语句对应的机器指令的执行顺序来提高处理器执行速度
- 现代处理器采用内部缓存技术,导致数据的变化不能及时反映在主存所带来的乱序.
- 现代编译器为优化而重新安排语句的执行顺序

尽管我们看到乱序执行初始目的是为了提高效率,但是它看来其好像在这多核时代不尽人意,其中的某些”自作聪明”的优化导致多线程程序产生各种各样的意外.因此有必要存在一种机制来消除乱序执行带来的坏影响,也就是说应该允许程序员显式的告诉处理器对某些地方禁止乱序执行.这种机制就是所谓内存屏障.不同架构的处理器在其指令集中提供了不同的指令来发起内存屏障,对应在编程语言当中就是提供特殊的关键字来调用处理器相关的指令.

## new/delete与malloc/free的区别

1. new分配内存按照数据类型进行分配，malloc分配内存按照指定的大小分配；

2. new返回的是指定对象的指针，而malloc返回的是void*，因此malloc的返回值一般都需要进行类型转化。

3. new不仅分配一段内存，而且会调用构造函数，malloc只分配内存。

4. new分配的内存要用delete销毁，malloc要用free来销毁；delete销毁的时候会调用对象的析构函数，而free则不会。

5. new是一个操作符可以重载，malloc是一个库函数。

6. malloc分配的内存不够的时候，可以用realloc扩容。扩容的原理？new没用这样操作。

7. new如果分配失败了会抛出bad_malloc的异常，而malloc失败了会返回NULL。

8. 申请数组时： new[]一次分配所有内存，多次调用构造函数，搭配使用delete[]，delete[]多次调用析构函数，销毁数组中的每个对象。而malloc则只能sizeof(int) * n。

## C++和C的区别

+ 设计思想上：C++是面向对象的语言，而C是面向过程的结构化编程语言
+ 语法上：
  + C++具有封装、继承和多态三种特性
  + C++相比C，增加多许多类型安全的功能，比如强制类型转换、
  + C++支持范式编程，比如模板类、函数模板等

## c++中四种cast转换

**C++中四种类型转换是：static_cast, dynamic_cast, const_cast, reinterpret_cast**

**C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。**

1. const_cast：用于将const变量转为非const
2. static_cast：用于各种隐式转换，比如非const转const，void*转指针等, static_cast能用于多态向上转化，如果向下转能成功但是不安全，结果未知；
3. dynamic_cast：用于动态类型转换。**只能用于含有虚函数的类，用于类层次间的向上和向下转化。只能转指针或引用。**向下转化时，如果是非法的对于指针返回NULL，对于引用抛异常。要深入了解内部转换的原理。**向上转换：指的是子类向基类的转换。向下转换：指的是基类向子类的转换。它通过判断在执行到该语句的时候变量的运行时类型和要转换的类型是否相同来判断是否能够进行向下转换。**
4. reinterpret_cast：几乎什么都可以转，比如将int转指针，可能会出问题，尽量少用

## C/C++ 中指针和引用的区别

+ 引用就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。引用的声明方法：类型标识符 &引用名=目标变量名；
+ 指针利用地址，它的值直接指向存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。

1. 指针有自己的一块空间，而引用只是一个别名；
2. 使用sizeof看一个指针的大小是4，而引用则是被引用对象的大小；
3. 指针可以被初始化为NULL，而引用必须被初始化且必须是一个已有对象 的引用；
4. 作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引 用的修改都会改变引用所指向的对象；
5. 指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变；
6. 指针可以有多级指针（**p），而引用至于一级；
7. 指针和引用使用++运算符的意义不一样；
9. **如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄露。**

## 数组和指针的区别

|                             指针                             |                 数组                 |
| :----------------------------------------------------------: | :----------------------------------: |
|                        保存数据的地址                        |               保存数据               |
| 间接访问数据，首先获得指针的内容，然后将其作为地址，从该地址中提取数据 |            直接访问数据，            |
|                    通常用于动态的数据结构                    | 通常用于固定数目且数据类型相同的元素 |
|               通过Malloc分配内存，free释放内存               |           隐式的分配和删除           |
|                通常指向匿名数据，操作匿名函数                |            自身即为数据名            |

## 野指针是什么

+ 野指针就是指向一个已删除的对象或者未申请访问受限内存区域的指针

## 函数指针

+ 函数指针是指向函数的指针变量。函数指针本身首先是一个指针变量，该指针变量指向一个具体的函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。
+ C在编译时，**每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。**有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。
+ 用途：调用函数和做函数的参数，比如回调函数。

```C++
char * fun(char * p)  {…}       // 函数fun
char * (*pf)(char * p);             // 函数指针pf
pf = fun;                        // 函数指针pf指向函数fun
pf(p);                        // 通过函数指针pf调用函数fun
```

## 函数栈空间的最大值

+ 默认是1M，不过可以调整

## extern“C”

C++调用C函数需要extern C，因为C语言没有函数重载。

## C++源文件从文本到可执行文件经历的过程

+ 对于C++源文件，从文本到可执行文件一般需要四个过程：
  + 预处理阶段：对源代码文件中文件包含关系（头文件）、预编译语句（宏定义）进行分析和替换，生成预编译文件。
  + 编译阶段：将经过预处理后的预编译文件转换成特定汇编代码，生成汇编文件
  + 汇编阶段：将编译阶段生成的汇编文件转化成机器码，生成可重定位目标文件
  + 链接阶段：将多个目标文件及所需要的库连接成最终的可执行目标文件

## 为什么析构函数必须是虚函数

+ **将可能会被继承的父类的析构函数设置为虚函数**，可以保证当我们new一个子类，然后**使用基类指针指向该子类对象**，释放基类指针时可以释放掉子类的空间，防止内存泄漏。

## 为什么C++默认的析构函数不是虚函数

+ C++默认的析构函数不是虚函数是**因为虚函数需要额外的虚函数表和虚表指针，占用额外的内存。而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存。**因此C++默认的析构函数不是虚函数，而是**只有当需要当作父类时，设置为虚函数。**

## C++中析构函数的作用

+ 析构函数与构造函数对应，当对象结束其生命周期，如对象所在的函数已调用完毕时，系统会自动执行析构函数。
+ 析构函数名也应与类名相同，只是在函数名前面加一个位取反符~，例如~stud( )，以区别于构造函数。**它不能带任何参数，也没有返回值（包括void类型）。只能有一个析构函数，不能重载。**
+ **如果用户没有编写析构函数，编译系统会自动生成一个缺省的析构函数（即使自定义了析构函数，编译器也总是会为我们合成一个析构函数，并且如果自定义了析构函数，编译器在执行时会先调用自定义的析构函数再调用合成的析构函数），它也不进行任何操作。所以许多简单的类中没有用显式的析构函数。**
+ 如果一个类中有指针，且在使用的过程中动态的申请了内存，那么最好显示构造析构函数在销毁类之前，释放掉申请的内存空间，避免内存泄漏。
+ **类析构顺序：1）派生类本身的析构函数；2）对象成员析构函数；3）基类析构函数。**

## 静态函数和虚函数的区别

+ 静态函数在编译的时候就已经确定运行时机，虚函数在运行的时候动态绑定。虚函数因为用了虚函数表机制，调用的时候会增加一次内存开销

## 重载和覆盖

+ 重载：两个函数名相同，但是参数列表不同（个数，类型），返回值类型没有要求，带没带const，在同一作用域中
+ 重写：子类继承了父类，父类中的函数是虚函数，在子类中重新定义了这个虚函数，这种情况是重写

## 隐藏和覆盖

覆盖指的是子类覆盖父类函数（被覆盖），特征是：
1.分别位于子类和父类中
2.函数名字与参数都相同
3.父类的函数是虚函数（virtual）

隐藏指的是子类隐藏了父类的函数（还存在），具有以下特征：
子类的函数与父类的名称相同，但是参数不同，父类函数被隐藏
子类函数与父类函数的名称相同，参数也相同，但是父类函数没有virtual，父类函数被隐藏

总结：
IF 子类的函数与父类的名称相同，但是参数不同

　　父类函数被隐藏

ELSE IF 子类函数与父类函数的名称相同&&参数也相同&&但是父类函数没有virtual

　　父类函数被隐藏

ELSE IF 子类函数与父类函数的名称相同&&参数也相同&&但是父类函数有virtual

　　父类函数被覆盖

## 纯虚函数

+ 纯虚函数声明如下： **virtual void funtion1()=0;** 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
+ 编译器要求在派生类中必须予以重写以实现多态性。**同时含有纯虚拟函数的类称为抽象类，它不能生成对象。**

## 抽象类

抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。

- **抽象类的定义：**称带有纯虚函数的类为抽象类。
- **抽象类的作用：**抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
- **使用抽象类时注意：**
  - 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。
  - 抽象类是不能定义对象的。

## 虚函数和纯虚函数的区别

+ 虚函数，不代表函数为不被实现的函数。是为了允许用基类的指针来调用子类的这个函数。

+ 纯虚函数，才代表函数没有被实现。纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
+ 纯虚函数声明如下： **virtual void funtion1()=0;** 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
+ 虚函数声明如下：**virtual ReturnType FunctionName(Parameter);** 虚函数必须实现，如果不实现，编译器将报错
+ 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
+ 实现了纯虚函数的子类，该纯虚函数在子类中就编程了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
+ 虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
+ 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
+ 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
+ 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

## 虚函数和多态

+ 多态的实现主要分为**静态多态和动态多态**
  + 静态多态主要是通过**重载和模板技术**实现，在编译的时候确定
  + 动态多态是用虚函数机制实现的**（覆盖）**，在运行期间动态绑定。举个例子：一个父类类型的指针指向一个子类对象时候，使用父类的指针去调用子类中重写了的父类中的虚函数的时候，会调用子类重写过后的函数，在父类中声明为加了virtual关键字的函数，在子类中重写时候不需要加virtual也是虚函数。
+ 虚函数的实现：**在有虚函数的类中，类的最开始部分是一个虚函数表的指针，这个指针指向一个虚函数表，表中放了虚函数的地址，实际的虚函数在代码段(.text)中。当子类继承了父类的时候也会继承其虚函数表，当子类重写父类中虚函数时候，会将其继承到的虚函数表中的地址替换为重新写的函数地址。使用了虚函数，会增加访问内存开销，降低效率。**

## 隐式类型转换

+ 对于内置类型，低精度的变量给高精度变量赋值会发生隐式类型转换，其次，对于只存在单个参数的构造函数的对象构造来说，函数调用可以直接使用该参数传入，编译器会自动调用其构造函数生成临时对象。

## C++中拷贝赋值函数的形参能否进行值传递

+ 不能。如果是这种情况下，调用拷贝构造函数的时候，首先要将实参传递给形参，这个传递的时候又要调用拷贝构造函数。。如此循环，无法完成拷贝，栈也会满。

## virtual修饰符

+ 如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。

+ 如果类中成员是virtual属性，会隐藏父类对应的属性。

## 静态变量什么时候初始化

+ 静态变量存储在虚拟地址空间的数据段和bss段，C语言中其在代码执行之前初始化，属于编译期初始化。而C++中由于引入对象，对象生成必须调用构造函数，因此C++规定全局或局部静态对象当且仅当对象首次用到时进行构造

# C++11特性

## C++11有哪些新特性

+ auto关键字：编译器可以根据初始值自动推导出类型。但是不能用于函数传参以及数组类型的推导
+ nullptr关键字：nullptr是一种特殊类型的字面值，它可以被转换成任意其它的指针类型；而NULL一般被宏定义为0，在遇到重载时可能会出现问题。
+ 智能指针：C++11新增了std::shared_ptr、std::weak_ptr等类型的智能指针，用于解决内存管理的问题。
+ 初始化列表：使用初始化列表来对类进行初始化
+ 右值引用：基于右值引用可以实现移动语义和完美转发，消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
+ atomic原子操作用于多线程资源互斥操作
+ 新增STL容器array以及tuple

## 右值和左值

+ 右值引用：C++11中引入的新特性 , 它实现了转移语义和精确传递。它的主要目的有两个方面：

  + 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
  + 能够更简洁明确地定义泛型函数。（模板参数是T &&和自动类型推导auto &&）这两种情况都是未定义的引用类型。
  + T &&和auto &&推导出来的类型规律
    + 通过右值推导T &&或者auto &&得到的是一个右值引用类型
    + 通过非右值（右值引用，左值，左值引用，常量右值引用，常量左值引用）推导T &&或者auto &&得到的是一个左值引用类型
    + const T &&不是未定义类型，不需要推导，本身就是一个右值引用
+ 左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。
+ 右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。
+ 右值引用和左值引用的区别：

  1. 左值可以寻址，而右值不可以。
  2. 左值可以被赋值，右值不可以被赋值，可以用来给左值赋值。
  3. 左值可变,右值不可变（仅对基础类型适用，用户自定义类型右值引用可以通过成员函数改变）。
+ 左值引用：要求右边的值必须能够取地址，如果无法取地址，可以用常引用；但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了。
+ 右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的**生存期会延长**至与绑定到它的右值引用的生存期。

+ 右值引用作用：右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。

## c++中的smart pointer四个智能指针

**C++里面的四个智能指针: auto_ptr, shared_ptr, weak_ptr, unique_ptr 其中后三个是c++11支持，并且第一个已经被11弃用。**

+ 智能指针：智能指针的作用是管理一个指针，因为存在以下这种情况：申请的空间在函数结束时忘记释放，造成内存泄漏。使用智能指针可以很大程度上的避免这个问题，因为智能指针就是一个类，当超出了类的作用域是，类会自动调用析构函数，析构函数会自动释放资源。所以智能指针的作用原理就是在函数结束时自动释放内存空间，不需要手动释放内存空间。
+ 智能指针：主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。

### auto_ptr

+ 采用所有权模式，存在潜在的内存崩溃问题！（c++98的方案，cpp11已经抛弃）

```c++
auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
auto_ptr<string> p2;
p2 = p1; //auto_ptr不会报错.

此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！
```

### unique_ptr（替换auto_ptr）

+ unique_ptr实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。

```c++
unique_ptr<string> p3 (new string ("auto"));   //#4
unique_ptr<string> p4；                       //#5
p4 = p3;//此时会报错！！ 编译器认为p4=p3非法，避免了p3不再指向有效数据的问题。因此，unique_ptr比auto_ptr更安全。
```

```c++
// 当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果源 unique_ptr 将存在一段时间，编译器将禁止这么做
unique_ptr<string> pu1(new string ("hello world"));
unique_ptr<string> pu2;
pu2 = pu1;                                      // #1 not allowed
unique_ptr<string> pu3;
pu3 = unique_ptr<string>(new string ("You"));   // #2 allowed

/*
其中#1留下悬挂的unique_ptr(pu1)，这可能导致危害。而#2不会留下悬挂的unique_ptr，因为它调用 unique_ptr 的构造函数，该构造函数  创建的临时对象在其所有权让给 pu3 后就会被销毁。这种随情况而已的行为表明，unique_ptr 优于允许两种赋值的auto_ptr 。
*/
```

```c++
// 如果确实想执行类似与#1的操作，要安全的重用这种指针，可给它赋新值。C++有一个标准库函数std::move()，让你能够将一个unique_ptr赋给另一个
unique_ptr<string> ps1, ps2;
ps1 = demo("hello");
ps2 = move(ps1);
ps1 = demo("alexia");
cout << *ps2 << *ps1 << endl;
```

### shared_ptr

+ shared_ptr实现共享式拥有概念。**多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。**
+ 从名字share就可以看出了资源可以被多个指针共享，它使用**计数机制**来表明资源被几个指针共享。可以通过成员函数use_count()来查看资源的所有者个数。除了可以通过new来构造，还可以通过传入auto_ptr, unique_ptr,weak_ptr来构造。当我们调用release()时，当前指针会释放资源所有权，计数减一。当计数等于0时，资源会被释放。
+ shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的), 在使用引用计数的机制上提供了可以共享所有权的智能指针。
+ 成员函数：
  + use_count 返回引用计数的个数
  + unique 返回是否是独占所有权( use_count 为 1)
  + swap 交换两个 shared_ptr 对象(即交换所拥有的对象)
  + reset 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少
  + get 返回内部对象(指针), 由于已经重载了()方法, 因此和直接使用对象是一样的.如 shared_ptr<int> sp(new int(1)); sp 与 sp.get()是等价的
+ 注意事项：
  + 不能使用已给原始地址初始化多个共享指针
  + 函数不能反悔管理了this的共享指针对象
  + 共享指针不能循环引用


### weak_ptr

+ weak_ptr 是一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. 
+ weak_ptr只是提供了对管理对象的一个访问手段。
+ weak_ptr 设计的目的是为配合 shared_ptr 而引入的一种智能指针来协助 shared_ptr 工作, 它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, **它的构造和析构不会引起引用记数的增加或减少。**
+ **weak_ptr是用来解决shared_ptr相互引用时的死锁问题，如果说两个shared_ptr相互引用，那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。**
+ 它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化，shared_ptr可以直接赋值给它，它可以通过调用lock函数来获得shared_ptr。

```C++
class B;
class A {
 public:
  shared_ptr<B> pb_;
  ~A() { cout << "A delete\n"; }
};
class B {
 public:
  shared_ptr<A> pa_;
  ~B() { cout << "B delete\n"; }
};
void fun() {
  shared_ptr<B> pb(new B());
  shared_ptr<A> pa(new A());
  pb->pa_ = pa;
  pa->pb_ = pb;
  cout << pb.use_count() << endl;
  cout << pa.use_count() << endl;
}
int main() {
  fun();
  return 0;
}
/*
可以看到fun函数中pa ，pb之间互相引用，两个资源的引用计数为2，当要跳出函数时，智能指针pa，pb析构时两个资源引用计数会减一，但是两者引用计数还是为1，导致跳出函数时资源没有被释放（A B的析构函数没有被调用），如果把其中一个改为weak_ptr就可以了，我们把类A里面的shared_ptr pb_; 改为weak_ptr pb_; 运行结果如下，这样的话，资源B的引用开始就只有1，当pb析构时，B的计数变为0，B得到释放，B释放的同时也会使A的计数减一，同时pa析构时使A的计数减一，那么A的计数为0，A得到释放。

注意的是我们不能通过weak_ptr直接访问对象的方法，比如B对象中有一个方法print(),我们不能这样访问，pa->pb_->print(); 英文pb_是一个weak_ptr，应该先把它转化为shared_ptr,如：shared_ptr p = pa->pb_.lock(); p->print();
*/
```

### 智能指针有没有内存泄露的情况

当两个对象相互使用一个shared_ptr成员变量指向对方，会造成循环引用，使引用计数失效，从而导致内存泄漏。例如：上面的例子就是

### 智能指针的内存泄漏如何解决

为了解决循环引用导致的内存泄漏，引入了weak_ptr弱指针，weak_ptr的构造函数不会修改引用计数的值，从而不会对对象的内存进行管理，其类似一个普通指针，但不指向引用计数的共享内存，但是其可以检测到所管理的对象是否已经被释放，从而避免非法访问。

## constexpr和const

+ 常量表达式的计算是在编译阶段，提高程序执行效率。非常量表达式只能在运行阶段计算出结果。
+ const：变量只读，修饰常量

```cpp
void func(const int num){	// 只读
	int a = 10;
	const int b = a;	// 常量
	int nums[b];		// 可以，b是常量
	int nums[num];		// 不可以，num是只读，不是常量无法给数组定义
}
```

+ constexpr：常量表达式。
+ constexpr不能修饰class和struct。但是能**修饰变量**

```cpp
constexpr struct T{ //会报错，需要去掉constexpr
	int a;
};
void func(){
    constexpr T t{1};
    t.a=10;	// 报错，因为t是常量表达式，不允许修改
}
```

+ constexpr修饰函数：**普通函数，类函数，类的构造函数，模板函数。**

  + 函数必须要有返回值，并且返回值必须是常量表达式
  + 函数在使用之前，必须有对应的定义语句，不能只有声明
  + 整个函数的函数体中，不能出现非常量表达式之外的语句。（using指令，typedef语句或者断言，return语句）
  + constexpr修饰的模板函数实例化结果不满足常量表达式函数的要求，则constexpr会自动忽略，等同于普通函数
  + constexpr修饰构造函数，则构造函数函数体必须是空的，且必须采用初始化列表的方式为各个成员赋值

  ```cpp
  struct person{
  	constexpr person(string n,int a):name(n),age(a){}
  	int age;
  	string name;
  };
  ```

## auto和decltype

### auto

使用auto声明的变量必须初始化，让编译器推导出它实际的类型，在编译时将auto占位符替换成真正的类型

```cpp
auto 变量名 = 变量值;
```

当变量**不是**指针或者引用类型时，推导的结果中**不会**保留const，volatile关键字

当变量**是**指针或者引用类型时，推导的结果中会保留const，volatile关键字

### auto的限制：

1. 不能作为函数参数使用。因为只有在函数调用的时候才能函数参数传递，auto必须要给变量初始化。
2. 不能作为类的非静态变量的初始化

```cpp
class C {
	auto v1 = 0;				//error
	static	auto v2 = 0;		//error,类的静态非常量成员不允许在类内部直接初始化
	static const auto v3 = 10;	//ok
};
```

3. 不能使用auto关键字定义数组

```cpp
void fun(){
	int arr[] = {1,2,3};
	auto t1 = arr;			//ok t1:int*
	auto t2[] = arr;		//error 无法定义数组
	auto t3[] = {1,2,3};	//error 无法定义数组
}
```

4.   无法使用auto推导出模板参数

```cpp
tmplate <typename T>
struct Test{}
int fun(){
	Test<double> t;
	Test<auto> = t;	// error 无法推导
}
```

### 使用auto

1. 用于代替冗长复杂、变量使用范围专一的变量声明
2. 在定义模板函数时，用于声明依赖模板参数的变量类型（模板参数有两个以上，且两个参数做）
3. 模板函数依赖于模板参数的返回值

```cpp
#include<string>
#include<vector>
int main()
{
    std::vector<std::string> vs;
    for (std::vector<std::string>::iterator i = vs.begin(); i != vs.end(); i++)
    {
        //...
    }
}

template <typename _Tx,typename _Ty>
void Multiply(_Tx x, _Ty y)
{
    auto v = x*y;	// 必须使用auto
    std::cout << v;
}

template <typename _Tx, typename _Ty>
auto multiply(_Tx x, _Ty y)->decltype(_Tx*_Ty)	// 必须使用auto
{	
    return x*y;
}
```

### decltype

在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，decltyp的作用就是在**编译的时候**推导出一个表达式的类型：decltype（表达式）

decltype推导的表达式可以简单可以复杂，在这一点上auto是做不到的。auto只能推导已经初始化的变量类型

### decltype推导规则

1. 表达式为普通变量或者普通表达式或者类表达式，在这种情况下decltype推导出来的类型和表达式是一致的
2. 表达式是函数调用，使用decltype推导出来的类型和函数返回值一致。如果函数返回值是纯右值，只有类类型可以携带const，volatile限定符，除此之外都需要忽略掉这两个限定符
3. 表达式是一个左值，或者被括号包围，使用decltype推导出的是表达式类型的引用（如果有const volatile限定符不能忽略）

### decltype的应用

decltype的应用多出现在泛型编程中。例如我们写个类模板，在里面添加遍历容器的函数

返回值类型后置

## final

final限制某个类不能被继承或者某个虚函数不能被重写。如果使用final修饰函数，只能修饰**虚函数（子类的）**，并且要吧final关键系放在类或者函数后面

1. 只能修饰虚函数，这样阻止子类重写父类的这个函数

```cpp
class P {
 public:
  virtual void fun() { cout << "P"; }	// 这里也可以加final只是加了没有意义，因为virtual就是为了重写
};

class S : public P {
 public:
  void fun() final { cout << "S"; }		
};

class GS : public S {
 public:
  void fun() { cout << "GS"; }	// 这里不允许重写
};
```

2. 修饰类是不允许被继承的，也就是这个类没有派生类

```cpp
class P final {
};

class S : public P {	// error 不允许继承
};
```

## override

override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的函数名。同时也明确表明将会重写基类的虚函数，这样就可以确保重写的虚函数正确性，提高代码可读性

```cpp
class P {
 public:
  virtual void fun() { cout << "P"; }
};

class S : public P {
 public:
  void fun() override { cout << "S"; } // 如果fun写成func则会报错，因为在基类中找不到该虚函数
};
```

## using和typedef

using语法和typedef一样，并不会创建新的类型，他们只是给某些类型定义新的名字，using相较于typedef的优势在于定义函数指针名别看起来更直观，并且可以给模板定义别名。typedef需要再包一层

```cpp
template <typename T>
struct MyMap {
  typedef map<int, T> mapType;
};

template <typename T>
using MMap = map<int, T>;
```

using还能声明父类的函数不被隐藏

```cpp
class P {
 public:
  void fun() { cout << "p" << endl; }
};

class S : public P {
 public:
  using P::fun;	// 声明父类的函数不被隐藏，否则无法调用fun()
  void fun(int i) { cout << "p10" << endl; }
};

int main() {
  S s;
  s.fun(10);
  s.fun();
  return 0;
}
```

## 可调用对象包装器，绑定器

### 可调用对象

1. 是一个函数指针
2. 是一个具有operator（）成员函数的类对象（仿函数）
3. 是一个可被转换为函数指针的类对象
4. 是一个类成员函数指针或者类成员指针

https://www.bilibili.com/video/BV1bX4y1G7ks?p=27

### 包装器

std::function是可调用对象包装器。他是一个类模板，可以容纳除了类成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，他可以统一的方式处理函数，函数对象，函数指针，并且保存和延迟执行他们

```cpp
#include <functional>
std::function<返回值(参数类型列表)> diyName = 可调用对象
function<void(int,string)> f1 = print;
```

### 绑定器

std::bind用来将可调用的对象与其函数绑定在一起。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。通俗来讲两个作用：

1. 将可调用对象与参数一起绑定成一个仿函数
2. 将多元（参数个数为n，n>1）可调用对象转换为一元或者（n-1）元可调用对象，即绑定部分参数

```cpp
// 绑定非类成员函数/变量
auto f = std::bind(可调用对象地址，绑定参数/占位符)
// 绑定类成员函数/变量
auto f = std::bind(类函数/成员变量，类实例对象地址，绑定参数/占位符)
```

## lambda表达式

lambda表达式有以下优点：

1. 声明式的编程风格：就地匿名定义目标函数或函数对象，不需要额外的命名函数和对象
2. 简介：避免了代码膨胀和功能分散，使程序更加高效
3. 在需要的时间和地点实现功能闭包，使程序更加灵活

```cpp
[capture](params) opt -> ret {body;};
capture：捕获列表（可选），捕获一定范围的变量
params：参数列表（可选）
opt：函数选型（可选）
    mutable：可以修改按值传递进来的拷贝（注意是修改拷贝，不是值本身）
    exception：指定函数抛出异常，如果抛出整数类型的异常，可以使用throw();
ret：返回类型（可选）
body：函数体（可选）
```

### 捕获列表

+ []：不捕获任何变量
+ [&]：捕获外部作用于所有变量，并且引用到函数体内使用（按引用捕获）
+ [=]：捕获外部作用于所有变量，并且作为副本在函数体内使用（按值捕获），并且是只读，除非opt使用了mutable关键字。
+ [=，&param]：按值捕获外部作用于中所有变量，并按照引用捕获外部变量param
+ [bar]：按值捕获bar变量，同时不捕获其他变量
+ [&bar]：按引用捕获bar变量，同时不捕获其他变量
+ [this]：捕获当前类中的this指针
  + 让lambda表达式拥有和当前类成员函数同样的访问权限
  + 如果已经使用了&或者=，默认添加此项

### 函数本质

lambda表达式的类型在C++11中会被看成一个带operator（）的类。是一个仿函数

按照c++标准，lambda表达式的operator（）默认是const，一个const成员函数是无法修改成员变量值的

对于没有捕获任何变量的lambda表达式，还可以转换成一个普通的函数指针

### move和forward的区别

> move：将右值引用拷贝到左值上
>
> forward：为了处理左值引用和右值引用拷贝问题，避免重复代码，使用了forward就能完美转发
>
> ```cpp
> 处理这种情况
> // const T &
> // T &
> // const T &&
> // T &&
> template<typename T1, typename T2>
> void set(T1 && var1, T2 && var2){
>     m_var1 = std::forward<T1>(var1);
>     m_var2 = std::forward<T2>(var2);
> }
> ```
>
> forward常用于template函数中, 使用的时候必须要多带一个template参数T: `forward<T>`, 代码略复杂;
>
> 还有, 明确只需要move的情况而用forward, 代码意图不清晰, 其他人看着理解起来比较费劲。所以保留move

## 闭包

闭包：有状态的函数。实现方式有仿函数（operator()的类或者结构体）和包装器绑定器和lambda表达式。

闭包的状态捆绑，必须发生在运行时。

# STL

## vector和list

> **vector：**
>
> + 连续存储的容器，动态数组，在堆上分配空间。
> + 底层实现：数组。
> + 两倍容量增长：vector 增加（插入）新元素时，如果未超过当时的容量，则还有剩余空间，那么直接添加到最后（插入指定位置），然后调整迭代器。如果没有剩余空间了，则会重新配置原有元素个数的两倍空间，然后将原空间元素通过复制的方式初始化新空间，再向新空间增加元素，最后析构并释放原空间，之前的迭代器会失效。使用了算法导论里面的平摊分析算法，时间复杂度是O(1)
> + 性能：
>   + 访问：O(1)
>   + 插入：在最后插入（空间够）：很快
>   + 在最后插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
>   + 在中间插入（空间够）：内存拷贝
>   + 在中间插入（空间不够）：需要内存申请和释放，以及对之前数据进行拷贝。
>   + 删除：在最后删除：很快
>   + 在中间删除：内存拷贝
> + 适用场景：经常随机访问，且不经常对非尾节点进行插入删除。

> **list：**
>
> + 动态链表，在堆上分配空间，每插入一个元数都会分配空间，每删除一个元素都会释放空间。
> + 底层：双向链表
> + 性能：
>   + 访问：随机访问性能很差，只能快速访问头尾节点。
>   + 插入：很快，一般是常数开销
>   + 删除：很快，一般是常数开销
> + 适用场景：经常插入删除大量数据

> **list和vector的区别：**
>
> 1）vector底层实现是数组；list是双向链表。
>
> 2）vector支持随机访问，list不支持。
>
> 3）vector是顺序内存，list不是。
>
> 4）vector在中间节点进行插入删除会导致内存拷贝，list不会。
>
> 5）vector一次性分配好内存，不够时才进行2倍扩容；list每次插入新节点都会进行内存申请。
>
> 6）vector随机访问性能好，插入删除性能差；list随机访问性能差，插入删除性能好。

> **list和vector的应用：**
>
> + vector拥有一段连续的内存空间，因此支持随机访问，如果需要高效的随即访问，而不在乎插入和删除的效率，使用vector。
>
> + list拥有一段不连续的内存空间，如果需要高效的插入和删除，而不关心随机访问，则应使用list。

## map和unordered_map

>  **map：**
>
> + **底层是基于红黑树实现的，因此map内部元素排列是有序的。**
> + map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。**不允许键值重复。**
>
> 对于map，其底层是基于红黑树实现的
>
> + 优点如下：
>     + 有序性，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作
>     + map的查找、删除、增加等一系列操作时间复杂度稳定，都为logn
>
> + 缺点如下：
>     + 查找、删除、增加等操作平均时间复杂度较慢，与n相关

> **unordered_map：**
>
> + **底层则是基于哈希表实现的，因此其元素的排列顺序是杂乱无序的。**
> + multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。**允许键值重复。**
>
> 对于unordered_map来说，其底层是一个哈希表
>
> + 优点如下：
>   + 查找、删除、添加的速度快，时间复杂度为常数级O(c)
>
> + 缺点如下：
>   + 因为unordered_map内部基于哈希表，以（key,value）对的形式存储，因此空间占用率高
>   + Unordered_map的查找、删除、添加的时间复杂度不稳定，平均为O(c)，取决于哈希函数。极端情况下可能为O(n)

## map和set

+ map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。所有元素都会根据元素的值自动被排序，且不允许重复。
+ map和set区别在于：
  + map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。
  + set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以**STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。**
  + map支持下标操作，set不支持下标操作。map可以用key做下标，***map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用**，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。**如果find能解决需要，尽可能用find。**

## STL迭代器删除元素

1. 对于序列容器vector,deque来说，**使用erase(itertor)后，后边的每个元素的迭代器都会失效**，但是后边每个元素都会往前移动一个位置，但是**erase会返回下一个有效的迭代器**；
2. 对于关联容器map set来说，**使用了erase(iterator)后，当前元素的迭代器失效，但是其结构是红黑树，删除当前元素的，不会影响到下一个元素的迭代器，所以在调用erase之前，记录下一个元素的迭代器即可。**
3. 对于list来说，它使用了不连续分配的内存，并且**它的erase方法也会返回下一个有效的iterator**

## STL里resize和reserve的区别

+ resize()：**改变当前容器内含有元素的数量(size())**，eg: vector<int>v; v.resize(len);v的size变为len,如果原来v的size小于len，那么容器新增（len-size）个元素，元素的值为默认为0.当v.push_back(3);之后，则是3是放在了v的末尾，即下标为len，此时容器是size为len+1；
+ reserve()：**改变当前容器的最大容量（capacity）,它不会生成元素，只是确定这个容器允许放入多少对象**，如果reserve(len)的值大于当前的capacity()，那么会重新分配一块能存len个对象的空间，然后把之前v.size()个对象通过copy construtor复制过来，销毁之前的内存；

## STL的allocaotr

+ STL的分配器用于封装STL容器在内存管理上的底层细节。在C++中，其内存配置和释放如下：
  + new运算分两个阶段：(1)调用::operator new配置内存;(2)调用对象构造函数构造对象内容
  + delete运算分两个阶段：(1)调用对象希构函数；(2)掉员工::operator delete释放内存

+ 为了精密分工，STL allocator将两个阶段操作区分开来：内存配置有alloc::allocate()负责，内存释放由alloc::deallocate()负责；对象构造由::construct()负责，对象析构由::destroy()负责。

+ 同时为了提升内存管理的效率，减少申请小内存造成的内存碎片问题，SGI STL采用了两级配置器，当分配的空间大小超过128B时，会使用第一级空间配置器；当分配的空间大小小于128B时，将使用第二级空间配置器。第一级空间配置器直接使用malloc()、realloc()、free()函数进行内存空间的分配和释放，而第二级空间配置器采用了内存池技术，通过空闲链表来管理内存。

## STL有什么基本组成

+ STL主要由：以下几部分组成：
  + 容器迭代器
  + 仿函数
  + 算法
  + 分配器
  + 配接器
+ 他们之间的关系：分配器给容器分配存储空间，算法通过迭代器获取容器中的内容，仿函数可以协助算法完成各种操作，配接器用来套接适配仿函数

## STL中迭代器

+ 迭代器：
  + Iterator（迭代器）模式又称Cursor（游标）模式，用于提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。或者这样说可能更容易理解：Iterator模式是运用于聚合对象的一种模式，通过运用该模式，使得我们可以在不知道对象内部表示的情况下，按照一定顺序（由iterator提供的方法）访问聚合对象中的各个元素。
    + 由于Iterator模式的以上特性：与聚合对象耦合，在一定程度上限制了它的广泛运用，一般仅用于底层聚合支持类，如STL的list、vector、stack等容器类及ostream_iterator等扩展iterator。

+ 迭代器和指针的区别
  + 迭代器不是指针，是类模板，表现的像指针。他只是模拟了指针的一些功能，通过重载了指针的一些操作符，->、*、++、--等。迭代器封装了指针，是一个“可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象， 本质是封装了原生指针，是指针概念的一种提升（lift），提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。

+ 迭代器返回的是对象引用而不是对象的值，所以cout只能输出迭代器使用*取值后的值而不能直接输出其自身。

+ 迭代器产生原因：Iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

## STL 的内存优化

+ STL内存管理使用二级内存配置器。
+ 第一级配置器：以malloc()，free()，realloc()等C函数执行实际的内存配置、释放、重新配置等操作，并且能在内存需求不被满足的时候，调用一个指定的函数。**一级空间配置器分配的是大于128字节的空间**，如果分配不成功，调用句柄释放一部分内存。如果还不能分配成功，抛出异常
+ 第二级配置器：在STL的第二级配置器中多了一些机制，避免太多小区块造成的内存碎片，小额区块带来的不仅是内存碎片，配置时还有额外的负担。区块越小，额外负担所占比例就越大。
+ 分配原则
  + 如果要分配的区块大于128bytes，则移交给第一级配置器处理。
  + 如果要分配的区块小于128bytes，则以内存池管理（memory pool），又称之次层配置（sub-allocation）：每次配置一大块内存，并维护对应的16个空闲链表（free-list）。下次若有相同大小的内存需求，则直接从free-list中取。如果有小额区块被释放，则由配置器回收到free-list中。

# 底层

## malloc的原理

+ Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。
+ 当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。
+ Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。

## C++的内存管理

在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。

+ 代码段：包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。
+ 数据段：存储程序中已初始化的全局变量和静态变量
+ bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。
+ 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。当进程未调用malloc时是没有堆段的，只有调用malloc时采用分配一个堆，并且在程序运行过程中可以动态增加堆大小(移动break指针)，从低地址向高地址增长。分配小内存时使用该区域。  堆的起始地址由mm_struct 结构体中的start_brk标识，结束地址由brk标识。
+ 映射区:存储动态链接库以及调用mmap函数进行的文件映射
+ 栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值

## 栈和堆的区别，以及为什么栈要快

+ 堆和栈的区别：
  + 堆是由低地址向高地址扩展；栈是由高地址向低地址扩展
  + 堆中的内存需要手动申请和手动释放；栈中内存是由OS自动申请和自动释放，存放着参数、局部变量等内存
  + 堆中频繁调用malloc和free,会产生内存碎片，降低程序效率；而栈由于其先进后出的特性，不会产生内存碎片
  + 堆的分配效率较低，而栈的分配效率较高

+ 栈的效率高的原因：栈是操作系统提供的数据结构，计算机底层对栈提供了一系列支持：分配专门的寄存器存储栈的地址，压栈和入栈有专门的指令执行；而堆是由C/C++函数库提供的，机制复杂，需要一些列分配内存、合并内存和释放内存的算法，因此效率较低。

## 段错误

+ 段错误通常发生在访问非法内存地址的时候，具体来说分为以下几种情况：
  + 使用野指针
  + 试图修改字符串常量的内容

## 内存泄漏

+ 内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费

+ 内存泄漏的分类：

  1. 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak.

  2. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。

  3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。

## C++如何处理内存泄漏？

使用varglind，mtrace检测

## 内存对齐

### 性能原因

CPU 看代内存是一块块的，块大小为 2，4，8，16 个字节，因此 CPU 在读取内存数据时，时以块大小为粒度读取的。举例说明：
case1：从 0 开始读取 4 字节的数据。直接将 0-3 这 4 个字节的数据读取到寄存器，返回
case2：从 1 开始读取 4 字节的数据假设 CPU 要读取 4 字节大小的数据，如果数据在 1 字节位置作为起始读取地址，读取过程就很复杂，

①先将 1-4 这 4 个字节读取到寄存器

②再读取 4-7 这 4 字节的数据到寄存器

③把 4，6，7 字节的数据剔除，剩下 1，2，3，4

④最后，将 1，2，3，4 字节的数据合并，存到寄存器

### 平台原因

并不是所有的硬件平台都支持访问任意地址的数据

### 对齐准则

1. 每个数据成员偏移量必须是 min(#pragma pack()指定的数, len(该数据成员))的倍数
2. struc 的 size，一定是长度最长的数据成员的倍数

## 动态链接和静态链接有啥区别

静态链接的缺点很明显，一是浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

动态链接的优点显而易见，就是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分，副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。
原文链接：https://blog.csdn.net/kang___xi/article/details/80210717

## 二维数组两种遍历方式

+ arr\[i][j]和arr\[j][i] 这两种遍历方式有什么区别
+ arr + i\*j 和 arr + j\*i

```
int arr[1024][1024]
for (int i=0; i<1024;i++)
	for (int j=0; j<1024;j++)
		arr[i][j]
		arr[j][i]
```

按行访问比较快

按行内存布局：二维数组的数据是按行存储的，即：先存第一行，再存第二行

内存缓存：读数据时，CPU缓存是一段一段的读取数据的，而且有局部性原理。会将该元素周围的数据都读到缓存中，提高读效率。如果用列存储就无法用到cpu缓存的特性。