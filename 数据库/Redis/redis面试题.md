#  1. 底层数据结构

## 1.1. 简单动态字符串SDS

```C++
struct sds{
	int len;     // buf数组已经使用字符串的长度
	int free;    // buf数组未使用的长度
	char buf[];  // 保存字符串
};
```

### 1.1.1. 为什么要使用SDS，而不使用C字符串

- 背景
  - Redis作为缓存数据库，`数据经常会被修改`，造成`内存重分配`，影响性能。
- 原因详述
  1. SDS有len成员变量，可以在**O(1)**的时间复杂度**获取长度信息**
     - 即使反复执行strlen命令，也不会对系统性能造成任何影响
  2. 更安全：杜绝**缓冲区溢出**
     - 当SDS执行strcat/strcpy等函数时，会先检查free是否够用，不够用时，就扩增
  3. 减少**重分配次数**
     - **扩增**：SDS会多分配free的空间，当需要扩容时，若free空间足够，直接改变len/free的值就可以
     - **缩短**：缩短时，直接修改free的值，不需要释放旧空间，申请小的新空间存放新字符串

## 1.2. 哈希表

### 1.2.1. 数据结构

```c
// 哈希表
typedef struct dictEntry {
	void* key;  // 键
	union {     // 值
		void* val;
		uint64_t u64;
		int64_t  s64;
	} v;
	struct dictEntry* next; // 指向下一个哈希节点，形成链表
}dictEntry_t;

struct dictht {
	dictEntry_t **table;  // 数组，每个元素都是dictEntry_t*，它是一个链表头，所有冲突的key挂在相同链表上
	unsigned long size;   // 哈希表容量大小
	unsigned long used;   // 当前已经使用大小
}
```

```c
// 字典
struct dict {
	dictht ht[2];   // 2个哈希表: ht[0]正常情况下使用, ht[1]在rehash时使用
    int rehashidx;  // rehash索引 (没进行rehash时，该值为-1)
}
```

### 1.2.2. rehash（重新散列）

- 背景

  - 哈希表中键值对的增加/减少，都可能导致rehash（为了使哈希表的 `负载因子` 维持在合理的范围内）：一般进行2倍扩充（算法导论中的平摊分析）

- rehash过程（渐进式rehash）

  - ht[1]分配空间，新建一个空的哈希表
  - rehash索引计数器（**rehash_index**），由-1变为0，表示rehash正式开始
  - 将ht[0]中的元素，rehash重新散列到ht[1]上
    - 每次一个(key,value)键值对rehash成功后，rehash索引计数器都+1
  - 当所有的ht[0]都rehash到ht[1]中后，ht[0]被清空，此时将ht[0],ht[1]**交换**，rehash结束，最后将rehash索引设为-1

  :slightly_smiling_face:在rehash过程中，**新增加的(key,value)键值对**，怎么处理？

  - 答：会直接rehash到ht[1]上，这样做，会保证ht[0]只减不增

## 1.3. 压缩列表ziplist

- 使用场景

  - 列表键、哈希键: 含有少数的键，且键是“短整型”、“短字符串”

- 优点

  - 节省内存，实现简单，是连续内存块的顺序存储（有点像变长数组，它通过长度划分每个节点）

- 每个 `压缩列表节点` 构成

  - 前一个节点的长度pre_len 当前节点的长度、类型 
  - 当前节点的数据内容

- 连锁更新

  - 当插入和删除元素时，可能会导致连锁更新。

    ① （全small）原ziplist节点都是长度小于256：当在idx插入大于256的节点时，idx+1后面的节点e1的成员pre_len无法保存前一个节点的长度，因此，要重分配内存。这样e1内存就扩增了，因为是顺序存储，所以e2、e3后面的元素都要向后移动（更新） 

    ② （big1、small、big2）：当删除small时，将会引起big2后面的节点连锁更新



## 1.4. 跳跃表skipList

- 结构

  - 是一个**多层次**的链表，每层节点的**next跨度**大小都不同，从上到下依次减小

- 时间复杂度

  - 性能可以和AVL树媲美，且实现简单

  - 最好O（lgN）
  - 最差O（N） 

- 使用场景

  - zset有序集合键

#### 1.4.1. Redis为什么使用skiplist，不使用红黑树

1. **范围查找**的时候，平衡树比skiplist操作要复杂。

   > 在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。
   >
   > 而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。

2. 平衡树的插入和删除操作可能**引发子树的调整**，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。

3. 从**内存占用**上来说，skiplist比平衡树更灵活一些。

   一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而skiplist每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。

4. 查找单个key，skiplist和平衡树的时间复杂度都为O(logn)，大体相当

5. 从**算法实现难度**上来比较，skiplist比平衡树要简单得多。

#  2. Redis五种数据结构

- 字符串键string
  - 字符串类型的value最大能容纳**512M** 
- 列表
  - ziplist
  - linklist               
- 哈希     
  - ziplist
  - hash-table            
- 集合           
  - intset
  - hash-table
- 有序集合
  - ziplist
  - 跳跃表                 



## Redis线程模型

### Redis单线程？多线程？

+  单线程指的是网络请求模块使用了一个线程（所以不需考虑线程安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。
+ 主线程：Redis在<u>处理客户端请求时（获取命令、解析命令、执行、返回内容）</u>等操作都是由一个顺序串行的主线程处理的，这就是所谓的“单线程”。
+ 后台线程：清理脏数据、无用连接释放、大key的删除

### Redis单线程为什么快

1. 纯内存操作，且操作复杂度不高
2. 核心是基于非阻塞的IO多路复用机制
3. 单线程避免了多线程的频繁切换上下文所带来的的性能消耗

### Redis6.0之前为什么之前一直不使用多线程？

+ **官方回应**：Redis几乎不存在CPU称为瓶颈的情况，主要受限于**内存/网络**。单机QPS可以达到**100万**。

### Redis超过内存限制，会出现什么问题

+ 会根据Redis配置文件，释放内存（内存淘汰策略LRU/LFU/random）。可能 <u>释放内存的速度 < 内存增大的速度</u>，此时就会导致Redis客户端写入错误



## 缓存穿透，缓存击穿，缓存雪崩

### 缓存穿透

+ 缓存穿透是指缓存和数据库中没有数据，导致所有请求都落到数据库上，造成数据库短时间承受大量请求而崩溃
+ 出现场景：
  + 被别人恶意攻击（比如，发起ID=-1的请求）
+ 解决方案：
  + 接口层增加入参校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截
  + 从缓存取不到的数据库，在数据库中也没取到，这个时候可以将key-value写成key-null，缓存有效时间可以设置短点（设置太长会导致正常情况也无法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
  + 采用布隆过滤器，将所有可能存在的数据haxi到一个足够大的bitmap中，一个一定不存在的数据会被bitmap拦截掉，从而避免对底层存储系统查询增加压力。
    + 布隆过滤器算法的特点：① 不在布隆过滤器中的元素，一定不存在。② 在布隆过滤器中的元素，大概率存在（但是不是“一定存在”）

### 缓存击穿

+ 缓存穿透是指缓存中没有数据但是数据库中有数据（一般是缓存时间到期），这个时候由于并发用户特别多，同时读缓存没有的数据，然后去数据库中拉去数据，引起数据库压力瞬间增大，造成崩溃。和缓存雪崩不同的是，缓存击穿是指并发查询同一个数据，还魂雪崩是指大量缓存数据过期。
+ 出现场景：
  + 刚好缓存过期期间，有大量的请求访问该过期数据
+ 解决方案：
  + 设置热点数据永远不过期
  + 加互斥锁

### 缓存雪崩

+ 缓存雪崩是指缓存同一时间大面积失效，所以后面的请求都会落到数据库上，造成数据库短时间承受大量请求崩溃

+ 出现场景：

  + 缓存宕机，缓存数据大面积同时失效
  + 缓存同时到期，缓存数据大面积同时失效

+ 解决方案：

  > **避免出现缓存雪崩**
  >
  > 1. 一般采用“搭建高可用集群”，：防止“Redis服务器宕机”导致缓存雪崩
  > 2.  采用“设置不同的过期时间”：防止同一时间大量数据过期现象发生
  > 3. 给每个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存
  > 4. 设置热点数据永远不过期
  > 5. 互斥锁

  > **已经出现缓存雪崩**
  >
  > 假设已经出现缓存雪崩，那么，没有其他解决办法！只能进行“熔断”、“降级”、“限流”
  >
  > 1. “熔断”，（拒绝请求）一旦发现当前服务的请求失败率达到预设的值，就拒绝随后该服务的所有请求。
  >
  > 2. “限流”，（限制请求数量）当经过一段时间后，会放行该服务的一部分请求，再次统计它的请求失败率。如果此时请求失败率符合预设值，则完全打开限流开关；如果请求失败率仍然很高，那么继续拒绝该服务的所有请求，这就是所谓的“限流”。
  >
  > 3. “降级”，（服务降级）而向那些被拒绝的请求直接返回一个预设结果，被称为“降级”



## Redis的过期键的删除策略

Redis是key-value的数据库，我们可以设置Redis中缓存的key过期时间。Redis的过期策略就是指当Reids中缓存中Key过期了，Redis如何处理

+ 惰性过期：只有当访问一个key时，才会判断key是否过期，过期则清理。该策略可以最大化的节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被删除，占用大量内存。
+ 定时过期：对每个key开启一个定时器，定时器到时间时，删除过期数据 。对内存相当的友好，不会浪费多余的内存。但是需要消耗CPU资源
+ 定期过期：每隔一定的时间，会扫描**一定数量**的数据库的expire字典中一定数量的key，并且清除其中过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使用CPU和内存资源达到最优的平衡效果

expire字典会保存所有设置了过期时间的key的过期时间数据。其中key是指向键空间中的某个键的指针，value是该键的毫秒精度的时时间戳表示过期时间。键空间是指该redis中保存的所有键

**Redis同时使用了惰性过期和定期过期两种策略**



## Redis集群方案

### 主从复制

+ 通过执行slaveof命令或者设置slaveof选项，让一个服务器去复制另外一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。**而从数据库一般是只读的，并接受主数据库同步过来的数据。**一个数据库可以拥有多个从数据库，而一个从数据库只能有一个主数据库

+ 正常情况下，主机提供服务，并将数据同步到备份机器；当主机宕机后，备机立即开始服务 。master宕机后，通过<u>选举投票</u>方式选择出新的master，继续提供服务。

+ 实现读写分离，提高并发性

+ 复制的方式有两种：全量复制和增量复制

+ 全量复制：

  + 主节点通过bgsave命令fork子进程进行RDB持久化，RDB持久化过程是非常消耗CPU，内存（页表复制），硬盘IO
  + 主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来非常大的消耗
  + 从节点清空老数据，载入新RDB文件（载入过程是阻塞的，无法响应客户端命令）。
  + 如果从节点执行了bgrewriteaof，也会带来额外的消耗（aof复制也需要消耗资源）

+ 增量复制：

  + 复制偏移量：执行复制的双方，主从节点分别会维护一个复制偏移量offset
  + 复制积压缓存区：主节点内部维护一个固定长度的，先进先出队列作为复制积压缓冲区，**当主从节点offset的差距超过换缓存区长度时，将无法进行增量复制，只能执行全量复制**
  + 服务器运行ID（runid）：每个节点都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点。从节点会将主节点的runid保存起来。从节点断开重连的时候，就是根据运行ID来判断同步的进度：
    + 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前通不过，主节点会继续尝试使用增量复制的方式（到底能不能使用增量复制还要看offset和复制积压缓存区的情况）
    + 如果从节点保存的runid与住节点现在的runid不同，说明从节点在断线前同步的redis节点并不是当前的主节点，只能进行权力复制

  > 过程原理图：![过程原理图](/数据库/Redis/image/主从复制原理图.png)

### 哨兵模式

sentinel，哨兵是redis集群中非常重要的一个组件，主要有以下功能：

+ 集群监控：负责监控redismaster和slave进程是否正常工作
+ 消息通知：如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员
+ 故障转移：如果master node挂掉了会自动转移到slave node上
+ 配置中心：如果故障转移发生了，通知client客户端新的master地址

哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协作工作。

+ 故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举
+ 即使部分哨兵节点挂了，哨兵集群还是能正常工作
+ 哨兵通常需要3个实例来保证自己的健壮性
+ 哨兵+redis主从的部署架构，不能保证数据零丢失，只能保证redis集群的高可用性

### Redis Cluster

Redis Cluster是一种服务端sharding技术，3.0版本开始正式提供了。采用了slot（槽）的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询的请求发送到正确节点上执行

+ 方案说明
  + 通过哈希的方式，将数据分片，每个节点均分存储一定的哈希槽（哈希值）区间的数据，默认分配了16384个槽位
  + 没分数据分片存储在多个互为主从的多个节点上
  + 数据先写入主节点，再同步到从节点（支持配置为阻塞同步）
  + 同一分片多个节点间的数据不保证强一致性
  + 读取数据时，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
  + 扩容时需要把旧节点的数据迁移一部分到新节点
+ 在redis cluster架构下，每个redis要放开两个端口，例如：一个6379，另外一个就是加上1W的端口16379。另外一个端口是用来进行节点间通信的，也就是cluster bus的通信。用来进行故障检测，配置更新，故障转移授权。
+ cluster bus用了另外一种二进制的协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间
+ 优点：
  + 无中心架构，支持动态扩容，对业务透明
  + 具备sentinel监控和自动failover（故障转移）能力
  + 客户端不需要连接集群所有节点，连接节点中任何一个可用节点即可
  + 高可用，客户端直连redis服务，免去了proxy代理的消耗
+ 缺点：
  + 运维也很复杂，数据迁移需要人工干预
  + 只能使用0号数据库
  + 不支持批量操作（pipeline管道操作）
  + 分布式逻辑和存储模块耦合等

### Redis Sharding

+ redis sharding是一种客户端端sharding技术，redis cluster出来之前，业界普遍使用多redis实例集群方式。其主要思想采用哈希算法将redis数据的key进行三列，通过hash函数，特定的key会映射到特定的redis节点上。
+ 优点：优势在于非常简单，服务端的redis实例彼此独立，互相无关联，每个redis实例就像单个服务器一样运行，非常容易线性扩展，系统的灵活去也很强
+ 缺点：
  + 由于sharding处理放在客户端，规模进一步扩大时给运维带来的挑战
  + 客户端sharding不支持动态增删接地啊你。服务端redis实例群拓扑结构有变化时，每个客户端都需要更新调整。连接不能共享，当应用规模增大时，资源浪费制约优化



# 6. Redis扩展特性

## 6.1. 发布订阅模式

- 客户端订阅服务端的频道

- 当服务端向该频道中发送消息时，频道中所有的客户端都会收到该消息，执行相应的动作 

## 6.2. 事务

### 6.2.1. SQL/Redis事务对比

SQL和Redis的事务有本质的区别

- SQL事务原理
  - innodb引擎支持的事务，采用**Redo log + Undo log**来实现
- Redis事务原理
  - 使用 **乐观锁**，只负责<u>监听key</u>有没有被改动。
    - 采用watch监听某个key
    - 在执行命令时，检查该被监视的key是否已经被修改
    - 如果该key时被改动，那么事务将会被打断

【补充】与SQL事务最大的区别，<u>Redis不支持事务回滚</u>，即使事务在执行过程中出错，也不会回滚，将会一直执行下去，直到事务结束。 因为，开发者认为，事务执行失败，很少会在实际生产环境中出现。

## 6.3. 索引

 Redis没有实现索引，如果需要索引，需要用户自己设置并实现之 





## 7.2. Hash之淘宝商城购物车

## 7.3. List之微博公众号消息流

订阅了某个公众号，当该公众号发文章后，会推送给你！ 特点：消息的发送是有一个时间线的 

（微信朋友圈）

```python
LPAUSH msg:{小明微信号ID} 10018    # 发消息
LPAUSH msg:{小明微信号ID} 10011    # 发消息  
LRANGE msg:{小明微信号ID} 0 -1     # 查看最新的消息流列表
```



## 7.5.Bit位之日活量

场景：统计2020/10/03，登录用户数。现在系统有千万级活跃用户，如何实现日活统计，为了增强用户粘性，要上线一个连续打卡发放积分的功能，怎么实现连续打卡用户统计？

```python
将20201003Login作为key，offset作为每个用户，value 0/1表示都否登录，即：

Data    1  0  0  0  1  1  0 
Offset  0  1  2  3  4  5  ... ... 

Setbit 20201003Login 0 1 
Setbit 20201003Login 4 5 

bitcount 20201003Login 0 -1  # 统计日活

将20201003Login, 20201004Login,..., 20201007Login相与，之后再统计1的总个数 # 统计连续几日登录量
```



## 7.6. Set之微信抽奖小程序、微博点赞列表、微博关注模型	

无序不重复，放相同的元素，将会被去重（每个人点击多次抽奖，将会被去重，只视为一次抽奖）

场景1：微信抽奖小程序 

```python
SADD activity:10086 {用户ID}   # 用户点击抽奖按钮后，将加入set
SMEMBERS activity:10086       # 查看参与抽奖的所有用户
SRANDMEMBER activity:10086 2 SPOP activity:10086 2  # 随机抽取count名中奖者
```

场景2：微博点赞

```python
SADD like:{消息ID} {用户ID}      # 点赞
SREM like:{消息ID} {用户ID}      # 取消点赞
SISMEMBER like:{消息ID} {用户ID} # 检查用户是否点过赞
SMEMBERS like:{消息ID} {用户ID}  # 获取点赞的用户列表
SCARD like:{消息ID}             # 获取点赞用户总数
```

场景3：微博关注模型

James --\> {A,B,C} Kobe--\>{A,C,D,R} 

James、Kobe是两个集合Set 

```python
SINTER James Kobe      # 取出James和Kobe共同关注的人（交集） 
SISMEMBER James Jordan # 判断James集合中是否有Jordan 
SDIFF James Kobe       # James可能认识的人
```

场景4：Set实现电商商品类型的筛选 

```python
SADD brand:huawei P30 
SADD brand:xiaomi 6X 
SADD os:android P30 6X
SADD cpu:brand:intel P30 6X 
SADD ram:8G P30 6X
SINTER os:android cpu:brand:intel ram:8G  # -->{P30, 6X}
```



## 7.7. ZSet有序集合之微博热点排行榜

```python
ZINCRBY hotNews:20190722 1   # 点击新闻 
ZREVRANGE hotNews:20190722 0 10 WITH SCORES  # 展示当日排行前十
```

---

