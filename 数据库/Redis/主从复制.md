# 主从复制

+ 主机数据更新后根据配置和策略，自动同步到备机的master/slave机制，**Master以写为主，Slave以读为主**
+ 作用：
  + 读写分离，性能扩展
  + 容灾快速恢复

### 原理

+ 通过执行slaveof命令或者设置slaveof选项，让一个服务器去复制另外一个服务器的数据。主数据库可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从数据库。**而从数据库一般是只读的，并接受主数据库同步过来的数据。**一个数据库可以拥有多个从数据库，而一个从数据库只能有一个主数据库

+ 正常情况下，主机提供服务，并将数据同步到备份机器；当主机宕机后，备机立即开始服务 。master宕机后，通过<u>选举投票</u>方式选择出新的master，继续提供服务。

+ 实现读写分离，提高并发性

+ 复制的方式有两种：全量复制和增量复制

+ 全量复制：

  + 主节点通过bgsave命令fork子进程进行RDB持久化，RDB持久化过程是非常消耗CPU，内存（页表复制），硬盘IO
  + 主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来非常大的消耗
  + 从节点清空老数据，载入新RDB文件（载入过程是阻塞的，无法响应客户端命令）。
  + 如果从节点执行了bgrewriteaof，也会带来额外的消耗（aof复制也需要消耗资源）

+ 增量复制：

  + 复制偏移量：执行复制的双方，主从节点分别会维护一个复制偏移量offset
  + 复制积压缓存区：主节点内部维护一个固定长度的，先进先出队列作为复制积压缓冲区，**当主从节点offset的差距超过换缓存区长度时，将无法进行增量复制，只能执行全量复制**
  + 服务器运行ID（runid）：每个节点都有其运行ID，运行ID由节点在启动时自动生成，主节点会将自己的运行ID发送给从节点。从节点会将主节点的runid保存起来。从节点断开重连的时候，就是根据运行ID来判断同步的进度：
    + 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前通不过，主节点会继续尝试使用增量复制的方式（到底能不能使用增量复制还要看offset和复制积压缓存区的情况）
    + 如果从节点保存的runid与住节点现在的runid不同，说明从节点在断线前同步的redis节点并不是当前的主节点，只能进行权力复制

# 模式

### 一主多从

+ 1个主，多个从
+ 主节点挂了，从节点不会作为新的主节点，还是从节点。需要人手动切换主节点

### 薪火相传

+ 上一个Slave可以是下一个Slave的master。
+ slave同样可以接收其他slaves的连接和同步，那么该slave作为了链条中下一个的master, 可以有效减轻master的写压力,去中心化降低风险。
+ 用 slaveof <ip><port>
+ 中途变更转向:会清除之前的数据，重新建立拷贝最新的
+ 风险：一旦某个slave宕机，后面的slave都没法备份。主机挂了，从机还是从机，无法写数据了

### 反客为主

+ 当一个master宕机后，后面的slave可以立刻升为master，其后面的slave不用做任何修改。
+ 用 slaveof no one  将从机变为主机。

### 哨兵模式

+ **反客为主的自动版**，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库
+ 选择新主机的规则：
  1. 优先级在redis.conf中默认：slave-priority 100，值越小优先级越高
  2. 选择偏移量最大。偏移量是指获得原主机数据最全的
  3. 选择runid最小的每个redis实例启动后都会随机生成一个40位的runid

# 复制延时

由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。
