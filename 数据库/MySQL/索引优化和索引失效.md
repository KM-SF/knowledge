# 索引的情况

+ 需要创建索引
  + 主键自动创建唯一索引
  + 频繁作为查询条件的字段应该创建索引
  + 查询中与其它表关联的字段，外键关系建立索引
  + 频繁更新的字段不适合创建索引（因为更新字段的同时还需要更新索引树）
  + 单键/组合索引的选择问题 。（在高并发下倾向创建组合索引）
  + 查询排序的字段，排序的字段若通过索引去访问将大大提高排序的速度
  + 查询中统计或者分组字段
+ 不需要创建索引
  + 表记录太少
  + 经常增删改查的表
  + where条件用不到的字段不创建索引
  + 数据重复且分布平均的表字段，如果某个数据列包含许多重复的内容，为他建立索引就没有太大的实际效果。**因此应该只为最经常查询和最经常排序的数据列建立索引。**

# 性能分析

+ MySQL Query Optimizer
  + MySQL中有专门负责优化SELECT语句的优化器模块。主要功能：通过计算分析系统收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最有的数据检索方式，但不见得是DBA认为最有的，这部分最耗时间）
  + 当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出事SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整个Query进行优化，处理掉一些常量表达式的预算，直接换成常量值。并对Query中查询条件进行简化和转换，入去掉一些无用或显而易见的条件，结构调整等。然后Query中的Hint（如果有），看现实Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或者Hint信息还不足以完全确定执行计划，则会去读所涉及对象统计信息。根据Query进行写相应的计算分析，然后再得到最后的执行计划
+ MySQL常见瓶颈
  + CPU：CPU在饱和的时候一般发生在数据写入内存或从磁盘读取数据时候
  + IO：磁盘I/O瓶颈发生在写入数据远大于内存容量时候
  + 硬件：硬件配置过低。top，free，iostat和vmstat来查看系统的性能状态

### Explain（查看执行计划）

+ 使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈

+ 语法：explain sql语句
+ 执行结果参数分析：
  + 表的读取顺序（**id**）：slect查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
    + 情况1：id相同，执行顺序由上至下
    + 情况2：id不同，如果是子查询，id的序列号会递增，**id值最大优先级越高，越先被执行**
    + 情况3：id出现部分相同，部分不同情况。执行情况遵循情况1和2
  + 数据读取操作的操作类型（**select_type**）：查询的类型，主要用于区别普通查询，联合查询，子查询等的复合查询
    + SIMPLE：简单的select查询，查询中不包括子查询或者UINON
    + PRIMARY：查询中若包含任何复杂的字部分，最外层查询则被标记位PRIMARY
    + SUBQUERY：在select活where列表中包含了子查询（=）
    + DEPENDENT SUBQUERY：在select或者where列表中包含了子查询（范围），子查询基于外层
    + UNCACHEABLE SUBQUERY：where出现了系统变量
    + DERIVED：在FROM列表中包含的子查询被标记位DERIVED（衍生）。MySQL会递归执行这些子查询，把结果放在临时表里
    + UNION：若第二个select出现在UNION之后，则被标记位UINON。若UNION包含在FROM子句的子查询中，外层SELECT将被标记位DERIVED
    + UNION RESULT：从UNION表获取结果的SELECT
  + 数据的来源（**table**）：显示这一行的数据是关于哪张表
  + 访问类型（**type**）：显示查询使用了何种类型，从最好到最差依次是：**system>const>eq_ref>ref>rang>index>ALL（常用的type）**。**一般得保证查询至少达到ange级别，最好能达到ref**
    + system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计
    + const：表示通过索引依次就找到了，const用于比较primary key或者unique索引。因为值匹配**一行数据**，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量
    + eq_ref：**唯一索引**扫描，对于每个索引键，表中只有**一条**记录与之匹配。常见于主键或者唯一索引扫描
    + ref：**非唯一性**索引扫描，返回匹配某个单独值的**所有行**。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然后，它可能会找到多个复合条件的行，所以他应该属于查找和扫描的混合体
    + range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，**一般就是在你的where语句中出现了between，<，>，in等的查询。**这种范围扫描索引扫描比全表扫描要好。因为它只需要开始于索引的某一点，而结束语另外一点，不用扫描全部索引
    + index：Full Index Scan，index与ALL区别为index类型**只遍历索引树。**这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取，而all从硬盘中读取）
    + all：Full Table Scan，将遍历全表以找到匹配的行
  + 哪些索引可能被使用（**possible_keys**）：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，但是**不一定被查询实际使用**
  + 哪些索引被实际使用（**key**）：实际使用的索引，如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在key列表中
  + key_len：显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据定义计算而得，不是通过表内检索出来的
  + 表之间的引用（**ref**）：显示索引的哪一列被使用了，如果可能的话，是一个常量。哪些列或者常量被用于查找索引列的值
  + 每张表有多少行被优化器查询（**row**）：根据表统计信息及索引选用情况，大致估算出找到所需要记录的行数
  + 额外信息（**Extra**）：包含不适合在其他列显示但是十分重要的额外信息
    + **Using filesort**：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL无法利用索引完成的排序操作称为“文件排序”
    + **Using temporary**：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见排序order by和分组查询group by
    + **Using Index**：表示相应的 select操作中使用了覆盖索引，避免访问了表的数据行，效率不错。如果同时出现了using where，表明索引被用来执行索引键值的查询。如果没有同时出现using where，表明索引用来读取数据而非执行查询动作
    + Using Where：使用where
    + Using join buffer：使用了连接缓存
    + impossible where：where子句的值总是false（where子句条件不成立）
    + select tables Optimized away：在没有Group By子句的情况下，基于索引优化MIN/MAX操作。
    + distinct：优化distinct操作，在找到第一匹配的元组后停止找到同样值的动作

## 索引优化

+ join语句的优化：
  + 尽可能减少join语句中的NestedLoop的循环总次数
  + 永远用小结果集驱动大结果集
  + 优化NestedLoop的内层循环
  + 保证join语句中被驱动表上Join条件字段已经被索引
  + 当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬JoinBuffer设置
+ 优化口诀
  + 全值匹配我最爱，最左前缀要遵守
  + 带头大哥不能死，中间兄弟不能断
  + 索引列上少计算，范围之后全失效
  + like百分写最右，覆盖索引不写*
  + 不等空值还有or，索引失效要少用

## 索引失效

+ 索引失效的常见情况
  + 全值匹配（这种不会导致失效，是最好的情况）
  + **最佳左前缀法则：如果索引了多列，要遵守最左前缀法则。查询从索引的最左前列开始并且不跳过索引中的列。**
  + 不在索引列上做任何操作（计算，函数，（自动或手动）类型转换），会导致索引失效而转向全表扫描
  + 存储引擎不能使用索引中范围条件，右边的列都失效
  + 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一直）），减少select *
  + mysql在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描
  + is null，is not null也无法使用索引
  + like以通配符开头（'%string'）mysql索引失效会导致全表扫描的操作。
    + like ‘%string%’这种情况，可以使用覆盖索引解决索引失效问题
  + 字符串不加单引号索引失效
  + 少用or，用它来连接时会索引失效
+ 建议：
  + 对于单键索引，尽量选择针对当前query过滤性更好的索引
  + 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好
  + 在选择组合索引的时候，经理选择可以能够包含当前query的where子句中更多字段的索引
  + 尽可能通过分析统计信息和调整query的写法来达到选择适合索引的目的

## 优化建议

### 单表

1. 对于单键索引，尽量选择针对当前query过滤性更好的索引
2. 在选择组合索引时，当前query中过滤性最好的字段在索引字段顺序中，位置越前越好
3. 在选择组合索引时，尽量选择可以能够包含当前query中的where字句中更多字段的索引
4. 在选择组合索引时，如果某个字段可能初夏你范围查询时，尽量把这个字段放在索引顺序的最后面
5. 书写sql语句时，尽量避免造成索引失效的情况

### 关联查询

1. 保证被驱动表的join字段已经被索引
2. left join时，选择小表驱动大表，大表作位被驱动表
3. inner join时，mysql会自动帮你选择小表为驱动表
4. 子查询尽量不要放在被驱动表，有可能使用不到索引
5. 能够直接多表关联的尽量直接关联，不要子查询

### 子查询

1. 尽量不要使用not in或者not exists
2. 可以使用left outer join on xxx is null替代

### 排序查询

1. 无过滤不索引
2. 顺序错，必排序
3. 方向反，必排序
4. order by字句，尽量使用index方式排序，避免使用filesort方式排序