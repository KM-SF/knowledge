## 锁的分类

### 按照对数据的操作类型

+ 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响
+ 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁

### 按照对数据的粒度

+ 表锁（偏读）
  + 特点：偏向MyISAM存储引擎，开销小，枷锁快，无死锁。粒度大，发生锁冲突概率高，并发度小
+ 行锁（偏写）
  + 特点：偏向InnoDB存储引擎，开销大，加锁慢，会出现死锁。粒度小，发生锁冲突概率小，并发度大。
+ 页锁：开销和加锁时间介于表锁和行锁之间。会出现死锁。锁粒度介于表锁和行锁之家你，并发度一般

### 总结

#### MyISAM引擎

+ MyISAM在执行查询语句（select）前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给涉及表加行锁
+ 对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读请求，但阻塞对同一表的写请求。只有当读锁释放后才会执行其他进程的写操作
+ 对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写请求，只有当写锁释放后才会执行其他进程的写操作
+ MyISAM的读写锁调度室写优先，这也是MyISAM不适合做写为主表的引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永久阻塞
+ **读锁会阻塞写，但是不会阻塞读。而写锁会把读写都阻塞**

| 锁类型 | 可否兼容 | 读锁 | 写锁 |
| ------ | -------- | ---- | ---- |
| 读锁   | 是       | 是   | 否   |
| 写锁   | 是       | 否   | 否   |

+ session1对表加了**读**锁
  + session1 不能查询其他没有锁定的表
  + session1 不能修改表的数据
  + 其他session也可以查询该表
  + 其他session可以查询和更新其他未锁定的表
  + 其他session修改该表的数据会阻塞，一直等待解锁，才执行。
+ session1对表加了**写**锁
  + session1 不能查询其他没有锁定的表
  + session1能修改表的数据
  + 其他session对该表进行操作会被阻塞，需要等待锁释放

##### 语法

+ 查看表的枷锁情况：show open tables
+ 对表枷锁：lock table 表名字 read/write（读锁/写锁）
+ 对表解锁：unlock tables
+ 查询表锁的使用情况：show status like 'table%'
  + table_locks_immediate：产生表级锁定的次数。表示可以立即获得锁的查询次数，每立即获得锁值加1
  + table_locks_waited：出现表级锁定征用而发生等待次数（不能立即获得锁的次数，每等待1次锁值加1）。该数值越高表明表级抢锁情况越严重

#### InnoDB引擎

+ InnoDB与MyISAM最大两个不同点：一是支持事务，二是采用行级锁
+ InnoDB引擎存在间隙锁：当我们用**范围条件**而不是相等条件检索数据，并请求共享或排它锁时InnoDB会给符合条件的已有数据的索引项**（不存在的数据也会）**加锁。对于键值在条件范围内比你高不存在的记录，叫做“间隙”。InnoDB也会对这个“间隙”加锁，这种锁机制就是间隙锁
+ **Innodb自动使用间隙锁的条件**：① 采用RR级别 ② 检索条件必须有索引（否则，会升级为表锁）
+ 间隙锁的危害：
  + 因为query执行过程中通过范围查找的话，他会锁定整个范围内所有的索引键值，即使这个键值不存在。
  + 间隙锁有一个比较致命的弱点：当锁定一个范围键值之后，即使某些不存在的键值也会被无辜加锁，**而造成在加锁的时候无法插入加锁范围内的任何数据**
+ 优化建议：
  + 尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁
  + 合理设计索引，尽量缩小锁的范围
  + 尽可能较少检索条件，避免间隙锁
  + 建立控制事务大小，减少加锁资源量和时间
  + 尽可能低级别事务隔离
+ **目的**：防止幻读 
  + 防止间隙内有数据被插入；
  + 防止已存在的数据，更新成间隙内的数据

##### 语法

+ **锁定一行：**

  ```mysql
  begin;
  select * from table where key=val for update; # 个for update就是锁某一行。该行一直到commit才解锁
  commit
  ```

+ 锁区域：

  ```mysql
  set autocommit=0; # 将自动提交关闭
  sql1; # 直到commit才解锁
  sql2; # 直到commit才解锁
  sql3; # 直到commit才解锁
  commit;
  ```

+ 查看锁的使用情况：show status like 'innodb_row_lock%';

  + innode_row_lock_current_waits：当前正在等待锁的数量
  + **innode_row_lock_time：从系统启动到现在锁定总时间长度**
  + **innode_row_lock_time_avg：每次等待锁需要的平均时间**
  + innode_row_lock_time_max：从系统启动到现在等待最长的一次时间
  + **innode_row_lock_waits：系统启动后到现在总共等待的次数**
  + 当等待次数很高，而每次等待时间也不小的时候，需要分析原因

### InnoDB和MyISAM引擎区别

+ InnoDB是采用了行锁，在锁机制方面所带来的性能消耗可能比表锁会更高一些，但是正在整体并发处理能力方面要远远优于MyISAM的表锁。当系统并发量较高的时候，InnoDB的整体性能会比MyISAM有比较明显的优势。
+ InnoDB的行锁同样也有脆弱的一面，当我们使用不当的时候，可能会让InnoDB的整体性能 表现不仅没有MyISAM好，有可能会更差

