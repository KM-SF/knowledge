# 索引

+ 性能下降的原因可能是：
  1. 执行时间长
  2. 等待时间长
+ 实际原因：
  1. 查询语句写的差（没有用索引，各种子查询等等）
  2. 索引失效
  3. 关联查询join太多（设计缺陷或者不得已的需求）
  4. 服务器调优以及各个参数设置（缓存，线程数等）

+ 索引定义：索引（Index）是帮助MySQL搞笑获取数据的数据结构。本质就是数据结构，**简单理解为“排好序的快速查找数据结构”。**
+ 在数据之外，数据库系统害维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这也就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引（B树索引）
+ 作用：目的在于提高查询下来，可以类比字典。
+ 注意：
  + 索引会影响到where后的查找和order by后的排序
  + 索引本身也很大，不可能全部存储在内存中，往往以索引文件的形式存储在磁盘上
  + 索引果没有特别指明，都是**B树（多路搜索树，并不一定是二叉树）结构组织的索引**。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用**B+树索引，统称索引。**除了B+树这种索引外，还有哈希索引

+ 优缺点：

  |                 优点                 |                             缺点                             |
  | :----------------------------------: | :----------------------------------------------------------: |
  | 提高数据检索的效率，降低数据的IO成本 |      索引也是一张表，该保存了主键与索引字段。也要占空间      |
  | 降低数据排序的成本，降低了CPU的消耗  | 虽然提高了查询的速度，但是降低更新表的速度（INSERT，UPDATE和DELETE）<br>因为更新表时，不仅要更新数据，还要更新索引文件中的索引列的字段 |
  |                                      |        索引只是提高效率的一个因素。还要设计最优的索引        |

+ 索引分类：
  + 单值索引：一个索只包含单个列，一个表可以有多个单列多音
  + 唯一索引：索引列的值必须唯一，但允许有空值
  + 复合索引：一个索引包含多个列
+ 索引结构
  + BTree索引
  + Hash索引
  + full-text全文索引
  + R-Tree索引
  
+ 覆盖索引（或者叫索引覆盖）：就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话查询列要被所建的索引覆盖

# 语法

+ 基本语法：
  + 创建：CREATE [UNIQUE] INDEX indexName ON tableName(columName(length));
    + UNIQUE：加了就是唯一索引
    + columName：一个列名就是单值索引，多个列名就是复合索引
  +   更新：ALTER tableName ADD  [UNIQUE] INDEX indexName ON (columName(length));
    + UNIQUE：加了就是唯一索引
    + columname：一个列名就是单值索引，多个列名就是复合索引
  + 删除：DROP INDEX [indexName] ON tableName;
  + 查看：SHOW INDEX FROM tableName;
+ 四种方式添加索引：
  + ALTER TABLE table_name ADD PRIMARY KEY (column_list)：添加一个主键，这意味着索引值必须是唯一的，且不能为NULL
  + ALTER TABLE table_name UNIQUE index_name (column_list)：创建索引的值必须唯一的（出了NULL外，NULL可能会出现多次）
  + ALTER TABLE table_name ADD INDEX index_name (column_list)：添加普通索引，索引值可能出现多次
  + ALTER TABLE table_name ADD FULLTEXT index_name (column_list)：指定了索引为FULLTEXT，用于全文索引

# 索引的情况

+ 需要创建索引
  + 主键自动创建唯一索引
  + 频繁作为查询条件的字段应该创建索引
  + 查询中与其它表关联的字段，外键关系建立索引
  + 频繁更新的字段不适合创建索引（因为更新字段的同时还需要更新索引树）
  + where条件用不到的字段不创建索引
  + 单键/组合索引的选择问题 。（在高并发下倾向创建组合索引）
  + 查询排序的字段，排序的字段若通过索引去访问将大大提高排序的速度
  + 查询中统计或者分组字段
+ 不需要创建索引
  + 表记录太少
  + 经常增删改查的表
  + 数据重复且分布平均的表字段，如果某个数据列包含许多重复的内容，为他建立索引就没有太大的实际效果。**因此应该只为最经常查询和最经常排序的数据列建立索引。**

# 性能分析

+ MySQL Query Optimizer
  + MySQL中有专门负责优化SELECT语句的优化器模块。主要功能：通过计算分析系统收集到的统计信息，为客户端请求的Query提供他认为最优的执行计划（他认为最有的数据检索方式，但不见得是DBA认为最有的，这部分最耗时间）
  + 当客户端向MySQL请求一条Query，命令解析器模块完成请求分类，区别出事SELECT并转发给MySQL Query Optimizer时，MySQL Query Optimizer首先会对整个Query进行优化，处理掉一些常量表达式的预算，直接换成常量值。并对Query中查询条件进行简化和转换，入去掉一些无用或显而易见的条件，结构调整等。然后Query中的Hint（如果有），看现实Hint信息是否可以完全确定该Query的执行计划。如果没有Hint或者Hint信息还不足以完全确定执行计划，则会去读所涉及对象统计信息。根据Query进行写相应的计算分析，然后再得到最后的执行计划
+ MySQL常见瓶颈
  + CPU：CPU在饱和的时候一般发生在数据写入内存或从磁盘读取数据时候
  + IO：磁盘I/O瓶颈发生在写入数据远大于内存容量时候
  + 硬件：硬件配置过低。top，free，iostat和vmstat来查看系统的性能状态

### Explain（优化执行计划）

+ 语法：explain sql语句
+ 执行结果参数分析：
  + 表的读取顺序（**id**）：slect查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
    + 情况1：id相同，执行顺序由上至下
    + 情况2：id不同，如果是子查询，id的序列号会递增，**id值最大优先级越高，越先被执行**
    + 情况3：id出现部分相同，部分不同情况。执行情况遵循情况1和2
  + 数据读取操作的操作类型（**select_type**）：查询的类型，主要用于区别普通查询，联合查询，子查询等的复合查询
    + SIMPLE：简单的select查询，查询中不包括子查询或者UINON
    + PRIMARY：查询中若包含任何复杂的字部分，最外层查询则被标记位PRIMARY
    + SUBQUERY：在select活where列表中包含了子查询
    + DERIVED：在FROM列表中包含的子查询被标记位DERIVED（衍生）。MySQL会递归执行这些子查询，把结果放在临时表里
    + UNION：若第二个select出现在UNION之后，则被标记位UINON。若UNION包含在FROM子句的子查询中，外层SELECT将被标记位DERIVED
    + UNION RESULT：从UNION表获取结果的SELECT
  + 数据的来源（**table**）：显示这一行的数据是关于哪张表
  + 访问类型（**type**）：显示查询使用了何种类型，从最好到最差依次是：**system>const>eq_ref>ref>rang>index>ALL（常用的type）**。**一般得保证查询至少达到ange级别，最好能达到ref**
    + system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计
    + const：表示通过索引依次就找到了，const用于比较primary key或者unique索引。因为值匹配**一行数据**，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量
    + eq_ref：**唯一索引**扫描，对于每个索引键，表中只有**一条**记录与之匹配。常见于主键或者唯一索引扫描
    + ref：**非唯一性**索引扫描，返回匹配某个单独值的**所有行**。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然后，它可能会找到多个复合条件的行，所以他应该属于查找和扫描的混合体
    + range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，**一般就是在你的where语句中出现了between，<，>，in等的查询。**这种范围扫描索引扫描比全表扫描要好。因为它只需要开始于索引的某一点，而结束语另外一点，不用扫描全部索引
    + index：Full Index Scan，index与ALL区别为index类型**只遍历索引树。**这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取，而all从硬盘中读取）
    + all：Full Table Scan，将遍历全表以找到匹配的行
  + 哪些索引可能被使用（**possible_keys**）：显示可能应用在这张表中的索引，一个或者多个。查询涉及到的字段上若存在索引，则该索引将被列出，但是**不一定被查询实际使用**
  + 哪些索引被实际使用（**key**）：实际使用的索引，如果为NULL，则没有使用索引。查询中若使用了覆盖索引，则该索引仅出现在key列表中
  + key_len：显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据定义计算而得，不是通过表内检索出来的
  + 表之间的引用（**ref**）：显示索引的哪一列被使用了，如果可能的话，是一个常量。哪些列或者常量被用于查找索引列的值
  + 每张表有多少行被优化器查询（**row**）：根据表统计信息及索引选用情况，大致估算出找到所需要记录的行数
  + 额外信息（**Extra**）：包含不适合在其他列显示但是十分重要的额外信息
    + **Using filesort**：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL无法利用索引完成的排序操作称为“文件排序”
    + **Using temporary**：使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见排序order by和分组查询group by
    + **Using Index**：表示相应的 select操作中使用了覆盖索引，避免访问了表的数据行，效率不错。如果同时出现了using where，表明索引被用来执行索引键值的查询。如果没有同时出现using where，表明索引用来读取数据而非执行查询动作
    + Using Where：使用where
    + Using join buffer：使用了连接缓存
    + impossible where：where子句的值总是false（where子句条件不成立）
    + select tables Optimized away：在没有Group By子句的情况下，基于索引优化MIN/MAX操作。
    + distinct：优化distinct操作，在找到第一匹配的元组后停止找到同样值的动作