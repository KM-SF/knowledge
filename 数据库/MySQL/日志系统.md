！！！知识来自：https://blog.csdn.net/u010002184/article/details/88526708！！！

# 日志系统

+ 日志系统主要有redo log（重做日志）undo log（回滚日志）和binlog（归档日志）
+ redo log是InnoDB存储引擎层的日志，提供前滚操作，记录的是“在某个数据页上做了什么修改”
+ binlog是MySQL Server层记录的日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”
+ 两者都是记录了某些操作的日志(不是所有)自然有些重复（但两者记录的格式不同）。
+ undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志：
+ redo log通常是物理日志，记录的是数据页的物理修改，而不是某一行或某几行修改成怎样怎样，它用来恢复提交后的物理数据页(恢复数据页，且只能恢复到最后一次提交的位置
+ undo用来回滚行记录到某个版本。undo log一般是逻辑日志，根据每行记录进行记录。
+ **undo日志用于记录事务开始前的状态，用于事务失败时的回滚操作；redo日志记录事务执行后的状态，用来恢复未写入data file的已成功事务更新的数据**
  + 例如某一事务的事务序号为T1，其对数据X进行修改，设X的原值是5，修改后的值为15，那么Undo日志为<T1, X, 5>，Redo日志为<T1, X, 15>。

# 名词

+ 数据库数据存放的文件称为data file
+ 日志文件称为log file
+ 数据库数据是有缓存的，如果没有缓存，每次都写或者读物理disk，那性能就太低下了。
+ 数据库数据的缓存称为data buffer
+ 日志（redo）缓存称为log buffer
+ 既然数据库数据有缓存，就很难保证缓存数据（脏数据）与磁盘数据的一致性

# 重做日志（redo log）

+ redo log是InnoDB存储引擎层的日志，又称重做日志文件，用于记录事务操作的变化，记录的是数据修改之后的值，不管事务是否提交都会记录下来。在实例和介质失败（media failure）时，redo log文件就能派上用场，如数据库掉电，InnoDB存储引擎会使用redo log恢复到掉电前的时刻，以此来保证数据的完整性。
+ 在一条更新语句进行执行的时候，InnoDB引擎会把更新记录写到redo log日志中，然后更新内存，此时算是语句执行完了，然后在空闲的时候或者是按照设定的更新策略将redo log中的内容更新到磁盘中，这里涉及到`WAL`即`Write Ahead logging`技术，他的关键点是先写日志，再写磁盘。
+ 有了redo log日志，那么在数据库进行异常重启的时候，可以根据redo log日志进行恢复，也就达到了`crash-safe`。
+ redo log日志的大小是固定的，即记录满了以后就从头循环写。
+ **作用：**确保事务的持久性。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特性。

# 回滚日志（undo log）

+ **作用：**保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读
+ 当事务失败时，则就从undo log中回滚版本

# 二进制日志（binlog）

+ binlog是属于MySQL Server层面的，又称为归档日志，属于逻辑日志，是以二进制的形式记录的是这个语句的原始逻辑，依靠binlog是没有`crash-safe`能力的
+ **作用：**用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。 
  用于数据库的基于时间点的还原。

## 区别

- redo log是属于innoDB层面，binlog属于MySQL Server层面的，这样在数据库用别的存储引擎时可以达到一致性的要求。
- redo log是物理日志，记录该数据页更新的内容；binlog是逻辑日志，记录的是这个更新语句的原始逻辑
- redo log是循环写，日志空间大小固定；binlog是追加写，是指一份写到一定大小的时候会更换下一个文件，不会覆盖。
- binlog可以作为恢复数据使用，主从复制搭建，redo log作为异常宕机或者介质故障后的数据恢复使用。

### 一条更新语句执行的顺序

update T set c=c+1 where ID=2;

- 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。
- 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
- 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
- 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。

## 事务执行过程

梳理下事务执行的各个阶段：

1. 写undo日志到log buffer；
2. 执行事务，并写redo日志到log buffer；
3. 如果innodb_flush_log_at_trx_commit=1，则将redo日志写到log file，并刷新落盘。
4. 提交事务。

#### 可能有同学会问，为什么没有写data file，事务就提交了？

+ 在数据库的世界里，数据从来都不重要，日志才是最重要的，有了日志就有了一切。

+ 因为data buffer中的数据会在合适的时间 由存储引擎写入到data file，如果在写入之前，数据库宕机了，根据落盘的redo日志，完全可以将事务更改的数据恢复。好了，看出日志的重要性了吧。先持久化日志的策略叫做Write Ahead Log，即预写日志。