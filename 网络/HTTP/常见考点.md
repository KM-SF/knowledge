### 在浏览器地址栏键入URL，按下回车之后会经历以下流程：

1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址；
2. 解析出 IP 地址后，根据该 IP 地址和默认端口80，和服务器建立TCP连接；
3. 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；
4. 服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器；
5. 释放 TCP连接；
6. 浏览器将该 html 文本并显示内容；

### GET和POST的区别

1. 概括：
   1. 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
   2. POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）

2. 区别：get参数通过url传递，post放在request body中。
3. get请求在url中传递的参数是有长度限制的，而post没有。
4. get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
5. get请求只能进行url编码，而post支持多种编码方式。
6. get请求会浏览器主动cache
7. get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
8. GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。
9. GET产生一个TCP数据包；POST产生两个TCP数据包。(1的情况)

### HTTP和HTTPS区别

+ HTTP特点：
  + 无状态：协议对客户端没有状态存储，对事物处理没有记忆能力。例如访问一个网站需要反复进行登录操作
  + 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP3次握手4次挥手，和服务器重新建立连接。例如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次都需要重新响应请求，需要消耗不必要的资源
  + 基于请求和响应：基本的特性，由客户端发起请求，服务端响应
  + 简单快速，灵活
  + 通信是使用**明文**，请求和响应不会对通信方进行确认，无法保护数据完整性
+ HTTPS特点：
  + 内容加密：采用混合加密技术，中间者无法直接查看明文内容
  + 验证身份，通过证书认证客户端访问的是不是正确的服务器
  + 保护数据完整性：防止传输的内容不被中间人冒充或者篡改
+ 区别：
  + 最简单的，HTTP 在地址栏上的协议是以 `http://` 开头，而 HTTPS 在地址栏上的协议是以 `https://` 开头
  + HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 **密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法** 能够解决上面这些问题。
  + HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。

###  HTTP/2.0

与HTTP/1.x相比，HTTP/2.0做了哪些改进呢？

- **多路复用**：允许在同一个时刻，对同一URL发起多次请求，同时对多次请求予以相应

  - HTTP/1.x，浏览器在同一个时间，请求同一URL具有一定数量的限制，超过该数量上限的请求都会被阻塞。
  - HTTP/2.0虽然只有一条TCP连接，但是在裸机上分成了很多stream

- 二进制分帧

  - 在不改动HTTP/1.x的语义/方法/状态码/URI等的情况下，HTTP/2.0是如何做到（突破HTTP/1.x的性能限制，改善传输性能，实现低延迟和高吞吐量）的呢？

  - 答：在应用层、传输层之间增加一个二进制分帧层！

    在二进制分帧层中，HTTP/2.0会将所有传输的信息分割成更小的消息和帧，并对它们采用二进制格式的编码

- 请求优先级

- 流量控制：类似于TCP滑动窗口来控制流量，数据接收方通过告诉发送方它能接收的窗口大小

- 服务器推送：客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器会将资源Z一起推送给客户端

- **首部压缩**

- TLS：更安全的SSL

### HTTP1.1和HTTP2.0

**HTTP1.1**

- 持久连接
- 请求管道化
- 增加缓存处理（新的字段如cache-control）
- 增加 Host 字段、支持断点传输等

**HTTP2.0**

- 二进制分帧
- 多路复用（或连接共享）
- 头部压缩
- 服务器推送

### HTTP请求报文与响应报文格式

请求报文包含三部分：

1. 请求行：包含请求方法、URI、HTTP版本信息。它们用空格分隔。例如，GET /index.html HTTP/1.1。

2. 请求首部字段：请求头部由关键字/值对组成，每行一对，关键字和值用英文冒号“:”分隔

3. 请求内容实体：请求携带的数据

响应报文包含三部分：

1. 状态行：包含HTTP版本、状态码、状态码的原因短语。例如`HTTP/1.1 200 OK`。

2. 响应首部字段

3. 响应内容实体

### Session和cookie的区别

1. Cookie保存在客户端，未设置存储时间的Cookie，关闭浏览器会话Cookie就会被删除；设置了存储时间的Cookie保存在用户设备的磁盘中知道过期，同时Cookie在客户端所以可以伪造，不是十分安全，敏感数据不易保存。Session保存在服务器端，存储在IIS的进程开辟的内存中，而Session过多会消耗服务器资源，所以尽量少使用Session。

2. Session是服务器用来跟踪用户的一种手段，每个Session都有一个唯一标识：session ID。当服务端生成一个Session时就会向客户端发送一个Cookie保存到客户端，**这个Cookie保存的是Session的SessionId这样才能保证客户端发起请求后**，用户能够与服务器端成千上万的Session进行匹配，同时也保证了不同页面之间传值的正确性.

3. 存储数据类型不同：Session能够存储任意的JAVA对象，Cookie只能存储String类型的对象。

4. 长于10K的数据，不要用到Cookies。

### HTTP的状态码

内容很多，重点看标『✨』内容

**2XX 成功**

- 200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨
- 201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立
- 202 Accepted 请求已接受，但是还没执行，不保证完成请求
- 204 No content，表示请求成功，但响应报文不含实体的主体部分
- 206 Partial Content，进行范围请求 ✨

**3XX 重定向**

- 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
- 302 found，临时性重定向，表示资源临时被分配了新的 URL ✨
- 303 see other，表示资源存在着另一个 URL，应使用 GET 方法丁香获取资源
- 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
- 307 temporary redirect，临时重定向，和302含义相同

**4XX 客户端错误**

- 400 bad request，请求报文存在语法错误 ✨
- 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨
- 403 forbidden，表示对请求资源的访问被服务器拒绝 ✨
- 404 not found，表示在服务器上没有找到请求的资源 ✨
- 408 Request timeout, 客户端请求超时
- 409 Confict, 请求的资源可能引起冲突

**5XX 服务器错误**

- 500 internal sever error，表示服务器端在执行请求时发生了错误 ✨
- 501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法
- 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
- 505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本

### HTTP的keep-alive是干什么的？

在早期的HTTP/1.0中，每次http请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的HTTP/1.0中以及HTTP/1.1中，引入了重用连接的机制，就是在http请求头中加入Connection: keep-alive来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定HTTP/1.0如果想要保持长连接，需要在请求头中加上Connection: keep-alive。

keep-alive的优点：

- 较少的CPU和内存的使用（由于同时打开的连接的减少了）
- 允许请求和应答的HTTP管线化
- 降低拥塞控制 （TCP连接减少了）
- 减少了后续请求的延迟（无需再进行握手）
- 报告错误无需关闭TCP连

### HTTP2相对于HTTP1.x有什么优势和特点？

#### 二进制分帧

帧：HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。

流：存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID

HTTP/2 采用二进制格式传输数据，而非 HTTP 1.x 的文本格式，二进制协议解析起来更高效。

#### 服务器推送

服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。

服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。

#### 头部压缩

HTTP/1.x会在请求和响应中中重复地携带不常改变的、冗长的头部数据，给网络带来额外的负担。

你可以理解为只发送差异数据，而不是全部发送，从而减少头部的信息量

- HTTP/2在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送
- 首部表在HTTP/2的连接存续期内始终存在，由客户端和服务器共同渐进地更新;
- 每个新的首部键－值对要么被追加到当前表的末尾，要么替换表中之前的值。

#### 多路复用

HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。

HTTP2中：

- 同域名下所有通信都在单个连接上完成。
- 单个连接可以承载任意数量的双向数据流。
- 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装

### HTTPS 是什么？

HTTPS ，实际就是在 TCP 层与 HTTP 层之间加入了 SSL/TLS 来为上层的安全保驾护航，主要用到对称加密、非对称加密、证书，等技术进行客户端与服务器的数据加密传输，最终达到保证整个通信的安全性。

### 为什么有了HTTP为什么还要HTTPS？

https是安全版的http，因为http协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS就是为了解决HTTP的不安全而生的。

### HTTPS是如何保证安全的？

**对称加密：**

即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密

对称加密虽然很简单性能也好，但是无法解决首次把秘钥发给对方的问题，很容易被hacker拦截秘钥。

**非对称加密：**

1. 私钥 + 公钥= 密钥对
2. 即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密
3. 因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方
4. 然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密

非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。

**解决方案：**

那么结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。

此时又带来一个问题，中间人问题：

如果此时在客户端和服务器之间存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。

所以这个时候需要一个安全的第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。

证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的HASH算法、证书到期时间等

### RPC和HTTP的区别

**传输协议**

RPC:可以基于TCP协议，也可以基于HTTP协议

HTTP:基于HTTP协议

**传输效率**

RPC:使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2协议，也可以很好的减少报文的体积，提高传输效率

HTTP:如果是基于HTTP1.1的协议，请求中会包含很多无用的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为一个RPC来使用的，这时标准RPC框架更多的是服务治理

**性能消耗**

RPC:高效的二进制传输

HTTP:大部分是通过json来实现的，字节大小和序列化耗时都比二进制要更消耗性能

**跨语言/跨平台**

RPC对跨平台和跨语言不太友好，HTTP可以实现跨语言和跨平台

**负载均衡**

RPC：基本都自带了负载均衡策略

HTTP：需要配置Nginx，HAProxy来实现

**服务治理**

RPC：能做到自动通知，不影响上游

HTTP:需要事先通知，修改Nginx/HAProxy配置