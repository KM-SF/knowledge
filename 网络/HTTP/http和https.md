# 一. HTTP协议

+ http（超文本传输协议）：一种无状态的，以请求应答方式运行的协议，它使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。HTTP 协议自身不对请求和响应之间的通信状态进行保存，协议对于发送过的请求或响应都不做持久化处理
+ HTTP协议版本

| 版本     | 内容                                                            |
| -------- | --------------------------------------------------------------- |
| HTTP/0.9 | 不涉及数据包传输，规定客户端与服务端之间的通信格式，只能GET请求 |
| HTTP/1.0 | 传输内容格式不限制，增加PUT,PATCH,HEAD,OPTIONS,DELETE模式       |
| HTTP/1.1 | 持久链接（长链接），节约带宽，HOST域，管道机制，分块传输，编码  |
| HTTP/2   | 多路复用，服务器推送，头信息压缩，二进制协议等                  |

## 1. HTTP特点

- 无连接：一请求，一连接。即：每次请求都会建立连接，请求完成后，就断开连接
- 无状态：不保存上次请求的状态信息

HTTP上面的2个特点，会带来缺点，即：每次请求不会保持上一次的状态，比如，在购物网站中，如果用户登录了信息，在点击下一个网页后，连接将会断开，需要重新再次输入账号/密码登录，这样十分麻烦。因此引入了HTTP-keepalive保持连接，Cookie、Session保存状态

- keepalive
  - 持久连接（长连接）：减少连接/断开的次数，降低消耗
  - 只要某一端没有明确提出断开连接，就会保持TCP连接状态

- Cookie
  - 保存在客户端
  - 客户端向服务端发起请求后，服务端会生成Cookie返回给客户端；客户端之后将会保存Cookie；当再次访问时，将会把Cookie放在报文头中传给服务端；服务端收到Cookie后，解析Cookie，发现这个请求是客户端A发来的，就直接可以向客户端A回复响应
- Session
  - 会话，保存在服务端
  - 比如：XShell，在第一次登录时，会生成Session，保存起来，它是保存在服务端的内存中

## 2. HTTP报文格式

+ HTTP协议的请求报文和响应报文的结构基本相同，由三大部分组成：

  + 起始行（start line）：描述请求或响应的基本信息
  + 头部字段集合（header）：使用kv形式更详细的说明了报文
  + 消息正文（entity）：实际传输的数据，他不一定是纯文本，可以是图片，视频等二进制数据

  ![HTTP协议格式](/网络/images/HTTP协议格式.png)

### 2.1 请求行报文格式

![请求行报文格式](/网络/images/请求行报文格式.png)

+ 请求方法：如GET/HEAD/PUT/POST/DELETE 表示对资源的操作
+ 请求目标：通常是一个URI，标记了请求方法要操作的资源
+ 版本号：表示报文使用的HTTP协议版本

#### 2.1.1 请求方法（Request Method）

+ GET：请求资源
+ POST：提交资源
+ HEAD：获取响应头，HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。
+ PUT：替换资源
+ DELETE：删除资源
+ OPTIONS：查询针对请求 URI 指定的资源支持的方法
+ TRACE：回显服务器收到的请求，用于测试或者诊断
+ CONNECT：要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。

### 2.2 响应行报文格式

![响应行报文格式](/网络/images/响应行报文格式.png)

+ 版本号：表示报文使用的HTTP协议版本
+ 状态码：一个三位数，用代码表示处理的结果，例如：200是成功，500是服务器错误
+ 原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因

#### 2.2.1 状态码（Status Code）

+ 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作

| 状态码 | 描述                      |
| ------ | ------------------------- |
| 1xx    | 提示信息，请求被成功接收  |
| 2xx    | 成功，请求呗成功处理：200 |
| 3xx    | 重定向相关：304           |
| 4xx    | 客户端错误：404           |
| 5xx    | 服务器错误：500           |

#### 2.2.2 常见状态码

| 常见状态码                   | 描述                                                                                                                                                                                                                                      |
| ---------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 200（OK）                    | 从客户端发来的请求在服务器端被正常处理了                                                                                                                                                                                                  |
| 204（No Content）            | 服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分，另外，也不允许返回任何实体的主体                                                                                                                                      |
| 206（Partial Content）       | 客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容                                                                                                                               |
| 301（Moved Permanently）     | 永久性重定向。表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。                                                           |
| 302（Found）                 | 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问                                                                                                                                               |
| 303（See Other）             | 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。                                                                                                                                                        |
| 304（Not Modified）          | 该状态码表示客户端发送**附带条件的请求**时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。                                                 |
| 400（Bad Request）           | 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。                                                                                                                                                        |
| 401（Unauthorized）          | 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用 户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。 |
| 403（Forbidden）             | 权限不足，该状态码表明对请求资源的访问被服务器拒绝了                                                                                                                                                                                      |
| 404（Not Found）             | 没有找到，该状态码表明服务器上无法找到请求的资源                                                                                                                                                                                          |
| 500（Internal Server Error） | 服务端内部错误。该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。                                                                                                                               |
| 503（Service Unavailable）   | 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求                                                                                                                                                                      |

### 2.3 HTTP头字段

+ 头部字段是KV的形式，key和value之间用":"分隔，最后用CRLF换行表示字段结束。例如：前后分离时经常遇到的要与后端协商传输数据的类型“Content-type:application/json”，这里的key就是Content-type，value就是application/json。HTTP头字段非常灵活，不仅可以使用标准里面的Host，connection等已有头，也可以任意添加自定义头，这就给了HTTP协议带来了无限的扩展可能
+ 头字段注意事项：
  + 字段名不区分大小写，字段名不允许出现空格，可以使用连字符"-"，但不能使用下户线"_"（有的服务器不会解析带"\_"的头字段）。字段名后面必须紧接着":"，不能有空格，而":"后的字段值前可以有多个空格
  + 字段的顺序是没有意义的，可以任意排序不影响语义
  + 字段原则上不能重复，除非这个字段本身的寓意允许：例如Set-Cookie
+ 常见头字段：HTTP协议中有非常多头字段，但基本可以分为以下类型
  + 请求字段：请求头中的头字段：Host，Referer
  + 响应字段：响应头中的头字段：Server
  + 通用字段：在请求头和响应头里面都可以出现：如Content-type，Connection

## 3. 持久连接

+ HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP连接。因此，每次的请求都会造成无谓的 TCP 连接建立和断开，增加通信量的开销。在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化
+ 为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法
+ 持久连接的特点是：在建立 1 次 TCP 连接后进行多次请求和响应的交互。只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。
+ 持久连接的好处
  + 在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。
  + 减少开销的那部分时间，使HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。
  + 持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。

## 4. Cookie / Session

 由于HTTP是无状态的，服务端单从网络连接上无法知道客户端身份，Cookie/Session引入解决了该问题。

### 4.1 Cookie

+ Cookie存储在`客户端浏览器`中。

+ Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态
+ Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。
+ 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

> 案例: 当在浏览器上登录邮箱的账号密码时，浏览器会提示你“记住密码”？。这就是Cookie机制
>
> 下次登录邮箱时，直接登录就可以，无需再次输入密码
>
> 1. 客户端请求连接服务器，服务器会给客户端颁发一个通行证。(set-cookie)
> 2. 客户端浏览器会把Cookie保存起来，这样，客户端下次连接时，携带该通行证
> 3. 浏览器检查该Cookie，以此来辨认客户端的身份
>
> 很多网站都有Cookie，Cookie不能跨域名，即：根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。
>

### 4.2 Session 会话

Session存储在`服务器`中（服务端维护了一张客户端明细表来确认客户端身份），因此，增加了服务器的存储压力。为了获得更高的存取速度，服务器一般把Session放在内存里。

客户端浏览器访问服务器的时候，服务器把客户端的信息以某种形式记录在服务器中，这就是Session。

1. 每个客户端的Session对象创建时期：客户端在第一次请求并连接服务器时
2. 客户端登录浏览器的时候，只需要查询服务器上保存的“客户端明细表”

### 4.3 Cookie/Session区别

1. 保存位置：cookie数据存放在客户的浏览器上，session数据放在服务器上
2. 安全性：cookie不是很安全，别人可以分析存放在本地的cookie，并进行cookie欺骗
3. 失效时间：session很容易失效，用户体验很差
4. 生命周期：Session是IE启动到IE关闭，(浏览器页面一关，session就消失了)。Cookie是预先设置的生存周期，或永久的保存于本地的文件

## 5. HTTP请求的完整过程

当用户在浏览器输入网址回车之后，网络协议都做了什么工作？

+ 首先干活的是浏览器应用程序，他要解析URL中的域名
+ 根据域名获取对应的IP地址，首先从网络缓存中查看，如果没有则从本机域名解析文件hosts(/etc/hosts)中查看，还是没有则要向DNS域名服务器发起域名解析请求拿到域名对应的IP
+ 拿到IP地址后，浏览器就可以与服务器建立TCP连接，发起三次握手
+ 握手建立之后，就开始组装HTTP请求报文，发送报文
+ 服务器收到请求报文后，开始请求报文解析，生成响应数据，发送响应数据
+ 浏览器收到响应后，开始渲染页面

## 6. HTTP/2.0

与HTTP/1.x相比，HTTP/2.0做了哪些改进呢？

- **多路复用**：允许在同一个时刻，对同一URL发起多次请求，同时对多次请求予以相应

  - HTTP/1.x，浏览器在同一个时间，请求同一URL具有一定数量的限制，超过该数量上限的请求都会被阻塞。
  - HTTP/2.0虽然只有一条TCP连接，但是在裸机上分成了很多stream

- 二进制分帧

  - 在不改动HTTP/1.x的语义/方法/状态码/URI等的情况下，HTTP/2.0是如何做到（突破HTTP/1.x的性能限制，改善传输性能，实现低延迟和高吞吐量）的呢？

  - 答：在应用层、传输层之间增加一个二进制分帧层！

    在二进制分帧层中，HTTP/2.0会将所有传输的信息分割成更小的消息和帧，并对它们采用二进制格式的编码

- 请求优先级

- 流量控制：类似于TCP滑动窗口来控制流量，数据接收方通过告诉发送方它能接收的窗口大小

- 服务器推送：客户端请求资源X，而服务器知道它很可能也需要资源Z的情况下，服务器会将资源Z一起推送给客户端

- **首部压缩**

- TLS：更安全的SSL

# 二. HTTPS协议

+ HTTPS = HTTP + 加密 + 认证 + 完整性校验，HTTPS是身披SSL外壳的HTTP。采用SSL后，HTTP就拥有了加密、证书、完整性校验的特性
+ 由于HTTP天生“明文”传输的特点，整个传输过程都是完全透明，任何人都能够在链路中截取获得，修改或者伪造请求/响应报文，数据不具有可信性，所以为了安全而生的HTTPS协议就诞生了
+ 使用HTTPS时，所有的HTTP请求和响应在发送到网络之前，都要进行加密

## 1. SSL/TLS

+ SSL为安全套接层，后面改名为TLS（传输层安全）

### 1.1 摘要算法

+ 摘要算法能够把任意长度的数据压缩成固定长度，而且独一无二的摘要字符串，就好像是给这段数据生产了一个数字指纹。任意微小的数据差异，都可以生产完全不同的摘要。所以可以通过把明文信息的摘要和明文一起加密进行传输，数据传输到对方之后再进行解密，重新对数据进行摘要，再对比就能发现数据有没有被篡改。这样保证了完整性。
+ 常见的摘要算法：md5，sha1，sha2，sha256

### 1.2 对称密钥加密算法

+ 对称密钥加密算法：编码，解码使用相同的密钥算法，如（AES,RC4,ChaCha20）

### 1.3 非对称密钥加密算法

+ 对称密钥加密算法：他有两个密钥，一个叫公钥，一个叫私钥。两个密钥是不同的，公钥可以公开给任何人使用，私钥必须严格保密。非对称密钥加密算法可以解决“密钥交换”的问题。网址密钥保证私钥，在网上任意分发公钥，你想要登录网址只要用公钥加密就行，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以无法破解。非对称密钥加密算法通常需要大量的数据运算，所以比较慢。如（DH,DSA,RSA,ECC）
+ 使用公钥加密，只能使用私钥解密
+ 使用私钥加密，只能使用公钥解密

### 1.4 实际运用

+ TLS里使用的混合加密方式，即非对称密钥加密算法和对称密钥加密算法结合起来。两者互相取长补短，既能高效的加解密，又能安全的密钥交换。流程如下：
  1. 通信开始的时候使用非对称密钥加密算法如RSA,ECDHE先解决密钥交换的问题
  2. 用随机数产生对非对称密钥加密算法使用的“会话密钥”，再用公钥加密。会话密钥很短，所以即使使用非对称密钥加密算法也能快速完成加解密
  3. 对方拿到密钥后用私钥解密，取出会话密钥。完成对称密钥的安全交换，后序就使用对称算法完成数据交换

## 2. 身份验证

依然考虑**中间人攻击**的情况，非对称加密的算法都是**公开**的，所有人都可以自己生成一对公钥私钥。

当服务端向客户端返回公钥A1的时候，中间人将其**替换**成自己的公钥B1传送给浏览器。

而浏览器此时一无所知，傻乎乎地使用公钥B1加密了密钥K发送出去，又被**中间人截获**，中间人利用自己的私钥B2解密，得到密钥K，再使用服务端的公钥A1加密传送给服务端，完成了通信链路，而服务端和客户端毫无感知

出现这一问题的核心原因是**客户端无法确认收到的公钥是不是真的是服务端发来的**。为了解决这个问题，互联网引入了一个公信机构，这就是CA。

+ 数字证书组成：CA信息，公钥用户信息，公钥，权威机构的签名，有效期
+ 数字证书的作用：
  + 通过数字证书向浏览器证明身份，防止域名解析的时候被黑客拦截，返回了黑客的服务器IP，进行跟黑客服务器进行TCP连接通信
  + 数字证书里面包含了公钥，保证公钥不是伪造

### 2.1 客户端校验证书

服务端在使用HTTPS前，去经过认证的CA机构申请颁发一份**数字证书**，数字证书里包含有证书持有者、证书有效期、公钥等信息，服务端将证书发送给客户端，客户端校验证书身份和要访问的网站身份确实一致后再进行后续的加密操作。

但是，如果中间人也聪明一点，**只改动了证书中的公钥部分**，客户端依然不能确认证书**是否被篡改**，这时我们就需要一些防伪技术了。

前面说过，非对称加密中一般公钥用来加密，私钥用来解密，虽然私钥加密理论上可行，但由于数学上的设计这么做并不适合，那么私钥就只有解密这个功能了么？

私钥除了解密外的真正用途其实还有一个，就是**数字签名**，其实就是一种防伪技术，只要有人篡改了证书，那么数字签名必然校验失败。具体过程如下

1. CA机构拥有自己的一对公钥和私钥
2. CA机构在颁发证书时对证书明文信息进行哈希
3. 将哈希值用私钥进行**加签**，得到数字签名

4. 明文数据和数字签名组成证书，传递给客户端。
5. 客户端得到证书，分解成明文部分Text和数字签名Sig1
6. 用CA机构的公钥进行**解签**，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）
7. 用证书里声明的哈希算法对明文Text部分进行哈希得到H
8. 当自己计算得到的哈希值H与**解签**后的Sig2**相等**，表示证书可信，**没有被篡改**

这时，签名是由CA机构的私钥生成的，中间人篡改信息后无法拿到CA机构的私钥，保证了证书可信。

### 2.2 CA机构

系统或浏览器中内置的CA机构的证书和公钥成为了至关重要的环节，这也是CA机构公信身份的证明，如果系统或浏览器中没有这个CA机构，那么客户端可以不接受服务端传回的证书，显示HTTPS警告。

实际上CA机构的证书是一条信任链，A信任B，B信任C，以**掘金的证书**为例，掘金向RapidSSL申请一张证书，而RapidSSL的CA身份是由DigiCert Global根CA认证的，构成了一条信任链。

各级CA机构的私钥是绝对的私密信息，一旦CA机构的私钥泄露，其公信力就会一败涂地。之前就有过几次**CA机构私钥泄露**，引发信任危机，各大系统和浏览器只能纷纷吊销内置的对应CA的根证书。

有些老旧的网站会要求使用前下载安装他自己的根证书，这就是这个网站使用的证书并不能在系统内置的CA机构和根证书之间形成一条信任链，需要自己安装根证书来构成信任链，这里的风险就要**使用者自己承担**了。

## 3. https请求过程（SSL的4次握手）

1. 用户在浏览器发起HTTPS请求（如 https://www.mogu.com/），默认使用服务端的443端口进行连接；
2. HTTPS需要使用一套**CA数字证书**，证书内会附带一个**公钥Pub**，而与之对应的**私钥Private**保留在服务端不公开；
3. 服务端收到请求，返回配置好的包含**公钥Pub**的证书给客户端；
4. 客户端收到**证书**，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；
5. 客户端生成一个用于对称加密的**随机Key**，并用证书内的**公钥Pub**进行加密，发送给服务端；
6. 服务端收到**随机Key**的密文，使用与**公钥Pub**配对的**私钥Private**进行解密，得到客户端真正想发送的**随机Key**；
7. 服务端使用客户端发送过来的**随机Key**对要传输的HTTP数据进行对称加密，将密文返回客户端；
8. 客户端使用**随机Key**对称解密密文，得到HTTP数据明文；
9. 后续HTTPS请求使用之前交换好的**随机Key**进行对称加解密。

# 三. HTTP和HTTPS区别

+ HTTP特点：
  + 无状态：协议对客户端没有状态存储，对事物处理没有记忆能力。例如访问一个网站需要反复进行登录操作
  + 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP3次握手4次挥手，和服务器重新建立连接。例如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次都需要重新响应请求，需要消耗不必要的资源
  + 基于请求和响应：基本的特性，由客户端发起请求，服务端响应
  + 简单快速，灵活
  + 通信是使用**明文**，请求和响应不会对通信方进行确认，无法保护数据完整性
+ HTTPS特点：
  + 内容加密：采用混合加密技术，中间者无法直接查看明文内容
  + 验证身份，通过证书认证客户端访问的是不是正确的服务器
  + 保护数据完整性：防止传输的内容不被中间人冒充或者篡改

### GET/POST

> 1. GET产生一个TCP数据包；POST产生两个TCP数据包
>
>    - 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）
>
>    - 对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
>
> 2. 请求参数是否会完整保留在浏览器的历史记录
>
>    GET √  POST X
>
> 3. URL长度限制
>
>    GET 有限制  POST 无限制
>
> 4. 对参数的数据类型 / 编码方式
>
>    GET只接受ASCII字符   POST没有限制
>
>    GET只能进行url编码   POST支持多种编码方式
>
> 5. 安全性(URL参数暴露)
>
>    GET比POST更不安全，因为参数直接暴露在URL上，POST放在Request body中
>
> 6. 缓存
>
>    GET请求会被浏览器主动cache   POST不会，除非手动设置
>
> 7. 回退
>
>    GET在浏览器回退时是无害      POST会再次提交请求

---

### Web攻击技术

- XSS跨站脚本攻击
- SQL注入攻击
- OS命令注入攻击
- 目录穿越攻击
- 会话劫持
- 密码破解
- DDOS攻击

https://mp.weixin.qq.com/s/vvUUhAanFHF_IyVT0G_42g

https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453141883&idx=2&sn=3b93d3bed05ec0094a0cae77bf1cc82c&scene=21#wechat_redirect