## 分层模型

OSI七层模型：物，数，网，传，会，表，应

TCP/IP四层模型：网（数据链路层/网络接口层），网，传，应

OSI七层模型中：应用层 + 表示层 + 会话层 = TPC/IP四层协议：应用层

OSI七层模型中：数据链路层 + 物理层 = TPC/IP四层协议：数据链路层



| OIS七层模型 | TCP/IP四层模型 | 协议                       |
| :---------- | :------------- | -------------------------- |
| 应用层      | 应用层         | http,ftp,nfs,ssh,telnet... |
| 表示层      |                |                            |
| 会话层      |                |                            |
| 传输层      | 传输层         | TCP,UDP                    |
| 网络层      | 网络层         | IP,ICMP,IGMP               |
| 数据链路层  | 数据链路层     | 以太网帧协议，ARP          |
| 物理层      |                |                            |

## 网络应用程序设计模型

C/S：Client/Server，也叫 客户机/服务器模式

B/S：Browser/Server，即浏览器/服务器结构



|      | C/S                                              | B/S                               |
| ---- | ------------------------------------------------ | --------------------------------- |
| 优点 | 缓存大量数据<br/>协议选择灵活<br/>速度快         | 安全性<br/>跨平台<br>开发工作量小 |
| 缺点 | 用自定义的协议安全性差<br>跨平台<br>开发工作量大 | 不能缓存大量数据<br>严格遵守http  |

## 传输

网络传输流程：数据没有封装之前，是不能在网络中传递。

数据封装过程：数据->应用层->网络层->链路层

UDP：每次发送数据包时都是需要寻路，这样每次走的路径可能都不一样

TCP：如果有一个链路能通，那么TCP以后就都通过这条链路来发送数据包，只有最开始的时候寻路

## 协议

> ARP协议：根据IP地址获取mac地址
>
> 以太网帧协议：根据mac地址，寻找下一跳位置，完成数据包传输

> IP协议：
>
> ​	版本：IPv4，IPv6		-- 4位
>
> ​	TTL：time to live。	设置数据包在路由节点中的跳转上限。每经过一个路由节点，该值-1。当值位0时，将该数据包抛弃。
>
> ​	源IP：32位				   -- 4字节
>
> ​	目的IP：32位		       -- 4字节
>
> IP地址：可以在网络环境中，唯一标识一台主机
>
> 端口：可以在网络的一台主机上，唯一标识一个进程
>
> **IP地址+端口号：可以在网络环境中，唯一标识一个进程**

> UDP协议：
>
> ​	16位：源端口号	2^16 = 65536
>
> ​	16位：目的端口号
>
> + UDP协议不面向连接，也不保证传输的可靠性：
>   + 发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。
>   + 接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。
>   + 接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误

> TCP协议：
>
> ​	16位：源端口号	2^16 = 65536
>
> ​	16位：目的端口号
>
> ​	32位：序号
>
> ​	32位：确认序号
>
> ​	6个标志位
>
> ​	16位窗口大小。	2^16 = 65536

# TCP和UDP的对比

|  对比项  |                             TCP                              |                             UDP                              |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   概念   | 面向连接的，可靠数据包传输<br>对于不稳定的网络层，采取完全弥补的通信方式<br>丢包重传 | 无连接的，不可靠的数据报传输<br>对于不稳定的网络层，采取完全不弥补的通信方式<br/>默认还原网络状态 |
|   优点   |                             稳定                             |                  传输速度快，效率高，开销小                  |
|   缺点   |                  传输速度慢，效率低，开销大                  |                            不稳定                            |
| 使用场景 |                     大数据传输，文件传输                     |                       对实时性要求较高                       |



## 网络套接字（socket）

* socket：一个文件描述符指向一个套接字（**该套接字内部由内核借助两个缓冲区实现（一个读缓存，一个写缓存）**）

* 在网络通信过程中，**套接字一定是成对出现**。一端的发送缓冲区对应对端的接收缓冲区。使用同一个文件描述符操作发送缓冲区和接收缓冲区。

* 网络字节序：网络字节序是大端法。本地字节序是小端法。所以网络字节序和本地字节序需要互相转换。

>
    > 小端法：高位存高地址，。低位存低地址
    >
    > 大端法：高位存低地址，。高位存低地址
    >
    > 地址：0x12345678
    >
    > |      | 小端法 | 大端法 |
    > | ---- | ------ | ------ |
    > | 高位 | 12     | 78     |
    > |      | 34     | 56     |
    > |      | 56     | 34     |
    > | 低位 | 78     | 12     |

> 套接字原理：![套接字原理](https://github.com/594301947/knowledge/blob/master/%E7%BD%91%E7%BB%9C/images/%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8E%9F%E7%90%86.png)

# socket编程

## 字节转换函数

```C
#include <arpa/inet.h>
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);
h表示host，n表示network，l表示32位长整数，s表示16位短整数。
如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转
换，将参数原封不动地返回
```

## IP地址转换函数

```C
#include <arpa/inet.h>
int inet_pton(int af, const char *src, void *dst); // ip字符串转换成网络字节
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); //网络字节转换成ip字符串
```

## 网络套接字函数

> **socket：创建套接字**
>
> ```C
> #include <sys/types.h> /* See NOTES */
> #include <sys/socket.h>
> int socket(int domain, int type, int protocol);
> domain:
>     AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址
>     AF_INET6 与上面类似，不过是来用IPv6的地址
>     AF_UNIX 本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用
> type:
>     SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类
>     型，这个socket是使用TCP来进行传输。
>     SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。
>     SOCK_SEQPACKET 这个协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的
>     接受才能进行读取。
>     SOCK_RAW 这个socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使
>     用该协议）
>     SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数
>     据包的顺序
> protocol:
>     0 默认协议
> 返回值：
> 	成功返回一个新的文件描述符，失败返回-1，设置errno
> ```
>
> + socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据
> + 如果socket()调用出错则返回-1。
> + 对于IPv4，domain参数指定为AF_INET。
> + 对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。

> **bind：绑定本主机端口号和ip**
>
> ```C
> #include <sys/types.h> /* See NOTES */
> #include <sys/socket.h>
> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
> sockfd：
>     socket文件描述符
> addr:
>     构造出IP地址加端口号
> addrlen:
>     sizeof(addr)长度
> 返回值：
>     成功返回0，失败返回-1, 设置errno
> ```
>
> + 服务器程序所监听的网络地址和端口号通常是**固定不变**的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。
> + 客户端一般情况下不主动调用bind函数，**不主动调用的话系统会自动帮忙调用bind函数，并且绑定一个随机端口。**
> + bind()的作用：是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。
> + 网络地址为**INADDR_ANY**，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，**这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址**。
>
> ```C
> 例子：
> struct sockaddr_in servaddr;
> bzero(&servaddr, sizeof(servaddr));
> servaddr.sin_family = AF_INET;
> servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
> servaddr.sin_port = htons(8000);
> ```

> **listen：设置同一时刻监听队列的最大上限**
>
> ```C
> #include <sys/types.h> /* See NOTES */
> #include <sys/socket.h>
> int listen(int sockfd, int backlog);
> sockfd:
>     socket文件描述符
> backlog:
>     排队建立3次握手队列和刚刚建立3次握手队列的链接数和
> ```
>
> + 服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，**如果接收到更多的连接请求就忽略**。

> **accept：接收客户端发起连接请求**
>
> ```C
> #include <sys/types.h> /* See NOTES */
> #include <sys/socket.h>
> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
> sockdf:
> 	socket文件描述符
> addr:
> 	传出参数，返回链接客户端地址信息，含IP地址和端口号
> addrlen:
> 	传入传出参数（值-结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小。传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）
> 返回值：
> 	成功返回一个新的socket文件描述符，用于和客户端通信，失败返回-1，设置errno
> ```
>
> + 三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来
> + **接收一个连接，内核维护了半连接队列和一个已完成连接队列，当队列为空的时候，accept函数阻塞，不为空的时候accept函数从上边取下来一个已完成连接，返回一个文件描述符。**

> **connect：与服务端建立连接**
>
> ```C
> #include <sys/types.h> /* See NOTES */
> #include <sys/socket.h>
> int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
> sockdf:
>     socket文件描述符
> addr:
> 	传入参数，指定服务器端地址信息，含IP地址和端口号
> addrlen:
> 	传入参数,传入sizeof(addr)大小
> 返回值：
> 	成功返回0，失败返回-1，设置errno
> ```
>
> + 客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址

