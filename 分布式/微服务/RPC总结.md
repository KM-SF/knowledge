## 最基础的RPC

RPC叫做远程过程调用，就是客户端调用服务端提供的接口就像调用本地函数一样。
先说下最基础的RPC吧，一个最基础RPC的核心功能主要有3点：

1. 服务寻址：我们要想远程调用像本地调用一样。就需要给提供的所有函数都提供一个唯一ID。
服务端保存这个ID和函数的映射关系
客户端进行远程调用时，需要将这个ID传递过来，然后服务端进行查找并调用
2. 数据编解码：客户端远程调用需要将对象序列化成二进制流，再通过网络传输。服务端也需要将二进制流反序列化成可识别的对象
3. 网络传输：客户端和服务端之间的通信协议。具体协议没有限制，可以是TCP，可以是HTTP等。

## 微服务1.0 RPC 

而在微服务的PRC中，在上面基础上增加一些功能：
服务注册与发现，负载均衡，限流熔断，降级，服务监控和治理

1. 服务注册与发现：
基础模式下：客户端写死了服务端的IP和端口。当服务端想扩容时，需要重新编译客户端代码，这样很不友好。
所以我们可以将服务端的IP和端口都注册到注册中心，这样可以支持动态扩容。
然后客户端只需要注册中心查询即可得到服务IP和端口
2. 负载均衡
我们对外可以提供多个服务提供方，然后通过负载均衡策略可以返回一个最佳的提供方给客户端使用
3. 限流：我们需要在高并发请求下，为了保护系统，对访问服务的请求进行数量限制，从而防止系统被大量请求压垮。
常见的限流算法有：计数器法，滑动窗口，漏桶和令牌桶
4. 熔断：
当我们调用下游服务时，如果下游服务出现过多的超时或者失败的情况。
我们为了保证自己服务不受影响，不在调用下游服务，直接返回结果。
5. 降级：
当系统压力较大的时候，无法提供足够的请求时候。
为了防止系统在进一步恶化，我们可以通过降级的手段（关闭一些非核心服务），进一步保护。
6. 服务监控和治理：统计接口的成功率和失败率，然后上报的监控中心，再由监控中心通知开发人员进行排查

## 微服务2.0 Service mesh

微服务1.0版本，有两个缺点：
就是它往往以jar包或者.so的方式加入到服务中。这样jar包或者.so进行升级时，这样服务也需要跟着一起升级，
业务和RPC框架耦合性太大。
第二个是跟语言相关。有一个服务用java写，而另外个服务是go写。那么RPC就需要提供java版本和go版本

所以就有微服务2.0版本的**Service mesh**（sidecar边车）
服务网格是一个基础设施层，用于处理服务间通信，屏蔽复杂的通信机制。
将通用功能（负载均衡，服务发现，认证授权，等等）抽离出来，做到框架与业务的解耦，服务只需要更关注业务逻辑即可。
他是以网络代理（sidecar边车）的方式和应用部署在一起。
对应用是透明的，可以进行单独升级。也与语言无关，只需要服务和Service Mesh通信就行。