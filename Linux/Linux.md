#  Linux工具教程：

https://linuxtools-rst.readthedocs.io/zh_CN/latest !!!

# top

+ top的信息摘抄于：[top linux下的任务管理器](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html)

+ top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。
+ 我们常常用top命令来查看哪些进程CPU占用高，内存占用高
+ 在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况；

```
    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00
    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie
    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st
    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers
    Swap:   397308k total,    67192k used,   330116k free,    71900k cached
    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init
    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd
    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0
    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0
```

+ 第一行：时间相关
  + 09:14:56 ： 系统当前时间
  + 264 days, 20:56 ： 系统开机到现在经过了多少时间
  + 1 users ： 当前2用户在线
  + load average: 0.02, 0.04, 0.00： 系统1分钟、5分钟、15分钟的CPU负载信息(数字/CPU核数 在0.00-1.00之间正常)正在运行的进程 + 准备好等待运行的进程  在特定时间内（1分钟，5分钟，10分钟）的平均进程数 

+ 第二行：进程数量相关
  + Tasks：任务;
  + 87 total：很好理解，就是当前有87个任务，也就是87个进程。
  + 1 running：1个进程正在运行
  + 86 sleeping：86个进程睡眠
  + 0 stopped：停止的进程数
  + 0 zombie：僵死的进程数
+ 第三行：CPU信息
  - Cpu(s)：表示这一行显示CPU总体信息
  - 0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。
  - 0.7%sy：内核占用CPU时间百分比
  - 0.0%ni：改变过优先级的进程占用CPU的百分比
  - 99.3%id：空闲CPU时间百分比
  - 0.0%wa：等待I/O的CPU时间百分比
  - 0.0%hi：CPU硬中断时间百分比
  - 0.0%si：CPU软中断时间百分比
  - 注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；

- 第四行
  - Men：内存的意思8175320kk 
  - total：物理内存总量8058868k 
  - used：使用的物理内存量116452k 
  - free：空闲的物理内存量283084k 
  - buffers：用作内核缓存的物理内存量
- 第五行：SWAP空间
  - Swap：交换空间
  - 6881272k total：交换区总量
  - 4010444k used：使用的交换区量
  - 2870828k free：空闲的交换区量
  - 4336992k cached：缓冲交换区总量
- 进程信息
  - 再下面就是进程信息：
  - PID：进程的ID
  - USER：进程所有者
  - PR：进程的优先级别，越小越优先被执行
  - NInice：值
  - VIRT：进程占用的虚拟内存
  - RES：进程占用的物理内存
  - SHR：进程使用的共享内存
  - S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数
  - %CPU：进程占用CPU的使用率
  - %MEM：进程使用的物理内存和总内存的百分比
  - TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。
  - COMMAND：进程启动命令名称

https://blog.csdn.net/zhangchenglikecc/article/details/52103737

# buffer，cache和swap

当有应用需要读写磁盘数据时，由系统把相关数据从磁盘读取到内存，如果物理内存不够，则把内存中的部分数据导入到磁盘，从而把磁盘的部分空间当作虚拟内存来使用，也称为Swap。

如果给所有应用分配足够内存后，物理内存还有剩余，linux会尽量再利用这些空闲内存，以提高整体I/O效率，其方法是把这部分剩余内存再划分为cache及buffer两部分加以利用。
从磁盘读取到内存的数据在被相关应用程序读取后，如果有剩余内存，则这部分数据会存入cache，以备第2次读取时，避免重新读取磁盘。当一个应用程序在内存中修改过数据后，因为写入磁盘速度相对较低，在有空闲内存的情况下，这些数据先存入buffer，在以后某个时间再写入磁盘，从而应用程序可以继续后面的操作，而不必等待这些数据写入磁盘的操作完成。
**如果在某个时刻，系统需要更多的内存，则会把cache部分擦除，并把buffer中的内容写入磁盘，从而把这两部分内存释放给系统使用，这样再次读取cache中的内容时，就需要重新从磁盘读取了**。

通过以上分析可以得知，空闲物理内存不多，不一定表示系统运行状态很差，因为内存的cache及buffer部分可以随时被重用，在某种意义上，这两部分内存也可以看作诗额外的空闲内存。swap如果被频繁调用，bi，bo长时间不为0，则才是内存资源是否紧张的依据。

## 1. free命令

1. total：物理内存实际总量
2. used：这块千万注意，这里可不是实际已经使用了的内存哦，这里是总计分配给缓存（包含buffers 与cache ）使用的数量，但其中可能部分缓存并未实际使用。
3. free：未被分配的内存
4. shared：共享内存
5. buffers：系统分配的，但未被使用的buffer剩余量。注意这不是总量，而是未分配的量
6. cached：系统分配的，但未被使用的cache 剩余量。buffer 与cache 的区别见后面。
7. buffers/cache used：这个是buffers和cache的使用量，也就是实际内存的使用量，这个非常重要了，这里才是内存的实际使用量哦
8. buffers/cache free：未被使用的buffers 与cache 和未被分配的内存之和，这就是系统当前实际可用内存。千万注意，这里是 三者之和，也就是第一排的 free+buffers+cached，可不仅仅是未被使用的buffers 与cache的和哦，还要加上free(未分配的和)
9. swap，这个我想大家都理解，交换分区总量，使用量，剩余量

## 2.buffer：

缓冲区，一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。

**buffer : 作为buffer cache的内存，是块设备的读写缓冲区**

**buffer（缓冲）是为了提高内存和硬盘（或其他I/O设备）之间的数据交换的速度而设计的。** 

**缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能**。linux有一个守护进程定期清空缓冲内容（即写入磁盘），也可以通过sync命令手动清空缓冲。

buffer是即将要被写入磁盘的，而cache是被从磁盘中读出来的。 buffer是由各种进程分配的，被用在如输入队列等方面。一个简单的例子如某个进程要求有多个字段读入，在所有字段被读入完整之前，进程把先前读入的字段放在buffer中保存。

## 3.cache：

Cache：高速缓存，**是位于CPU与主内存间的一种容量较小但速度很高的存储器**。由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，这样就减少了CPU的等待时间，提高了系统的效率。Cache又分为一级Cache（L1 Cache）和二级Cache（L2 Cache），L1 Cache集成在CPU内部，L2 Cache早期一般是焊在主板上，现在也都集成在CPU内部，常见的容量有256KB或512KB L2 Cache。

**cache: 作为page cache的内存， 文件系统的cache。**如果 cache 的值很大，说明cache住的文件数很多。如果频繁访问到的文件都能被cache住，那么磁盘的读IO 必会非常小。 

**cache（缓存）是为了提高cpu和内存之间的数据交换速度而设计的，也就是平常见到的一级缓存、二级缓存、三级缓存。**cpu在执行程序所用的指令和读数据都是针对内存的，也就是从内存中取得的。由于内存读写速度慢，为了提高cpu和内存之间数据交换的速度，在cpu和内存之间增加了cache，它的速度比内存快，但是造价高，又由于在cpu内不能集成太多集成电路，所以一般cache比较小，以后intel等公司为了进一步提高速度，又增加了二级cache，甚至三级cache，它是根据程序的局部性原理而设计的，就是cpu执行的指令和访问的数据往往在集中的某一块，所以把这块内容放入cache后，cpu就不用在访问内存了，这就提高了访问速度。当然若cache中没有cpu所需要的内容，还是要访问内存的。

cache经常被用在磁盘的I/O请求上，如果有多个进程都要访问某个文件，于是该文件便被做成cache以方便下次被访问，这样可提高系统性能。

## 4.buffer和cache的特点

### 共性：

都属于内存，数据都是临时的，一旦关机数据都会丢失。

### 差异：(先理解前两点，后两点有兴趣可以了解)

1. buffer是要写入数据；cache是已读取数据。
2. buffer数据丢失会影响数据完整性，源数据不受影响；cache数据丢失不会影响数据完整性，但会影响性能。
3. 一般来说cache越大，性能越好，超过一定程度，导致命中率太低之后才会越大性能越低。buffer来说，空间越大性能影响不大，够用就行。cache过小，或者没有cache，不影响程序逻辑（高并发cache过小或者丢失导致系统忙死除外）。buffer过小有时候会影响程序逻辑，如导致网络丢包。
4. cache可以做到应用透明，编写应用的可以不用管是否有cache，可以在应用做好之后再上cache。当然开发者显式使用cache也行。buffer需要编写应用的人设计，是程序的一部分。

## 5. swap

Linux 的交换分区（swap），或者叫内存置换空间（swap space），是磁盘上的一块区域，可以是一个分区，也可以是一个文件，或者是他们的组合。

SWAP的作用类似Windows系统下的“虚拟内存”。当物理内存不足时，拿出部分硬盘空间当SWAP分区（虚拟成内存）使用，从而解决内存容量不足的情况。

SWAP意思是交换，顾名思义，当某进程向OS请求内存发现不足时，OS会把内存中暂时不用的数据交换出去，放在SWAP分区中，这个过程称为SWAP OUT。当某进程又需要这些数据且OS发现还有空闲物理内存时，又会把SWAP分区中的数据交换回物理内存中，这个过程称为SWAP IN。

当然，swap大小是有上限的，一旦swap使用完，操作系统会触发OOM-Killer机制，把消耗内存最多的进程kill掉以释放内存。

https://blog.csdn.net/qq_27516841/article/details/99682823

http://t.zoukankan.com/gzxbkk-p-7325293.html