# 一. 哈希表

哈希表：也叫做散列表。是根据关键字和值（Key-Value）直接进行访问的数据结构。

它通过关键字 key 和一个映射函数 Hash(key) 计算出对应的值 value，然后把键值对映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数（散列函数），用于存放记录的数组叫做 哈希表（散列表）。 

哈希表的关键思想是使用哈希函数，将键 key 和值 value 映射到对应表的某个区块中。可以将算法思想分为两个部分：

+ 向哈希表中插入一个关键字：哈希函数决定该关键字的对应值应该存放到表中的哪个区块，并将对应值存放到该区块中
+ 在哈希表中搜索一个关键字：使用相同的哈希函数从哈希表中查找对应的区块，并在特定的区块搜索该关键字对应的值

# 二. 哈希函数

哈希函数：将哈希表中元素的关键键值映射为元素存储位置的函数。一般来说，哈希函数会满足以下几个条件：

+ 哈希函数应该易于计算，并且尽量使计算出来的索引值均匀分布，这能减少哈希冲突
+ 哈希函数计算得到的哈希值是一个固定长度的输出值
+ 如果 Hash(key1) 不等于 Hash(key2)，那么 key1、key2 一定不相等
+ 如果 Hash(key1) 等于 Hash(key2)，那么 key1、key2 可能相等，也可能不相等（**会发生哈希碰撞**）

常用方法：

1. HashFunc(key)%$HashNum：hash函数得到hash值后取模桶个数
2. HashFunc(key)&(1<<$HashNum-1)：hash函数得到hash值跟 左移（桶个数-1）按位与。要求桶个数是2个倍数

# 三. 哈希冲突处理

哈希冲突：不同的关键字通过同一个哈希函数可能得到同一哈希地址，即 key1 ≠ key2，而 [Hash](https://so.csdn.net/so/search?q=Hash&spm=1001.2101.3001.7020)(key1) = Hash(key2)，这种现象称为哈希冲突。

## 1. 开放地址法：

开放地址法：指的是将哈希表中的「空地址」向处理冲突开放。当哈希表未满时，处理冲突时需要尝试另外的单元，直到找到空的单元为止。`H(i) = (Hash(key) + F(i)) \% m，i = 1, 2, 3, ..., n (n ≤ m - 1)`

## 2. 链地址法

链地址法：将具有相同哈希地址的元素（或记录）存储在同一个线性链表中。 链地址法是一种更加常用的哈希冲突解决方法。相比于开放地址法，链地址法更加简单。 假设哈希函数产生的哈希地址区间为 [0, m - 1]，哈希表的表长为 m。则可以将哈希表定义为一个有 m 个头节点组成的链表指针数组 T。

链表长度过长时会影响查询的性能，这个时候可以将链表转换为红黑树。

# 四. rehash

当hash碰撞过多时，会导致查询的效率过低，这个时候就需要rehash，扩大hash桶的个数。

## 1. 负载因子

1.负载因子越大，发生哈希冲突的概率越大，数组长度就会偏小，但节省空间

2.负载因子越小，发生哈希冲突的概率越小，数组长度就会偏大，但浪费空间

3.当**元素个数/负载因子>=数组长度**，此时我们**认为冲突比较严重**，需要**进行扩容**，即假设此时HashMap的哈希表长度为16，当元素个数超过12就会发生扩容。

## 2. 渐进式扩容

1. 先申请原来hash桶的个数的两倍（此时有两个桶，新桶和旧桶）
2. 启动一个索引idx=0，用于rehash
3. 每进行一次增删改查时，就将idx所在的旧桶下标的链表元素，重新计算hash值，然后取模（新桶个数）放到新桶中。
4. 直到idx等于旧桶大小，表示旧桶全部rehash完成
5. 这个时候用新桶替换旧桶（指针指向新桶）